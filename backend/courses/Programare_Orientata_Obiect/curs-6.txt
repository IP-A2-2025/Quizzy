***************Beginning Page***************
***************page number:1**************
‘\ Gavnlut Dragos
O O P Course s

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
> Casts
> Macrcvs
b Macros vs Inline
> Literals
Summary b Templates
> Function templates
> Class templates
> Template specialization
> Compile-time assertion checking

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
> Casts

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Casts
> Assuming that a class A is derived from a class B, than it is possible for i
an object of type A to be converted to an object of type B. E
> This is a normal behavior (obviously A contains every member defined
in B). E
> The conversion rules are as follows: l
- It will always be possible to convert a class to any of the classes that it
inherits
4. It is not possible to convert from a base class to one of the classes that
inherits it without an explicit cast
~:~ If the cast operator is overwritten, none of the above rules apply,

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Casts
> Let's consider the followin code: OHS“ Field/Va’
APP-CPD 100000 c‘
2:223:01; :::::: :z; 1?‘ 1°°°°“ "' D
m“ = z mm A, pm“ I ( Wm“ m <1, <1; )1 —
vnd mnllhmxd) (
3: 3 ; 3; “1 300000 c.al
L‘ 300004 c.a2 ‘
> ssuming t e pointer “c” points to t e o set — I
300000, what do we need to do to obtain a 300008 c0a3 3
pointer to an object of type B’ Z 300012 c.b1 L
300016 C.bZ ‘
300020 c.c3
300024 c.c4

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Casts
> Let's consider the lollowin code: Offset HEM/Var
Appxpp 100000 c“
(1m A ( Mm: m ,1, ,1, =1; >; 100004 b‘
Um . ‘ MM m m‘ m‘ >0 i
ms; c = mm A‘ Mm a 4 WM“: m n‘ a; >1 —
vum numb/01d) l
:2 § i 2:: ‘O 300000 c.a1
—’ h h ‘f —300004 c.aZ
> Assummg t e painter “c” poinlsto t e u set —
300000, what do we need to do to obtam a 300008 c0a3
pointer to an object of type B’?
> The simples way is m add 1+12| w the offset a ,
where “c” variable points. Tins wilt position 300020 (£3
the new pointer w a Locatiun 0r a B type 300024 c c4

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Casts
class A void main(void)
{ { ‘1
public: s b; 1‘

int a1,a2,a3; A* a = ab;
)J } E
Elass szublic A ;Bb;
public = It?" ﬁlbl
)Imt b1,bZ; ;A' a : ﬁb;

’ lea eax,[b]

muv dword ptr [a],eax

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Casts
i i I - m
public: C c; I“ ‘ix-M r ‘
int a1,a2,a3; A* a; n Z J?" M" "‘ “1"” ‘
); 5* b; in‘ “mm I
E mlﬂsv I
class B m in: mm} 1
7 ) W w; D v a P’ e ,w ‘
int b1,b2; 7mm,‘ my)‘: m mp 1mm ‘
)' “W12? idmwmmraéh
class C:public A,B '—H
{
public:
int c1 ,cZ;
); I,

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Casts ‘
public: C cs 1'1" ,}I,*“',‘,. .
int a1,a2,a3; A“ a; n Z m, V ‘
)1 B‘ b’ test will . ‘Z *
je my“ slzeuflAl
class B a Z Q1 1e: e:X,[¢]
{ b 81C’ add “>980: (acn 1 11)
Imv mm n- !b 4w- .101 1
PM“ Mu: wig" P 1 ‘
int b1,b2; 'W' Mm ptr [mp-mmm
)' mils} “mm m [mp-1am]
class Czpublic A)‘; w
{
public: '
int c1,c2;
);

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Casts
class A void main(void) Disasm
{ { :2- (c-yb; d d [v1 12:
public: L' <; ‘W “I” P" J

4 "1qu

mt a1 ,a2,a3; A a, 3;: ennmm w [>1 svzeoﬂm
). R. h. sub “hm. (urn - 12)

' '1 mv duorﬂ w [ebD-ﬂﬁhheax

t‘ u, jmp mum
class B a Z 3p MlLl_nsn
{ h 8 ' mav duordnn[ehp1wh]-0
, [; unmask

public: m eckm'mrd w [lhpdlm]

int b1,b2; Imv mm ptr [c2],!cx
);
class Czpublic A,B
{
public:

int c1,c2; '
);

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Casts
> Let's anal ze the inllowin- Iroram: I
APMPP I
class A i Mm: m .1, .1, .1; >;
class a i mm: m m. hz: >1 i
ms; c z pnvil: At pnvil: s 4 pm“; m qt ‘z; )1 i
void m21ﬂ(vuld) i
i
< (t
m i Z m
i <2:
> This type of cast can be performed only if the inheritance is public‘
> In this example, there ls a Clear translation from “A'” l0 “C'”, but, 35A IS
inherit using private access modiﬁer, this cast is nut allowed.

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Whenever we discuss about conversvon between classes that Share an
mheritance relatvonshw, there are tWO nutvons that Heed t0 be mentvuned:
“may B downcast C Inherits B lnheritsA
Lets assume that We have the fottowmg dasses: tugs M mm m a, aZ, a3, I»
(lat; B WM): u M1“ m n1, n2‘ u
We have the Ionawmg termmotogy: m“ < mm a ( MM“ w rl, n. :>.
maxim; : From child to parent ¢i convert to base
n - gm‘: Enbjcn, ~ Always possible and safe
‘i
and
void mm < : From parent to chitd
A mm, , - - - .
I ‘ an“ Z (mummo, Requires EXPlICIt cast or dynarmc cast
y ~ Unsafe 1!!

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Upcasting produces an interesting secondary effect catlcd abject slicing
Tr... t t
m .1. .1. .3.
nun: value) ant/aim!» plume), tub/am!) Q
)r
5mm B M... . t
wt m, o2, - .
BUM vain!) R(valu:'valu=). tub/aim). bib/aim) U DoSomelhmg has ONE parameter Of tYPEA
)r
vmll DuSumeUuYYgUl ubleck) (
Wet .1... .14., .Her. , m... .1, m... .1, m... ..>,
)
van! numb/uni) (
531335333);wa DoSnmelhing is called wrtrr a parameter pr type a
)
This codc wrlt epmpite and Wm print on trre scrccn: a1 zsez 25,53 25. chc
an mstanee of B can atways be casted w vts base class, you can slice from an
object pr type B yetues yr and v2 and you wrtl obtam an object of type A (hat
can ne send to mnetren DoSomethmg.

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Upcastmg produccs an mtcn (an B: m :ing
? —
m H. H. u‘
.(m mm Wm» mm
)y
5W. B Mm A (
W m, n2.
“(m Wm Mumvvmn. bu
M
vmd nusumsumvgln ubjsnk) (
WW Md, am, 3km
)
vum mqumd) (
B WW5»
MEMWLDVQDM»
>
Tm nodc Wm mmpm and ‘A , 25 chc
(all DnSamethlng
an Instance m B can atways b‘ e from an
object of type B values w and v‘ 4 4 J‘ type A mm
can ne send m functvon DoSomethmg.

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
b Ucastin- deueeS an interestin- Seconda effect called Obi“ slicin-
APP-cw
mm A l
m i1, n, n; l 1‘ w *
‘(m v.1“) = luv-m), mum), 12m)“ r " “1 W”
Mans! M m) . mm» < l
n
strusc'tlh; 9:211‘ A l all a: :I
nun! 9min Annuvvnuab mum), m “gmgmmb 9mm;
h
ma wmmanm mm» ( ,,
Frimf(“n:xn, ‘14.1, as:m\n“, whicncml
1 , /
was mammal l
a Labjutﬁ);
} wmmamuhjm»; cull humming
> However, if we add a copy'constructor to class A, it would be used,

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Upcast / downcast
b Ucastin Induces an interestin- seconda effect called DbICt slicin-
APP-cw
mm A t
int i1, i1, a);
‘(m um) = “(v-m), mum), nah/nun) n a momma);
anst It! m) . mum < i
22"“ I = um‘ A t
m m, n; call am
y Bun: ulna): ‘mm-v.1“), mm“), mm“ A Urnw Z rump”;
vém mainbwiﬂ) (
I “mam; /
A Labial: - whim;
) “11 AMA
> However, if we add a copy-constructor to class A, it would he used‘ This way
of creating a object from another object that inherits it, is another usage of
objezt slitting‘

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Casts
> Let's anal e the followin- code: ‘a
APP-CPD I
chss A { puhhc: 1n! u, a2, I3; ); 2
class I i public: Ant h!‘ b1; h ‘
m“ c 1 Wm: A, Wm: I c Dllhlicz m <1, <1; n ‘
mm mllllvnlﬂ} I
1 ‘
c ‘1
-~ h Z m
’—
> What happens when we convert (cast) Etc to B‘?

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Casts 1
> Let's anal 1e the (ullowin- code: 1
APP-CPD I
(1m ‘ ( Mm: m =1, =1, =1; >; \
class l ( Mm: 1m m‘ m; >; ‘
class c z puhht A‘ mm a ¢ FNMA‘: m ‘L a; >1 1
void mzlﬂ(vuld) I
( lea emu] \
if; 7 ‘ v (m Hum
) ' “ je nuuiun
1“ E£>l,[[]
add anew
mov dwurd pt!‘ [ebp'HFEh],eo:
> What happens wh- imp nuns
NULL cnsn ,
mov award ply‘ [:hp'HFElv],B
nuns: '
mov mmmm an‘ [swam]
mm ‘mm pt!‘ [b],édl

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Casts
> Let's anal e the Iollowin- code: I
APP-CPD r
(his r r Mm: m .1, .1, =1; ); ‘
a»; I r pm“: m n1‘ m n ‘
m“ c 1 Wm: A, Wm: I c Dllnici m <1, <1; 1; r
mm mnlllvnxd) r
{ r
c ‘1
|~ n Z m
)—
> But - what if we DO NOT WANT to change the address “b” points to when the
cast is performed Z What if we want “b” to point to the exact same address as
“8c” 2

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Casts
> Let's anal e the Iollowin Code:
APP~¢PP
(his A r Izllhhc: m .1, .1, =1; n
a“; I t mu“ m n1‘ m r;
class c 1 pm“ A, Dllhlic I t Dllhlic: m <1, <1; n
wad mnlllwnd)
r ~ r
) ‘x
> But - what if we DO NOT WANT to change the address “b” points to when the A
cast is performed Z What if we want “b” to point to the exact same address as
“8c” ?
> One solution is to use a double cast (ﬁrst cast “ﬁr” to a void‘, and then cast
that void‘ to a B‘ b

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
Casts

> Let's anal e the Iollowin- code: I
APMPP r
d... . r mm. m .1, .1, .1; );
a... a t mm: m u. m n ‘
<1... < 1 public A, pum< I t Dllhlic: int <1, <1; n r
wad "mum; r
{ .
,

> But - what if we DO NOT WANT to change the address “b” points to when the
cast is performed Z What if we want “b” to point to the exact same address as
“8c” 2 ,,

> Another solution is to use reinterpreticast keyword from C» to do this!"

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Casts
> C‘+ has Several ways l keywords that can be use t0 specify how a cast should
behave:
> smtic_cast
> reinterprel_cnsl
> dynamic_msl
> canst_cnst X
> All of them have the following syntax:
static_:ast (type to cast w (expression) ‘
cnnst_cast <type to cast to> (expression)
dynamic_cast (type m cast to) (expression)
reinterpret_cast (type m cast a» (expression)

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
re1nterpret_cast

> reinterpret_cust is the simplest cast mechanism that translates in Changing
the type of a pointer, while maintaining the same address where it points tot
reinterpreLcast <tip*> (ptr) Q ((tip‘) ( (v0id*) ptr))

> This is the fastest cast possible (it guarantees very few assembly instructions
that will be used for pointer type translation),

> However, it has a downside as it allows casts between pointers of , l‘
incompatible types‘ The result may obtain a pointer with a data that has a
weird memory alignment, invalid pointers, etc. "

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
re1nterpret_cast I‘
> Let's anal ze the (ullowin- Iroram: I
APMPP ‘
d.” ‘ { Mn“ m .., .1, .1; n
Um . ‘ Mm: m m. n1: n ‘
class C z anvil: A‘ anvil: l ( DUNK: ml ‘L c2; )1 ‘
Wm mmvnm) ‘
{
I n
)—
> This code val not compile. Wmle there vs a valid conversion from a pointer of type
C' m a pmmer 01 type A‘ due tn the Inheritance, as (Lass A ls unhem m a prvvals
way, the conversion icasl] vs not possvble‘

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
re1nterpret_cast
> Let's analyze the following program:
APP~¢PP
(his A r mm; m .1, .1, =1; y;
dass u - v ~an ml n2; )1
wad mnlllwndl
r ~ x
—> x
> This code will compile‘ lt is important to understand the reinterpret_cnst is L
not bounded by class type or access modiﬁer type‘ L
> However, the only reason this code works is that “A” class fields (a1,aZ and
a3) are the first ﬁelds in an instance 0i type C (if we Want t0 Obtain a pointer
to B in this manner, we will only obtain a B‘ pointer that overlaps over the
offset of local variable c).

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
rcmlcrprcticasl can not DC uscd with constant valucs or wvth variable of
basvc type‘ The fenewrrrg expression Wm not cerrrpne.
int x = reinterpreticast <mt>11000);
int y =1Qg; WK rzur- ‘KKKrrrKKKrKKrrKKKrr mm rmKrK Km ‘,rrr‘ re ‘aw
. . "KKK; [:n'ulr'ﬁwn 15 K and “mm rrrrrerrrrK Krmrrr tan be
Int X Z remerweuast <mt>(v); “Kr-KKK W .rrKrrKrKrK, r. Kr =K=KrK .K, KKKKK 1K K
Mrv'mnrztyle {an ’
remlerprelicasl can however, copy me vame of a pormer L0 a varrame {even
\f that varvable ls not large enough w hum the enure pomter value).
int x = relnterpreticaskint>(“test"); mov dwurd ptr [x],205858h
char >< = reinterpreticaskchar>(“tesl"h; muv eax, 205858h “KKKKKK MK
mOV byte Ptr [Xlral KISSEZIIEZELKQS“KKKKKK
In thvs case exzossss vs eemuy the address/offset where the smug “test” vs
Located in memory.

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
The same Logic goes for mm data tprS (float / double). Just hkc m thc casc

oi im, they can not be casted in mrs way.

"06“ = re‘"‘e’P’eLca5‘<ﬂ°a‘>(11‘)? ($127‘; new Y i ‘2m Wad ‘Mr be
double x = reinterpret_ca5[<double>(1.Zl; :5;§§'§;1:j§:1§;111 "r m‘ W "' “"11"” “We ‘1*’ “r
rermerpreeease can however be uscd with rcfcrcnccs to change rherr values.

ThrS rndudes references 0‘ a dufferenl type thaL the actual value‘

int number = 10; mov dwurd plr [number],20

reinterpreticastdnt &>(number) I 20;

Int number : 10; mov byte ptr [numbeﬂlﬂ

remterpreticaskchar &>(number) = 20;

***************Ending Page***************


***************Beginning Page***************
***************page number:28**************
re1nterpret_cast
> reinterprel_cast can also be used for direci~ memory access t0 the actual Code
(in other words, it can be used to convert n pointer to a function, to a pointer
to a data type].
APP-(PP
m michnum: x‘ m y)
( return x . y;
i x
Wm nv-(vm) l
‘ m- . . “mnmimmm (MM); ‘a
i a
> In this example, "a" pointes l0 the actual machine Code that was generated
for the addition instruction‘
> This is widely used by obfuscator or pieces of code that modify the behavior
of a program during the runtime‘

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
static_cast
> static_cast implies a conversion where: ‘E
> Values can be truncated upon assignment
> In case oi inheritance, the address where a pointer points to can he changed ‘g
> It can also be used with initialization lists l‘
> It does not check in any way the type oi the object (RTI'I field from vfptr ‘
pointer}
> It is in particular useful if we want to identify a function with a specific set of
parameters (especially if we have multiple instances oi that
functions/method and calling it might produce an ambiguity)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
stat1c_cast
> static_cast can he used with constants. m this case, the conversion and
asstgnment are often done m the pre'compiling phase.
int x = static_cast<int>(1000); mov dword ptr [x],1000
char x = static,cast<char>(1000); mov byte ptr [x],Z32 1232:1000 ,6
256)
I char x = static_cast<char>(3.75); mov byte ptr[x1,3 (3 = int(3.75) )

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
> Let's anal ze theﬂallowin- Iroram: I
APMPP ‘
(1m s { We)“: m .1, .1, .1; );
class a t Mm: m has m; x ‘
ma rmmvuxd) I
{ _ > arm c2440: ‘staticilasﬁ: cannot camert tram ‘a ~‘ w ‘a ~-
note: TvaS [minted m are “Wm-m1 (om-Ersirm remlires
> mneerweww, mule mt or Fumwmzy» ‘last
> This code wilt not compile, as there vs NO possible conversion from a pomter '
of type B to a pointer of type A

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
> Let's anal ze memuowin- Iroram: I
APMPP ‘
class ‘ { Mm: m .1, .1, .1; );
class l \

4 ‘
mm‘ \
) uperamr v o ( mm m m; > ‘
vgxd mix"(vuxﬂ)
1
E b, Error cum ‘mngmu mm chPrt Frnm 'a " m ‘A ~'
r a - Sinks!!!“ WM); "m: mm pull“!!! (e are unrelated; Lunverilon r'equlres
> velntamreticait, (istvle cast m hmitimvstyle (est
Y
> This code will not compile, even if we add a cast operator‘ The reason is the
same, we try w cunverl a 5* m an A‘ (the cast operator requires an object,
not a pointer H!).

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
stat1c_cast g
> Let's anal e the Iollowin- ro-ram: I
APMPP ,
<1... 1 { mm. 1... .1, .1, .1; );
a... I l
( l
public: l
1.1 .1, .1; l
~ 19...... 1- u i I'llurn I... m; )
351.1 mum-1)
t
l n;
1- . . snug...“ ~-
l
> Now the code works and a pointer of type A‘ is obtained by calling the zast
operator overload from class B.

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
> Let's anal ze memuowin- Iroram: I
APMPP ‘
An! .ea4;“1 X, char y)
‘
return X ' y;
)
in! ldd((hzr x, in! y) ‘
{
re¢urn X ‘ y‘
>
Iaidmaiﬂvnd) error c2655: ‘Adﬂ‘: 2 overloads have simila: canversions
Hate: could be '3'“ Add1:(§har‘,1nt:\‘ \
, note: or '1nt Add¢‘n¢,<ner1
. , . not h 1e \r n' tn makch <he 3r mvn\ 1 st ‘z c. ‘nx
> Thus code wm not compne e W ‘ y‘ E g“ 1 m 1 l ,,
due to the ambiguity between two functions.

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
stat1c_cast
> Let's anal e the Iollowin- ro-ram: I
APMPP i
m Mm“ X, (m y)
i i
mm. X ~ y; i
, i
m mam-r x, m y) i
{
return X . y;
)
vom mum-n
‘
i
> Now the code compiles‘ By using the static_cast we can tell the compiler
witch one of the two Add function it should use !

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
dynam1c_cast

> dynamic_zust works by safely convert a pointer/reference of some type into ‘a
a pointer/reference of a different type, provided there is an inhen'tance
relationship between those two types‘ ;

> In this case , the RTI'I from the vfptr pointer is used and the evaluation is
done at the runtime, This means that casting using dynamic_cast is generally
slower than other type of casts‘ However, if the cast is done, we are certain r
that we have obtained a pointer to a valid pointer/reference

> This also implies that R'l'l'l ﬁeld must be present -) dynamic_cast works on
classes that have at least one virtual method‘

> dynamir:_cast also works if there is a clear translation/cast between classes

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
dynam1c_cast
> Let's anal e the Iollowin- I-roram:
APPIPP
class A ( public: m =1‘ =1‘ =1; )1
(1:5; I
t
publiz:
a“: n1‘ n2;
iii‘; c = public A, vuhlzc I c vuhlxc: int <1, <1; >; l
ml mnnlvmd) x
t x
c <; a
, l
> This code will compile - but keep in mind that this is a safe (clear) translation A
as we will always be able to obtain an object of type B from an object of
type c (that inherits B),

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
dynamic_cast ‘
> Let's anal ze the iollowin- code: I
APMPP l
‘his A( M1,‘; m all izl is; >1
ms; x i
l l
mm: l
l“! nil n1; l
1i.” t z Mm A. Mm s l mm m! n. <1; );
void mixﬂlvoxd)
i
a h;
c w Z dynamicjist<V>ﬂhll
)—
> This code will not compile. While there is a possible conversion from B“ to C’,
it’s not a safe one‘ The only case such a conversion will be safe, is if that B’
was obtained from a “C” object and [hen remasted back tn a “C”. As this
can be validated only for classes that have Virtual methods lpalymorphiq,,
types), the compiler will Issue an errcn

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
dynamic_cast
> Let's anal e the lollowl'ri Code:
APPIPP
class A ( public: m =1‘ =1‘ =1; )1
(1:5; I
t
publiz:
i
3.55 c = mm A, mm - i Mm m d, m >; i
wan milllvnid} i‘
i i
I h: l
c ‘c Z dymmﬁmcwm; i
> This code will compile.
> However, “c” will be nullptr (as we can not obtain a valid C object from a B
object), This is very useful as it allows the programmer to check the result of
the cast and have different actions based on it.

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
dynam1c_cast
> Let's anal e the lollowl'n Code:
APPIPP
class A ( public: m =1‘ =1‘ =1; )1
(1:5; I
t
publiz:
an‘ n1‘ n2;
mum Wm m 0; l
3.55 c = mm A, mm - l Mm m d, m >; ‘a
wan "mum; l‘
l -m l‘
< m . WMJBRPW;
> Now, the code compiles and the value of “cl” point to object ".c"
> In reality, b‘ is a pointer to the B part of object “c” (this means that we can
safely convert it to a C')

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
dynam1c_cast
> Let's anal e the Iollowin Code:
APPIPP
class A(
public: int i1, i1, is;
vlrlull "01¢ r11; t);
n
<!=ss I i
plum m u‘ n; i
mm: vom m 0; l
ii“, t = Wm l. Mm l ( M1,“ m d. <2; y; l
van ammo l l
t <1 l
A q 1 (mu; ‘x
I ~a - dynlmciclskl'ﬂl); ml
> This code also compiles.
> While there is no relationship between A and B , since local variable “a”
points to an object of type C , that contains a “B” component, this conversion
is possible.

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
con st_cast

> const_:ast is used to change “const” characteristics for an object, It can be
used only on data of the same type (it will not convert from a type to
another), it will just remove the “const” characteristic of one object. 3‘

> lt is also important to mention that this type of cast can produce undefined
behavior depending on the way it is used 1!!

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
C O n St_C a S t
> Let's anal e the Iollowin Code:
APMPP
Mn mum-1)
l mt X - m;
(ans! 1n! - Fir . IX;
i
mmrw, n; 1
) x
> This code will compile and will convert pt! const pointer to a non-constant ,7
pointer that can be used to change the value o! “x” ‘
> As a result, the program will print “ZOO” on the screen‘
> It is important that the variable/memory zone where “ptr” pointer points to
is NOT located 0n a READ-ONLY memory page (0r simple put, it Should be a
constant pointer obtained from a non-constant variable)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
C O n St_C a S t
> Let's anal e the Iollowin Code:
APMPP
Mn mum-1)
l (mt a." - m - 1“ n--;
Ilsm_csm5leilll:lll] e '='; l
mmms", Mimi 1mm); l
) ‘x
> This code will compile but it will most likely produce a run-time error. ,7
> In this case, “CH exam" is located in a section of the executable that is
constant (does not have the write permission for the memory page where it is "
located]. As a result, event if we convert the const pointer to a non'const
pointer, when we try t0 modify it, it will crash l

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
const_cast 1‘

> Let's anal e the lollowim code: ‘a
APPIPP ‘I
void minlvoiﬂ) l
‘ 4,. l x - 1M; ‘l

> This code will not compile, as “x” is defined as const, and const variables can
not be changed l

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
C O n St_C a S t
> Let's anal e the Iollowin Code:
APPIPP
mu minlvoid)
l .
l i
v Now , this code will compile (using the const_cast we can remove the const
attribute of “x”) allowing one to change “x” value‘
> The behavior of the program is however , undeﬁned —) in this context ‘
undefined means that the actual value of “x” may not be 200 ll! ‘
> A runtime error will not happen because “x” is actually located on the stack
(this means that it is located 0n a memory page with the WRITE flag set).

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
const cast I
> Let sanal Ze the Vullowm- code. (oust 1M b, Z mu; 1‘
App4cpp mov dwmd pt?‘ [11,54n 1
m4 “mm.” wmfgasum-wml1 : we; 1
t mow mm pfr [XLHC'sh ‘
(uni! m X Z m; pmnxﬂ_"$;:g"l 1/, 1
~<m§um<m~><m> - m; "m “win ;
wrinmwx Xv; PM 54" I
) pm mush , “4.1"
till Printf
b m P5“;
Caz 1: Debug mode, no optimizations
> Since “x” IS deﬁned as constant, the (umpuer assumes 1th whenever “x” 1s use u ,
can replace us value wvlh me mnstanl‘ Thus mean, that me fouuwing Instruction 1
“printf("%d", m” 15 actually translated by the (Dmpuer mm: , "
“printf( "94a" 1416);”

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
c0nst_cast
(oust 1m x = 1am;
'(const_cast(int'>(lx)) - zen;
puma-'14", x);
> Let's anal e the lollowirl Code:
APMPP "*d"
mu mnlvm) Pm“
l m.“ mt X Z m;
qmnulmqn-nm: - m;
r I
v In this case, we force the campiler to use the value of “x” through a ll‘
const_cast -) as a result value ZOO is printed‘
> However, keep in mind that this is not a normal usage of “x” ‘

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
C O n St_C a S t
> Let's anal e the followin code:
APPIPP
class rest
t
Fuhlxn:
(nus! 1n! x;
rls!(£n! vaiu!) I xlvaiu!) i l
mu setunt value) t ‘(twsgcistdntvllxn - value; ) ‘
3514 milﬂlvolﬂ) i
r a
res! mu); a
nrtnm-n a mt); “
Lsclill'); x
mntrm: ", m); ‘
> This is however, a dmerent caset Even if “x" is a constant, every instance of class
Test can have a diiferent value for “x”, This means, that the compiler will not use
the value used to construct “x”, but rather the content of memory that
corresponds t0 “X”. As a results, this code Will print first 100 and theﬂ 200.

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
> Macros

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
Macros

> Macros are methods that can be used to modify ipre>process) the code in
C/C“ before compiling a‘

> They are defined using the following sintax: ‘E
#deﬁne <maCro> <value> E

> Once defined a macro cand be removed from the definition list using the
following sintax: ‘
#undef macro

> Macros work before the compile time in a preprocessor phase‘

> One simple way of understanding them is to think that you are within an
editor and you are applying a replace command (search for a text and ,
replace it with another text)‘

> In reality macros a far more complex (in terms of how the replacement is
done, and what king of things can be replaced by them)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
Mac ros
> Examples (simple macros)
APP-CPD
mm- IVFFELSXXE 1w
m» amu[m|rrzn_suz];
> After the preprocessor phase the code will look like this:
APP-cup a
a." “mama; l

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
Mac ros
> Macros work sequentially (are applied immediately after they are defined].
Also, during the preprocessur phase, there is no notion of identifiers, so
there can be a vanabte and a macro that have the same name‘
APMPP
void mitn<ana>
‘ m m“ Z m;
t"! (Emu;
lamp Z vzlua,
Idefjne value ZEE
temp Z value;
>—
> After prepwcessw phase the Code will [00k a5 follows:
APP-WP
vokd "mm-1) ,
t
m yam Z m;
m temp;
temp - "m;
{mp . 1m,
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
Mac ros
> Macros can be written on more than on line. To do this, the speciat character ‘\' is
used at the end uf each Line.
Important —) arter this character there shouldn't be any other characters (except
EOL).
APP-CPP
Nde(1ne PRINY\
x‘ (value > 10") Drxnt‘(“ﬁreiter‘ >1 \
11;! Drxn!‘("5ma\\er\“)r
"are mi1ﬂ(vnld)
‘ m mu Z 1w;
mm,
l______________________________________________
> After preprocessor phase the code wrll lock as follows:
APP-CPP ,
void mum“)
1
m vim 1 m.
1r mm > m) wmnmmwm;
.15. mmvmuﬂvm
)

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
Mac ros
> Macros can be deﬁned using another macro, In this case the usage o! #undef
and #define can change the value of a macro during preprocessor phase .
APPIPP
[define “mun: vm/E
mm. VALUE nu
my rewllllFFELsﬂE];
mm. VALUE 2w
cm vwzl-urrsuxzs]; ‘x
> After preprocessor phase the code will look as follows:
APP-CPD
aw momma; ‘
(w rmlUMl];

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
Mac ros
> Macros can be defined to look like a function.
APP~CPP
Inefinennﬂxw) ((mwﬁm . m)
vula ma)"(vu)¢)
(
m v1, v1?
v, Z m,
v1 Z m;
m v3 Z Wm. m;
1—
> After preprocesso! phase the code will look as fullows:
APPIPP
void mmm)
(
m v1, v1, ,
u 1 1w.
v2 1 2m:
) m v3 1 ((vmm) v (m = (m);

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
> Macros that are defined to Look Like a (unction can have a variabke number of

parameters if the speciﬁer is used.

APP-CPD

adafina PR1NY(furma(,...) \
<\

Printv<“\nvrint Vi1u=§-“>= \
Pr,nt§4§=rmwt. ‘ivAiARGSA,7; \

1

vain m.1n<vu1n>

<
int v‘. v1;
n Z we;
v2 Z zen;
vR1~Y(“xn,xn“, v1, m;

1

> After prepwcessw phase the Code will Look as follows:

APMPP

Maid mainkvnld) '

1
‘"1 v1, v2;
V1 Z lea,
V1 - ZEE; ,
,r;n1¢4“\npr;n1 valueii“)£ '
,r,n¢¢4“~4‘~4“‘ v1‘ v1);

)

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
> Macros can use the special character 'ﬁ“ to change a parameter into its
correspunding string:
APP-CPD
adafina (M1IK<{DH¢1(1DH» ( \
u (\(mmuunn < mmwm (“MUM 1;‘ mm “mam “mum, mum»);
h
vuid mainKvuiﬂ)
(
m v1, v15
v, Z we:
v1 Z we;
(Minn > m;
)—
> After preprocessor phase the Code will [00k as follows:
APMPP
Maid mainkvnid) '
1
‘"1 v], v2;
V1 Z lea,
V1 - m1;
u (Manny) ( "1mm" mam“ ‘u mm MM!“ curretlly“, "v1 > my; >; '
>

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
> Macros can use the special character 'ﬁ“ to change a parameter into its
correspunding string:
APP-CPD
anefine (N[(K(cundiliu") \
r; (\(cunniliun)) < Dr1n{f(”rha cunniljun ‘Xs‘ wash’! avalualad <5rra<l1y“, Iﬁundiliun)
h
vuid mainKvuid)
r
m v1, v15
v, Z we:
v1 Z 2m!-
mmn > m;
l______________________________________________
> After preprocessor phase the Code will Look a5 follows:
APMPP
vnAd malnkvnid) '
1
xn! v], v2;
V1 Z lea,
V1 - ZEE; ,
r¢ Arkvi>v1)) r nr1n1f4"rhe (undrtrnn ‘iir w=;“'1 evaluated curretlly“, "v1 > "1» , . '
>

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
> Macros can use this sequence o! characters "#8" to concatenate parameters:
APP-cw
mam: sumo/9:7 \
w: mywutm v1, w: m t return v1 ‘ v2; 1
SUMUnl);
wow»);
sumo-arm
void mainKvuidF
t
m x Z mum”, 15>;
*—
> After preprocessor phase the code wtll look as follows:
APPIPP
,“¢ =¢¢_,“¢4,“¢ "at ,“¢ "1: 1 re¢urn V, t "1‘ >
4mm: magma-1M1; no 4mm: v1) 4 return n ‘ m > '
(her add7(har((har v1, (her v2) 1 rltur" v1 ‘ v2, )
Mata malﬂlvujd)
m X Z mat-“(wt u); '
)

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
Macros don't suppork overloading m there are two macors wvth me same
name. the last one wru rchacc the omer, a warning Wm be Issued m thc
compiler and men me code wru be compvledlv
The muewmg code won’t compvle because SUM needs 2 parameters (only me
second macros is used}
"1""! 5W“! 3*" warvnng c4005: sum" New renemmerr
“MW WM'MJ m“ "Bee: SEE LIFEVJDIAS dehvutmn er ‘sew-v
f“ “mm” warning mew: MI emmgh argumenfs r'er
) er~r~er (2059: syntax er~r~er~: ‘;'
The following code is empire-d and works properly
(
“We WW w,
we X e Mr, 2):
“We WWW We
X e 5W0, 1, z),
>

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Mac ros

> Use round brackets! Macros don't analyse the expression; they just do a text
replace —> the results may be different than expected.
Incorrect Correct
“mu Ian/(m0 x/y mm urvum (mum
vnld mum“) um mum“:
‘ intxﬂuvmemhs); j imx:nxv(noln,s¢s);
2

> After precompilation the code will look as follows: ‘3
Incorrect Correct ‘r
rm run-(wad) m4 mum-1) ‘3
{ m X Z n . 1» / s . s; ) m X Z ((1. . 1») 1 (s . 5)); r

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
> Be careM when they are used in a loop‘ Whenever possible use ‘(‘ and‘}‘ to
make a complex instruction easier to understand!
Incorrect Correct
"an"! mwwr \ mam! "mum; \
pnnm“x-xn“,x>:pnnd(“v-xd“,y); r mun“X-m“,x>;»mm“v-m“,y>; r
win msanrwm rm mmrvm)
< <
intx:1B,y:zB; “Hump”;
1r (x>y) How)
mm (x, w; mm u, y);
r >
> After preprocessor phase the code wrll look as follows:
Incorrect CONECI
M “mummy wok-1 munch!)
1 r
mtx:1»,y: 2»; 1M1: m. y: 2»; ,
1r (x>y) why)
mun“X-w,Xxmmnw-mxy); (pmmﬂ"x-Xa",x)iprlmﬂ'W-deli)
> >

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
> Pay attention to operators and functions that modify the parameter of the
macro. Because of the substitution sume calls wilt be made more than one time.
Incorrect (res will be 3) Correct
"an"! segmiMrEsuIQXIW \ ‘mm “(luvs-115m) n
rzsuk - mmmmym m u - w, \
win "Winn/win} m ¢_1 Z mt t
< result Z ((tJMtJJNtJmL2)»: \
m X Z 2, y Z 1; )
m m; void numb/old)
“mums, X», y); r
r m X Z 1‘ y Z 1‘
I": rZS;
§=Z7m1n<r=§, Kr’, yr,
)
> After preprocessor phase the Code will look as follows:
Incorrect Correct
vnxd mum-1) ma mimwvld) '
1 r
1HUZ1,YZ1; MXZz.YZ1;
m res; m res;
mm Z um mp MM)‘ t m t_l Z m‘ m ¢_2 Z mt
> new“ Z (MJJMLIJTMJ):MJJJ; >
)

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
Mac ros

> There is a list of macros that are predefined for any C/C++ compiler:
iFlLEi The current file in which the macro will be substituted
iLlNEi The line in the current file in which the macro will be

substituted

_DATE_ The date when the code was compiled
iTlMEi The time when the code was compiled
iSTDLVERSIONi Compiler version(Cx98, Cx03,Cx13,..,)
icplusplus It is deﬁned if a C++ compiler is used
_COUNTER_ A unique identifier (0..n) used for indexing

> Besides these, each compiler deﬁnes it's own specific macros<for compiler
version, linkage options, etcl

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Mac ros ‘
> The usage of _COUNTER_ is very helpml if we want m create unique ‘
indexes in uur program:
APP-CPD
( 1m x : iCWNYERi;
l
> After precumpilation the code will luck as follows:
APMPP
vnm mixll(vnx|1)
l
>—

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
l Macros vs lnline

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Macro vs lnllne
> Let's anal e the Iollowin- code: I
APPXCPP I
Anx ram": xX Anx y) 3
‘ XXXXXX X > y P X = y;
)
XXX X.xn(; X
(
in! X, y;
X - Xinnlu;
y . X.X¢(>;
,XXXXv(-xn-. ~.X(X. X::;
XXXXXX I:
)
> OBSERVATION: This code is compiled without any compiler optimizations !

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
Macro vs lnllne
> Let's anal ze theiullowin- code: "W gamma w m l
pm w. z
APPLPP m» e:>1,mm ,m [>1] ‘
in. ml,“ X‘ m y; pm w z
12mm K > y 1 K 1y, (all "EX z
> add efl'ni i‘
m mm pm w. i
l m X y, push um»: szrsng w i
K Z and), (an prim
v - randl):
mﬂmwx mxlxl m;
r¢‘~r“ u;
>—
> In this case , Max iuncucn will be called, With "x" and “y” being pushed on
the stack.

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
Macro vs lnllne
> So how can we o-timize this program: ‘E
APPIPP ‘1
m ram“ Xv m y) 1
‘ "mnymy; a
) X
m mun z
{ ‘
m X, y;
x - "will;
I y . r.n¢(>;
prxnrﬂ'id", Hm!‘ 177;
) return I:

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
Macro vs lnhne
> 50 how can we otimize this pro-ram 1
App.cpp App.cpp (with macros]
m me-X Xl m y)
( men» XXX<XX1X X X » X ‘I
rllurn X > y P X = y;
) m mm)
m mun i
l m XX y:
m X, y; X Z XXX-:0; l
X - man; y - "will; l
y . mm; urinzfl'id", XXX (X. m; l
umwrw. mu. m; ruurn n; l
mm n; ) i
> If we replace Max function with Max macro, then the replacement is done in
the pure-execution phase. As a result, the piece of code that pushes variable
on the stack and Max function assembly stubs are no longer required.

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
Macro vs Inhne
11: X_IS_SMALLER
Jun Emur
x_15_su|.|.i|l:
b SD how Can we ontimize this proram :
APMPP APMPI Em}!
m mum X; m y)
( m“; m
rlturn X > y r X = y;
1n mm
1“ mainl) { I u printf
( m X‘ y;
m x, y; x 1 mm); i
“mm; Z .i -
y - mm; I
“mm-ma mm m; v ,
mm m ) ‘
i — 1,
> In this case, the replacement modifies the code from print!

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
Macro vs lnhne
> So how can we ontimize this proram :
APPIPP APPJIPP (inline)
m mum X; m y) Mr m menK x‘ m y)
‘ "mnnyrny; ‘ "mnwynm
) )
m mm m mm:
r r
m x, y; m x, y; ‘r
x - mm; x - "Mu; a
y . mm; y - mm; ‘x
pmwrw, mu, m; pumrw, 144x (x, y»; r‘
mm n; mm n; x
> Another snlutinn is to use inline specifien This speciﬁer tells the compiler
that we recommend to insert the code of Max function directly in the code of
caller 18.24 in this case main function,‘

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
Macro vs lnline
Debug mode
(no optimizations]
> SD how can we ontimize this proram :
APMPP APPIPP (inline)
m hixltnr Xl m y) Wt m mxlin! Xl m y)
‘ "munynw; ‘ mummynm
) t
m mill) m Mm
t t
m x, y; m x, y;
X Z "mu; x 1 "mu;
y - "um; > - ‘
mmrwl mm m; ‘a
mm n; mm n; z
l l
> Another solution is to use inline specifien This specifier tells the compiler
that we recommend to insert the code of Max function directly in the code of
caller 18.24 in this case main function,‘

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
cmn mm“ sm 7 X
enmedi X Xv,‘ 7 ‘1 plogram:
push 23>: i
push offsat smng ‘w
£511 _ XXX Maxhnr X, XXX y) Max
(
rum" X , y > MW X s y > X y,
> >
XXL mam XXL Xswo
< printf
XXX X. y, XXX X. y,
X = W = ra"d(7>
V ".1
cmovg I ompare and e i1 reater pmef(“¥d“, (X, m‘
*4 »'—
Another solutvon vs m use inline specvﬁeh Thvs specviver Lells {he compvler
that We recommend to msert the (Ode of Max functvon directly w the code of
caller fag. m ms case main funcuon].
If We use optimizations “x” and “y” are used as reystels and the whole
process vs optvmvzed.

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
Macro vs lnline
P Not all 'UHCUOHS can be used with inline seciﬁer
APPIPP
mm: m Karim/(1n! my.‘ um)
‘ mt m. - o;
m i; 11m: <- X; hunt“, sum .- 11m);
ruurn sum;
l r
mt "mu ‘a
i a
1n! x; a
X - mm: \
mmim", nmmmxsn; ‘x
"m". n;
> If this code is compiled using optimization, the compiler will integrate
lterativ function in main {mainly because Iterativ function does not contain
any recursive functionalities r in this case).

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
P Not all functions can be used with inline seciﬁer

APPIPP

mm m “min/u“ mm mm

c
1f u -- mm

ruurn 11m;
E15!
mum X ‘ leeursAvUAJAmUI) ‘

1m "mu

{ a
‘HK x; a
X - mm: \
pmmm", lccuvsivﬂm'Sn; ‘x
mu". n;

> If we run this code with uptimization the compiler is not able tn inline the
code from Recursiv function:
> www- ms WWW M! m, mum-u ,1. mm. m Mil /Mk\nx\vd4| W /z< .1" m, m, m WIND‘ m wm- m
wmwm-Mmr m'umwni' mwwwmm m Hum/511w w mm mrwwev m Imnlfo'ieoexev
w Izmsmngltub Kb mmwm
> (\mwmm.

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
Macro vs lnline

> Using MACROS guarantees inline replacement. 0n the other hand, debugging ‘E
is really tricky, especially if the MACRO is complex in nature {multiple lines).

> Using inline specifier DOES NOT GUARANTEES that inline replacement is going x‘.
to happen (it should be seen more as a suggestion for the compiler). On the
other hand, debugging is easier and without any bit issues.

> In case of inline , this is used on in release mode {or to be more exact, if the
optimizations are enabled (-01, -OZ, i at the compiler level‘

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
Macro vs lnline
> Class methods (if deﬁned in the definition 0f the Class) are usually Considered
inline as well,
APP-CPP
¢1iss rest
t
in! x; 1/ Privl!
puhiicz
vain SetXlint v=1u:7 l
) v ‘a
n ’ r
> There is one exception - when the class is exported (in this case the code
from the header file is usually compiled and linked in the component that
imports the library). In many cases, the Optimization translates into direct
access the data memben

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
Volati le spec1f1er
> Let's anal e the lollowin- code:
APP~¢PP
m mm u
t
1m x - "mo;
mummy n;
return m
)
> If we Compile the Code in the release mode (or more exactly, if Optimizations
are in place) the compiler might decide that local variable “x” is not 1
necessary (elg. we ca translate the entire code into “printﬂ“%d”,rand())”) ‘1
> The solution , if we want to avoid this behavior is to use volatile speciﬁer’
APPACPP
m mm ‘
{ mum m X - Mao;
“miner, x);
) mum n;

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
> Literals

***************Ending Page***************


***************Beginning Page***************
***************page number:82**************
L1 tera ls
> Literals are a way of providing a special meaning to numbers by
preceding them with a predefined string.
> Literals can be defined in the following way:
> Where:
,, <return-type> can be any kind of type l
a; <literalgname> has to be a name (form out of characters, underline, m) “
parameter_type has to be one of the following: const char ', unsigned
long long int, long double, char, wchar_t, char8_t, char16_t, char3Z_t)
The underline is not required, However, compilers issue an warning if not
used !

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
L1 tera ls
> Let's analyze the following code:
APP-WP
m arm-nu" ,mmm a." - x)
( In! vﬂue - 0:
Ihik (l'x) 1: I)
‘ "in . "M - 3 l (-1) _ -=-; a
mm “M; l
1 a
vnld "lele “
> What we did in this case was to explain the compiler how to interpret
if a number is follower by _baza_3

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
L1 tera ls
> Let's analyze the following code:
APP-cw
m mm“ @1me a." - x)
l In! vﬂue - 0:
while (l'x) 1: I)
‘ "it. . "n. - 3 t (-1) _ -,-; a
mm “M; z
1 a
vma "tr-(Wm)
> Since we define the literal _baza_3 as one that works with strings,
the compiler will translate 121102 (a number) into “121102” (a string)
that can be send to the literal conversion function.

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
Literals
> Let's analyze the following code:
APP-CPD
m Mum-- rel-(mum W W m x)
( return (“monuuuum
and nmlvnd) ‘
‘ m x . m; l
> This code will compile and run just like the previous one. XX‘
> However, the compiler will throw an warning: “warning C4455: ‘operator
""Mega': literal suffix identifiers that d0 nut start with an underscore are
reserved”

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
Literals ‘
> Let's analyze the following co. --
error (slam; ‘Werner “"Jlega‘: declaratlrm of 1mm
App.cpp “Der-atm- has in invahd Parameter 1m
m 09mm“ mum X, error czsaa “mm lateral >ufﬂ>1 ‘fl-legs’, mm! operator
( * ur 1mm uperatm template ‘operator “Ll-legs‘ not mm:
mm ((intbxb'mm'mm, note: Literal npemm- must have a paranietel 1m of the (mi
) ‘unsigned lung 1w‘;- or‘ ‘(mist am- ~‘
vuld malﬂlvmlﬂ
(
m X . Um;
l—
> This code will not compile, as we did not use a valid parameter for '
(he defined literal‘

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
Literals
> Let's analyze the following code: ‘i
APP-cop ‘
m ﬂparator“ ,wammum In": In": m x) i
( return (innx, ‘i
l i
void miiﬂlvuidl
(
unsigned 1m 1m m a,
’—
> This code will not compile, as the compiler will consider a_to_int a
new identifier that was not defined yet‘ ,
> This translates, that we can use this with constant numbers or
constant string (but not with variables)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
L1 tera ls
> Let's analyze the following code:
APP-CPD
M “mm-- erjmmm W 1w.- m n
( prlntf('h::ma1:Xd\n'. (mm:
3..“ “Wm-- ,MMWM... M. M. m x)
( prlntﬂ'nu: law, (mum my);
in“ ninlvviﬂ) l
‘ mm“; 1
15a Jrlntjtex;
> A literal does not have to return a value. In this case we used literals
to print the value of a number (as a decimal value and as a
hexadecimal value).
> This code will print 150 and 0x96 on the screen‘

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
L1 tera ls
> Let's analyze the folluwing cude:
APP-cw
( char ' tn - new! :har[sz ¢ a];
tnkz] 1 I;
for (sing: w: : 0; w: < sx; an")
muz - wt - l] - 51"[Wl];
> returntxt; w the length 0F "(H test today”
van mnnlvnd)
( Mil‘ ’ ‘m - ‘M H5! MWLMQNH -/
prlnﬂCXsVl‘. ten):
deletelltem
2 ,
> In particular for literals that have a const char ‘ parameter (a pointer), the
size of the data the pointer points to can also be send if a secondary
parameter is added. The secondary parameter must be a size_t.

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
l Templates

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
Templates
> Macros bring great power to the code written in 610+ ‘x
> Templates can be considered to be derived from the notion of macros 9
adapted for functions and classes
> The goal is to deﬁne a model of a function or class in which the types of data i‘
we work with can be modified at the precompilation stage {similar to macros)
> For this there is a key word “template”
> Just like macros, the usage of templates generates extra code at compilation
(code that is specific (or the data types for which the templates are made
hr)‘ However, the code is faster and efficient‘

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Templates
> The templates deﬁned iri c++ are of two types: ‘i
r, For classes ‘i
~t~ For iunctions I‘
> Templates work just like a macro e through substitution E‘
v The difference is that the template substitution for classes isn’t dune where ‘
the ﬁrst instance of that class is used, but separately, so that other instances
that use the same type of data to be able to use the same substituted
template
> Important: Because the substitution is made during precompilation, the
templates must be stored in the files that are exported (rorn a library (filesh)
otherwise the cumpilerﬁn case it is tried the creation of a class from a
template exported from a library) will not be able to do this‘

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
Tem plates
> Templates for a function are defined as folluws:
APMPP
inﬂat- <chss Y>
Returnjylil mmwmlp-rmm;
u
“Min nyvename I>
Inuvnilyvl functionjimlﬁinmuvs) x
v Alleast one of the "Return_type" or “parameters” must contain a member of
type T,
APP-cw
w-Ilm (cliss Y>
r 5m" um,“ "mm

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
> Function templates

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
Templates

> A simple example: I
APP-WP r
“mn- (ch55 v> 1
v Sum" mug, v um}: ‘
i mm MM . MM; ‘
vum mum-n ‘
i awn: X . Wm w;

> The code compiles correctly —> x receives the value 3,75

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
> Asimple example:
A .c
pp Pp error (1m; ‘Sum’: rm matUung averluaded funttmn mum
$33333;ij ‘; "M n Em,» (2752: w sum'rJP: template parametel w- 1; amhigunus
{ *’ * note: See deflaratlrm 0r ‘Sum’
mm “he; t mug}; rmte: mm he ‘dmlhle‘
> note: or ‘we
Wm “1mm; error (2734: ‘r swmngw: muld not deduze twang argument m
r ‘r‘ From ‘double'
M1. X Z
>
> The Code will not Compile r 1 i5 Converted to int, 2.5 t0 double, but the Sum /
function should receive two parameters of the same type. '
> The compiler can't decide which type to use —> ambiguous code

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
Tem plates
> A Simple example:
APMPP
t-mvht- (ch55 v>
v Mu mug, v mum
i mm MM . MM;
void mun-m: l
r x
m x . sumllt 2n x
mm .1 - Sumllét 1.4); l
) l
> In this case —> x receives the value 3 and the called function will substitute A
class T with int, and d receives 3.9 (in this case the substitution will be made "
with double)‘
> In the Compiled Code there will be two Sum functionsklne with parameters 0f
type in! and the other one with parameters of type double)

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
> Be careful how you put the parameters!!!
A .c
pp Pp emmur (1272: ‘Sum‘: no matching avelloaded Function found
;=g:;@§;;;“j;j;l error (1752: ‘r Sumtint,int'7'1 (uuld not deduce mum
{ ' argument Fm‘ ‘r'
mm mu t y); note’ see dedaraucm of ‘Sum‘
> emmum (2571: cum‘; no matching overloaded Function Found
Wm WWW) emmur c2732: ‘r Sumtintdnty‘: could not deduie template
m amgumemt rum ‘r'
m X Z Sumut 1); note: see dezlar'atirm 0r ‘Sum‘
duuhle a Z SumklmSt 1,0);
)
> The Code above Cerft be complied —> not because the return value is
drfferent, but because the compiler can't deduce what type to use for class '
Tiwhat return value is obtained)

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
Tem plates

> Be careful how you put the parameters!!! I
APP-WP l
t-mvht- (ch55 v> ‘1
v Sumlxnt x, m y:
{ mm. mu . yn ‘
) I
vum mum-n
t

m x - Sumdllvlh 2n

) Mm .1 - smmuvus 1.4);

> In this case the code can be compiled (we use <> to specify the type we want

to use in the template).
> X will be 3 and d will also be 3 [1,5 and 2A are converted to int]

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
Templates
> Templates can be made for mure types I
APP-WP l
“mn- (ch55 u, (his u, (his m l
u Sum": ,, vs y: ‘
( l
mm (um ‘ y); ‘
) I
vum mum-n
{
m x - sum-mm 1);
mm .1 - sumxnndwhlevdwhlousv 1.4):
y
> In the first case (Sum<int>) the compiler converts to Sum<int,int,int> (which
will match the parameters)

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
Tem plates
> Templates can be made for mure types
APMPP
t-mvht- (ch55 u, (his u, (his m
v: mm x, vs y:
{ mm (um ‘ m
)
void mum-n l
‘ m X . WMMM My; l
) mm .1 - swumwnmwnoum 1.4); l
> In the ﬁrst case (Sum<int>) the compiler converts to Sum<int,int,int> (which
will match the parameters) "
> The compiler tries to deduce the type based on the parameters, I‘! it is not
Specified. The return type must be Specified because the Compiler can't
deduce it from the paramters,

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
Tem plates
> Function templates cand receive parameters with default~ values
APMPP
“mn- (ch55 u, (his v2, (his m
v: mm x, v; y - msn
{ ruurn (um . m
)
void mum-n l
> “X” receives the value 15 1101-5 9 the default value for y).
> The use of default parameters requires the existance of a constructor for the
type of the used class, Expressions like “T3 y I 10” are not valid unless type
T3 accepts equality {Dr has an explicit assignment Operator) with int.

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
> Class templates

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
Templates

> Class templates are defined as follows: I
APP-WP l
musl- (CIISS r> ‘l
ms; lm-ss l ‘
Tm... (QM-m. r> ‘
(his Myths! {

> The T variable can be used to deﬁne class members, parameters within

methods and local variables within methods‘

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
> Class templates are defined as follows: I
APMPP l
mm. “his Y>
chss suck ‘
{ l

Y usillli]; ‘
m cwnn l
M1“:
suckl) : (mull!) O
m, mm um) { mumps] . "M; s
l W, l return usil>><wlwh )
)1
wm mnlllvnd)
(
5mm“, s;
sJusnll); SJushlZ); sJushlZ);
prAnKﬂW'ﬂ $~Pw())z
> The code above prints “3"

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
> Be careful what types you use for (unctinns when using templates in a class:
APMPP
lzmplalz (class v>
(11;; Slzck
t
v t,t¢|1ee1;
xnt ‘aunt;
Wm“:
Slzck (nun! a t)
“Sawﬂy ‘ mm umfgzzgpy - “We; > ‘:v-Mvr c1554 ‘wind statmnmmuwu s)‘;
>1 ‘ (annut (unvert argument 1 fram ‘int' to ‘T a
vmd mawbmxd) \uth
l [
Stitk<1nt> S;
LEAN‘); “mm; “mm; “1"
prtntt< :4 t §,vuu<>>; ]
J______________________________________________
> The code above can't be compited. The Pop (unction is correct, but the Push
function must receive a reference—> s.Push(1) doesn't give 1t a reference!!!

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
> Be careful what types yeu use for functions when using templates in a class: I
APMPP l
mm. ml ,, ‘
a“; n.“

{ l
Y usillli]; ‘
m cwnn l

nu“:
sunkl) : (mull!) O
mu mm Mun l “gimme . um; l
I! Pauly { ruurn usrl>><wnrh )

35m mum-n

(

) mmvw HMO);

> The code can he compiled and prints "3".

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
Tem plates
> The same as function templates, class templates can use multiple types
APMPP
t-mvht- (ch55 mm“ m
cllSS v.1’
t
v1 KEY;
v2 Value;
public:
Fur u = mmm, vnuaﬂlln 0 L
void SelKeylcnns! v1 ti; t Key - v; ) z
mu Sawﬂuekuls! n w {Vihﬂ . v; l l
3514 mi1ﬂ(v01¢) t L
Pnrmmls! m», um u; L
mummy." grade") ; x
) lien/ﬂush”: i
b “Pair() z Kelel (l), Value(TZ())" —) calls the default constructor fur Key and
Value {for “p” Key will be nullptr and Value will be 0),
> It is important that both T1 and T2 have a default constructor: T1 () implies
creating an object using its delault constructon

***************Ending Page***************


***************Beginning Page***************
***************page number:109**************
> The same as function templates, Class templates can use more types
APMPP
t-mvht- (this mm“ m
czljj v.1’
t
v1 KEY;
v2 Value;
public:
mm = mum), VllullYlln 0 ‘x
Pairlcmls! n M, m.“ m m = “may, vuuqn) 0 x
van sum/mm n w l Key - v; > x
m4 setvaluelconst v2 m (Vllue - v1 ) \
n l‘
void mum-n x
mum“ mm aw Dl":xam_|rade‘t1l); \
> An explicit constructor can also be used in a class that uses a template, In the
example above the constructor receives a string (const char "b and a number.

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
> A more complex example: ‘
Awqw ‘
mm. “hss v>
cuss Suck ‘
{
WM Pushﬂ‘ value) ( LAsKIcwnKH] - (‘v/ﬂue); ) ‘
Yl Pow) ( "turn Lisll'1mml]; )
)i
“Mm (um 1w.» n,
<1.“ m
(
);
WM numb/aid)
( "
S!lck<P-1r<cun§lcll"h,1nl>> s;
3mm“ Banana! mm mmuumn my:
5.Pl|5h(||en Parana“ chart “MUMJHIMK 9));
s_|=usn(m FilKnmsl char‘, mutklurmn", ll);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
> Macros can be used lugheter with templates: I
AWCPP ‘
Mnfxn- F(k,v) n-w Pansmsl an", Ink)“, v)

Mame Suck msuckdnnmns! chlr', m» ‘
<1.“ Mm ‘
(
“Mm m, mu.“ n,
<1.“ P.“
(
m4 mum-1)
5..“ 5;
s.»ushw-.m_,,.w, my);
sJusMIV'WLIHﬂK 977:
s.Push(P("cl_[rade"v ll):
)

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
Te m plates
> Class templates can alsp accept parameters without a typelconstant)
APP-CPI’
t
v lxsllsxze ;
in! (nunl;
publAc:
slsekl) z cuunlll) c) l
"Q14 Fush(cwnsl v1 vilﬂl) t tlstlequntssl - (vezu-x; ) E
v: Paul) ( return l1§!|--(nun!]; t l
:éid mainlvoiﬂ) l
‘ Slims, m s;
S!l(k<1n!, lue> ,1; ~~"' ‘
fur (‘he [r - I; [r < s; !r.~: ,~
s.vushl(r)1
)
> In this scenan'o, “s” will have 10 elements and “52" 100 elements
> TWO different Classes will be createdlone with 10 and one with 100 elements)

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
Templates ‘
> Class templates can also accept parameters without a typelconstant) I
APP-CPP l
Kerwin: mess v m
class Stack t
‘ l
v lxstlsxze ;
m em“; l
puhltc:
stackl) z emu») 0
wm PusMcmlst u mu) t ListlcwnU-t] - (mu-u; )
n Pam) ( return tum-mum; t
:an mnlvem
‘ snemnt, 10> s;
Sllzk<1nl> ,1;
m (m u . e; u < s; u“; ,,
s.vushl(r)1
)
> In this scenan'o, “s” will have 10 elements and “52" 100 elements‘ In thecase
of sZ the default value ior Size will be used.

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
Templates ‘
> Class templates can accept default values for types I
APP-CPP l
‘
2 ss c ‘
v mum]; l
m em“; l
Duhlsc:
Slackl) z emu») l)
ma Fuslllcmlsl u lam) l usllemml - (mu-u; )
n Ml; l “ml. l1§!|--(m|l!]; l
:an minlvoiﬂ)
‘ .
"
> In this scenan'o “s” will be a ll'st of 100 doubles and sZ (because we didnyf;
Speciiy the type) will be a list 0i ints.

***************Ending Page***************

***************Beginning Page***************
***************page number:115**************
> Ctass templates can accept defautt vatues for types
APP-CPD
t
m t1§lllﬂﬂ],
‘mt eemmt;
M1,‘, emmm [2955 '5tat'k‘: use of t1“ template
“if? Q ‘nu-M2 (>1 u V 1 r'enulref template argument list
i‘; my; $3335,“ Lj;;?2(gm§§i;""""'1 ' "a "6' > We see derlaration mt we‘
>t emmm c2123: @2' unknown >512
we mummy emmm £2511 'Stack‘: no apprupr!ate difault
4 .. v 5 constructor avallable
' note: see metlemetwm m; 'steou
> ,
> The above code can't be compiled e evem w the type T is by default int
> It must be Speciﬁed that when a variable 0i type Stack ls made, that valiable
(“52"| ism fact a temptateiwe must use <>|

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
> Classes can use methods with templates I
APMPP t
=1iss anllll
{ r

1n! value; r
pub!$<:
lntel£r() 1 valu!(l) ()
t-me1it- <=1iss r>
void SatvilullY v; t ~11“! . (1n12v; v
)
vesu mesnrvesnv
( ink-III 1;
1.5!!Vi1ua<f]uit>ln_5f);
1.51!va!ue<dnuh!e>(1.1);
3.5:!Va!ue<char)('a');
) N

> In the scenario above, Integer has 3 methods (with float, double and chap

parameter)

***************Ending Page***************

***************Beginning Page***************
***************page number:117**************
Tem plates
b Classes can use methods with templates
APMPP
(1:5; Xntlllv
t
1n! valuli
Pub!$<:
mam) 1 mum 0
t-mvht- (ch55 v> i
void Satvﬂu!" v; t in“! - mm; y x‘
); i
mu MAI-(van i l
intellr a; l
“mm-(mm; l
Lsetvnual'l'); x
> Specifying the type in the template is not mandatory,
b In this scenario, Integer has two method:
> one with a ﬂoat parameter—) deduced by the compiler from alsf
> one with a char parameter —) deduced by the compiler from ‘a’

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
> Classes that use templates cand also have static members: l
APMPP l
“Mme”; Y>
cuss Ilumer ‘
{ l
l mm l

am“; l
sun: 1m (all;

)i

m Humerdnnzztwn! - 1|;

m Mmmmmn . 2»:

1m Mamsmml e so;

ma mama

i
Numerdnn "a; ,,
Mum-Ran» n2;
Manama” n3;
mmmaam niann ultwnn lawman);

***************Ending Page***************

***************Beginning Page***************
***************page number:119**************
> Classes that use templates cand also have static members: l
APMPP l
“Mme”; Y>
cuss Ilumer ‘
{ l
l mm l

am“; l
sun: v ml;

)i

m Humerdnnzztwn! - 1|;

a" Mmmmmn . c.»

m1. M..<m1.>=ml e so;

ma mama

i
Numerdnn "a; ,,
Mum-Ran» n2;
Manama” n3;
Punrflﬁndklﬂfx niann ultwnn lawman);

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
> Classes that use templates can also have (riend functions: ‘
APP-CPP \
(@lﬂeulass n
(his Mr
( l
v mu;
m Imam; l
Mm:
mm ma "mm-km) m;
);
"m YulOlmer-(nunlm n) ‘
(
“st - my
>
vnld "mm-mm» m
t
(.mm . a;
)
ml mum-1)
l
liner-(dun I“;
mrtdmnle) n1;
mum):
1mm); ,

***************Ending Page***************

***************Beginning Page***************
***************page number:121**************
> Classes that use templates can also have (riend functions: ‘
APP-CW \
(ewlateulass n l
(his Mr
( l
v mu;
m Imam; l
Mm; ‘
mm ma "mm-km) m l
l
t.v.nu- . 5; ‘
)_ >
vnld mum)
l
much») n1:
maul» n1;
1mm);
mum;
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
Template
> specialization

***************Ending Page***************

***************Beginning Page***************
***************page number:123**************
Templates
> Templates have a series of limitations: ‘i
> The biggest limitation is that a method lrom a class that uses a template has ‘i
exactly the same behaviour lthe only thing that differs is the type oi the a
parameters) ‘i
> For example, ii we deﬁne a iunctiun Sum with two parameters x and y, in which ‘i
we return my, then we can't change this to another operatiun (e.g. il x si y are of i
type char return x‘y instead Xey)
> This limitation can be overcome if we use specialized templates
> Specialized templates represent a way in which for a class we define a
method that overwrites the initial code 1mm the template with a more
specific one for parameters of a certain typet

***************Ending Page***************

***************Beginning Page***************
***************page number:124**************
Templates 1
> An example: ‘i
APMPP i
“mn- (ch55 v>
a“; mm" ‘
{ i
1 mm ‘
pm“; i
"Q14 s-liv x) ( Vilul Z x; y;
m sun ( mm (“m-1.1!; >
i;
mu minivan”
( Hum-Kink) n1;
n1.§a!(5);
“mum” n1;
n2.se!('7');
prAnKﬂWIkIL "Haw "new "2.5mm
> The code runs r but pn'nts “n1:5, n2:55” even though we initialized n2 with
‘7’ —) and we expected to print “n2 = 7"

***************Ending Page***************

***************Beginning Page***************
***************page number:125**************
Tem plates
b Another example:
APP-cop
‘emulate <¢1=ss v,
‘lass Numhcr
(
v vlluli
public:
Vnid s¢‘(r :7 ( v.1“; - r; >
int icl1) < rclurﬂ 1inl)vilu=l >
11m¢1.11 <>
:1.” mm, <<m> Ternpme
mm?" v.1“; 3pcc|alvzc~d m
ma summ- z) ( mu! - 1-1‘; ); char
An! @11(; { rQIHFn (‘"1:V;1u!; > '
(
Numhar<1nl> “1;
n1‘S!!(5)i
Number<¢hir> “z;
n2.s=l1'7')x
printf("nl:ld, "1:14", “1_§-¢(>, “2.5-m(>>:
v
> The code runs properly and prints n1:5, n2:7

***************Ending Page***************

***************Beginning Page***************
***************page number:126**************
> Specialiled templates work fur functions the same way:
Awqw
mm m n
1n! tunvmrﬂullvlﬂ vzlul) l “(urn (nub/nut, )
mm. o
m (unverﬂnlnkthinkthir value) 4 return ("Mun-w w 7: >
Wm mmomm)
{ Template specvahled
m , Z [mnwﬂmlvu,5,;
m y Z Wmmmmm ¢ >1 m char
)
> The code runs r x will be 1 and y will be 4

***************Ending Page***************

***************Beginning Page***************
***************page number:127**************
Compile-time
> assertion checking

***************Ending Page***************

***************Beginning Page***************
***************page number:128**************
Compile-time assertion check] ng
> Templates are a really powerful tool. However, sometimes, one might need t0
add some constrains. Let's analyxe the following example:
APP-cup
mum- AW m" 5h!)
(1.5! Sllck
l v EkﬂKEISREli
mm: 1
5mm l l
> l
); r‘
ma mum-1)
> How can we enforce some limits for template parameter size ? [e4g, we do
nol~ want Size t0 be Smaller than Z 0r bigger then 100)

***************Ending Page***************

***************Beginning Page***************
***************page number:129**************
Compile-time assertion check] ng
P C*+11 standard provides a keyword SKUCiCJISSErt that can produce an
evaluation of an expression during the compile phase and throw a compile
error:
> Format:
static_assert condition condition ‘
> Example:
static_assert ( a>10, “'a‘ variable should be smaller or equal to 10“ );
This code will lail in the compile phase if “a” can be evaluated it that time a
(this usually means that “a” is a Constant) and if its value is bigger than 10.
> Usually, static_assert is used within different class methods (e.g.
constructor) to check the parameters or with templates to provide some
constraints‘

***************Ending Page***************

***************Beginning Page***************
***************page number:130**************
> The previous code can be modify in the (allowing way:
APP-CPD
(amplala ((YDEHIMQ 1,1"! 511¢>
(1,5; Slaﬁk
<
v [kmcntﬂsncli
mm.
Sla<k<> (
“Mum” (Sm > 1, “5m m m“ must ha biggar m" w);
“mum” (Sm < we “5m m 5nd must >= Wu» my. we“ -
1
1;,“ Mum”) note: Mule convplling (lass template member‘ functlun
< ‘Stackdloafdnm: 15ml (may
mwnmﬁw a; we‘ see remem to funninn mm» instannatmn
1 'Stazkkﬂoatﬂﬁu‘ 1 =s¢au<mmr bemg (wrunléd
> Now the code nu Longer ﬂute: sea reference m (1555 template instantlallon
. 'StackafloatJBm‘ balm; cumplled
complies and shows the
fulluwing error: I,

***************Ending Page***************

***************Beginning Page***************
***************page number:131**************
Complle-tlme assertlon checklng l
> lrl particular for templates, static_asserl can also be used to allow only a I
couple of types to be used in a template. ‘
> ThIS is however, a Z-step process. Flrst we deflrle a template that can tell us ‘
lf a type is equal (the same] with another type. l
APMPP ‘
(ewlautlylilllﬁme u, lylilllﬁmz m
strut! YYPetMvzre
t emit (em peel equal e meet
n
giggigggggfegm Speclalized template for template
t TypeCompare that has both parameters
mm: cw“ hwl equal e We; ,7
>; of the same type
> The trick here is to use a specialiled template where the value of a stetit
constant variable lS changed.

***************Ending Page***************

***************Beginning Page***************
***************page number:132**************
The prevvous code can be Matty W the tettewvhg Way:
template <Iypﬁﬂamc 1,1ht $11e>
t1.55 5t.tt
t

v Elsmsnkitnzs].
Pub)“

S!a(k() t

t sntk the be Mu mm t .e mu

>
1;,“ mum”) nets: while campiling (leis template member‘ tunetmt
< ‘Stacklfloatdﬁiw::$far\(vmd,\‘

gutkt/Anatgﬂﬂv i, notei see eeteeenee (u ﬂmcKluvv template anslanuatluvv
> stethneetgtm-:;stee|<wtuu)‘ being whpnea

rwte: see hetehehte to class template initaﬁtlatlim

|hth15 (age the (Oltgwwg ‘Stacktfloat,2%>‘ hem; camplled
happen: When Typelomparedloamnb vs catted. the compner chases the ﬁrst (more
generic form! of the temptate that has the vatue of equal false,
If we woutd have create a var usmg Stack<int,200> then TypeCompareﬂnMnb would
have seteeteu the specvahzed temptete that has the value of equal

***************Ending Page***************

***************Beginning Page***************
***************page number:133**************
Complle-tlme assertlon checking
> Let's analyze the (allowing code: I
APP-CPD t
vain m.1n<vu1n> ‘
t
m X e mm; \
stmgssmtx \: w. "x mm m be w \"7: ‘
1 ‘
Wm- [2131' ‘mum am not Mum tn a (Unstnnt
mt! m usage .1;
> Keep in mind that stutic_ussert only works w|th constant value (egt values that can
be deduce during the compile phase). In this case, the value of "x" is a random one
(as a result, the Compiler can nut evaluate if “X” i5 O or not and an ermr will be I,
reportedlt

***************Ending Page***************

***************Beginning Page***************
***************page number:134**************
y my

***************Ending Page***************

