***************Beginning Page***************
***************page number:1**************
‘\ Gavnlut Dragos

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
> Standard Template Library (STL)
b Sequence containers
> Adaptors
S U m ma f'y > Associative containers
> l/O Streams
> String;
k > Initialization lists

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
Standard Template
> Library (STL)

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
STL (Standard Template Library)
> A set of templates that contains:
> Containers (class templates that may contain other classes) ‘l
> Iterator; (pointer used for template iteration) ‘l
> Algorithms (lunctions that can he called for a container) ‘l
> Adaptors ‘l
> Allocators ‘l
> Others ‘
> To use an STL template, we have to include the header(s) where that
template is defined‘
> STL object can be initialized in the following way: (“vectardnv x") if we
use “using namespace std;", or using their full scope definition
("stdz :vector<int> x”) otherwise‘
> There may be various implementation of STL objects. As these
implementation are compiler specific, their performance varies frmn on
compiler to another.

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
STL-Containere

> Sequencecontainers
> vector
> list
> 10rward_lis! E
> deque
> Adaptors ‘stack, queue, priorityiqueue)

> Assuclaﬂve containers
> Ordered: set, multiset, map, multimap
> Un-ordered: unorderediset, unorderedimap, unorderedimultiset, ,

unorderedimultlmap

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
E Sequence
> containers

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
STL - Vector
> Vector = an unidimensional array for objects I
> Constructors: r
APPIPP j
vaAd mesnlvasﬂl
( vlclwv<YYFl> v;
vacluv<vil> vlsxxayi
l______________________________________________
> Memory allocation / resizing is done dynamically
> Every object added in a vector is actually a copy of the original one

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
STL - Vector
b Insertion in a vector is done using the following Commands: pushjatk, insert l‘
> For deletion, we can use: pop_back, erase or clear r
> For reallocation: the resize and reserve methods ‘
> For access to elements: the index operator and the “at” method ‘
APP-CPD
um, mum! 5m;
IlMlude (vector)
void "mm-1)
r
"(u-mum v;
“wthmwwwxun;
m x - vm;
m y : mm);

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
APP-CPP ‘
usan; nileante 3K1;
linclud: <v‘<‘»r> ‘
c1m 1n.!.=r
{ ‘
an‘ v=1u¢1
Fuhlic:
Int-III‘) = v:1~-¢»> ()
Intaprllllt v} : V-luelv) U
1n!!‘!r(<n.,! Integer ‘V, = Vi!“a(v.vi!ua) 1»
mu SeiUnK V) {VIM . v1 ) ‘
int 5:“) ( "turn Vilull )
>
V,‘¢ m.1n(~n1¢>
1
v=<‘=.<1n‘=.-.> v;
Int-[Ir 15);
v-uusniblzkll);
Lnﬂﬁ;
prmfm-mvlnl-mnx um» mum»;
i________________________________-------
After execution: i=6,v[0]=5

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Example: 4
APP-CPP ‘
(1-55 1"‘lllr
4 4

m: Velma;
mm:
lntqaﬂ) = vnuqﬂ) 4 arim(‘[7lb] “mm mm“, ms); 1 ‘
mumm v) = v-mm 4 vrsnrﬂ'ﬂv] v-m mrﬂdhn', 0|!va )
Intuuﬁmnst [mun M = “hwy-m1 4 mmvwl (any rmr m.“ (mum;
ms, u, mam); > 4
mum 419"er 4W.“ lnt=|=|i n 4 Vill: Z Him; Brim(“["9] w: mum“,
ms, n, LVﬂul); return was; 1
vnld snun v) 4 v11“ . v; )
m mu 4 rm". v.1“; 4
.‘r;
Wu nay-(Wm
4
vlnnrctﬂtulr) v;
[mun 1(5);
hr (m w - u; w < s; cm) ,,
1.5!:(1060 . u-y;
v.9u5h_hl(k(l)i

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
STL - Vecto r

Exampte:

E—

- [OOBBFCBO] Value ctor(5)

lr=0 [UOD3A688] Copy ctor from (OU98FC9U,1000)

tr=1 [0003A6C8] Copy ctor (rom (00D3A688,1000)
[ootmecc] Copy ctor from 10098FC90,1IJO1)

tr=2 [UOD3A710] Copy ctor from (OUD3A6C8,1000)
[0003A714] Copy ctor from (00D3A6CC,1001)
[0003:0151 Copy ctor from (OD9BFC9IJ,1OUZ)

tr=3 [OODBAGBB] Copy ctor from (ODD3A710,1UOD)
[OODBA68C] Copy ctor (rom (00D3A7I4,1001)
[0003,1590] Copy ctor from (OOD3A71B,1DOZ)
[00D3A694] Copy ctor from (0098FC9U,1003)

tr:4 [UODBAéDB] Copy ctor ‘rum (00D3A688,1000)
E60D3A6E8] Copy ctor from (0098FC90,1004)

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
STL - Vector
v.2ush backm
k

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
STL - Vector
v.2ush backm
> Allocate space for

m m count+1 elements ‘a
k

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
STL - Vector
v.2ush backm
> Allocate space for

count+1 elements ‘x
mama] mm c ,M h f a
- - > Opy ovet e ‘m x‘
V |tem[1] ltem[1] count elements in the
m5. ltem[2] new allocated space 1
Copy-ctor/Move»
ctor

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
STL - Vector
> Allocate space for ‘E
i t 1 l t ‘
‘m. ltem[0] coun + e emen s ‘I
m ‘u It "\[1] > Copy/Move the ﬁrst 1
v e count elements in the 1
@‘ ltem[2] new allocated space g
v
m > Free the space used by I
k the current elements

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
STL - Vector
v.2ush backm
> Allocate space for
count+1 elements ‘x
ltem[0] a‘
It "\[1] > Copy/Move the first g
v e count elements in the
|tem[2] new allocated space
m > Free the space used by 3
i mm the current elements
> Copy/Move the new
Copy/Move Cm, item into the extra
allocated space

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Test case:
APP-1 ‘PP
mm.- lmmiLsni 1m
(1-ii x"‘l|lr
4
m valueszrKELsnE];
9mm
tutu-r0 < mm: }
{mun-(mt "my ( 5mm“); )
magnum“ mug" m 4 (nvamKUnz'lleluas); )
Intueu operawr- (must {menu a) 4 (cpyFMﬂint'H-Values); mm ‘this; >
vein 5mm mm
(
m (m n . a; n < “:56;me nu)
valuesltr] . m“;
>
vein anyfmumc’ 115a)
(
m (m n . a; n < “:56;me nu)
‘um-um] . mum]; '
>
vein Sl'ﬂwnst mm" m
(
(npyFmﬂlm'lvwnuls);
>
h

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Test case:
Vec-1.cpp Vec-2.cpp
ma numb/aid) void .mmm
< 1
vzztw'd'ntzgzr: v; “HUMMER” v,
integer 1; mew u
m um tr Z a; tr < manna; "w VMQMQW);
( For (m v - a; v < 359999; tr»)
1.5mm; 1
“Putnam; ‘ saw».
) vvyushibackﬂbi
1 )
)—
Plr-1,cpp
‘m “mum; Ptr-chp
INS" w Z m Inwserhuuuuulx vmd mnVIKvu1¢7
1m." x; < ,
m (m 1r Z a, 1r < mm, "H; Inmgar "v . n!» Inmgar'UBBBBB];
{ fur (1n! tr Z a; tr < ‘BBBBB; tr¢¢l
1,5elklr); <
qwmum; vm] Z nrw mqmm;
) 1
) ]—

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
STL - Vector
The study was conducted in the following way:
> Each of the 4 applications was executed for 1D time‘ Execution time was
measured in milliseconds,
> Execution time was divided into two times: time needed to initialize the
container and the time needed to add the data into the container,
APP-1 ‘CPP
mu mums)
Intellr 1; ‘
> All of these tests were conducted using the following speciﬁcations:
> OS: Windows 8.1 Pro
> Compiler: cLexe [15.00.21005.1 (or we]
> Hardware: Dell Latitude 7440 - l7 - 4600U, 1,70 GHI, 8 GB RAM

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
STL - Vector
Results:
Vec- Illit 0 O 0 O O 0 O O 0 O
1 Set 1985 1921 1937 1912 1921 1953 1937 1938 1912 1912
Vec- lnit 140 125 157 115 109 110 11o 109 110 11o
Z Set 531 515 515 516 516 515 531 516 515 500
Ptr- Illit 406 359 360 375 359 360 359 359 359 360
‘ Set 4B5 485 468 469 485 468 469 485 469 484
Ptr- lﬂit 0 0 D O O D O O D O
Z Set 411 453 453 437 375 391 390 375 375 375
v Vec-1,Vec-2,Ptr-1,Ptr~2 -) the 4 methods previously described
> “lnit” -) the Series of times recorded when we Initialize the Container
b “Set” -) the series of times needed to add the data in in cuntaine[,,,~
> T1 4. T10 -) resuit times I

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
STL - Vector
Results:
Average execution time i
1m 1
1m 1‘
um 1‘
11w ‘r
mm r
m i
m
um
1w
“ veer Vec'Z m4 Pm

m n on; M n
.5!‘ ms 517 m, 1 uu a

> Vec-1,Vec-2,Ptr-1,Ptr-Z -) the 4 methods previously described 77/

v “lnit” -) the series of times recorded when we initialize the contains’?

b "Set" -) the series of times needed to add the data in in coritairier

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
STL - Vector 1
APP'1-CPP
ma mum-n t
"ammo v;
> Let's consider the following code: r" 3:55;;(393 < ""i "W l
> If we run this code on g++ clang ) wiﬂsfl'ileu: m, “hated: “w, “mo. V-<IW<“YO)3
and cl.exe (Microsoft) ) r
> The results show that the r1;
allocation strategy is m
different depending on the u
compiler, w
y Clang/GH prelers powers M \
of 2‘ .- ’
n
c-‘“e:-:zz::::=i=asmmazxzsczzmcazeeg
_=t _m/w.

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
> To iterate through all oi the elements stored in a vector we can use iterators‘ An
iterator is a special object (similar to a pointer)
APP-cw
mo mole-1m
l
vector-(Int) v;
v.push_b¥k(‘l); v-wsh_bxk(1); mpusthke); v.wsh_bxk(l); v.wsh_hxk(5); ‘
veexortlnn: :lxeraxor m x
it e mum); ‘x
eon. (k < imam x
l a
prlmﬂ'lw '. (IM)('|z))l l
lwr x
> lleraturs work by overloading the following operators:
operator» , operator-- (to go forward/backwards within the container)
Pointer related operators ioperator») to gain access to an element from the container

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
ST L - Vec t0 r
> In this example access to elements is done via operator—)
v veztor template also provides two methods: front and bark that allows
access to the first and last elements stored,
APP-cw
dass mm»
i
Fublxc:
m v.1“;
"mun 1 mum 0 x
mmum my z vii-mm) 0 l
52m mum-1) ‘a
l ‘a
vecmrmunher: v; 1 ,
v.push_hatk(Num!rl1771 v.nush_hatkluumerl2))z VJIASLBRHNIAMEFBUI
v.push_hicklNunﬁ:l‘M))I v.vush_hackll4um:rl$)); a‘
venurmunbennxurlmr l - “tum;
,rlmmmn A-wﬂua);
mmumnn u . new“):
pmmm w, v.frm|ll)~valu=, v.n==kl>.v=1u=>;
)
> This example will print on the screen: 1 3 1 5

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
STL - Vector
> vector template also provides a special iterator {called reversejtemtor)
that allows iterating/moving through the elements of the vector in the
reverse order.
APMPP
(his um.’
r
m4 minivan!) r‘
v-nush_hack(l|umel‘(l))i v.nush_hack(l|um(1)); v-Iiush_hacklllumll‘(3)); x
v.push_hack(l4umerll)l; vJushJacklliumrlii); ‘x
"(WWW mm“, n; ;
m (n - whenlil); n r- hum; a»;
nr1n1ﬂ14 ~, 11-min); ‘
vectormumern:reverseJKeram‘ m;
m (m e LINEN); m r: “mm; m”)
vmmm: ". m-wn-m;
l—
b This example will print: “1 2 3 4 5 5 4 3 21"

***************Ending Page***************


***************Beginning Page***************
***************page number:26**************
> Inserting elements in a vector: i
APP-cup l
a.“ m,» i
l i
m MM“) i
( v=mr<mmh=r> v;

v.9ush7hick01mhll11”; inlshihickUﬂlilthUnS mannincklnumrlln;
“Wilhullmulm; “Wilhullimwlsn;
ummmmnmim i . “who;
v.ins=r't(i ¢ I, nubv'lxlh;
um); (1 ( mmdll)
( mml"xa,", mm“);
in;
I
> Thi's example will prim: 1,2,1 3,4,5

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
> Deleting an element from the vector: ( wernseﬁteratar) ) I
APP-cup t
:hss m"

( t
m "MW t
(
v=mr<nmh=r> v;
v.9ush7hick01mhll11”; “wet-Jukmm-run; vJuanackmma-NSH;
v.m.,h.(tt~mwtm; v.m.,h.(ttmmem
ummmmmm, , . Mum);
Vaughn);
v.=ras=(i¢3);
unil- (i t v.lnd())
(
printﬂ'Xdl'. !->Vll||e);
1M;
}
'—
> This example will print: 1,2,4

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
STL - Vector

> This code compiles‘ However, keep in mind that after an element i5 deleted, an
iterator can be invalid‘ As a general mle, don't REUSE an interator alter it was
deleted like in the next example: "mmmim"

APMPP

chss um.’

t

vet-1 numb/aid) t‘

‘ "(mt-m» t; ‘t
v.|:ush_hack(l|umer(l)); v-Izush_hacklllum(1))i ~.|=tet_t.ettttmrtm; x
v.push_ha:k(l4umer(l)); v.push_hacktuumrts)); ‘x
vecmrmumenzzneramr t e memo: x
um- 1 ;
mm (1 < “my; ‘
i mmtmm Hm“);

w;
t
)—
> During the execution, an exception will be triggered on "\Lemseﬁﬂ)”

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
> To ﬁx the previous problem, we don't re-use an iterator when we delete an

element. Instead, we compute an iterator in place (using \cbeginO to do

this)‘

APMPP

(his um.’

r

m4 numb/aid) L

‘ x
“(tam-m» v; ‘a
v.|zush_hack(l|umer(1)); v.|zush_hack(l|um(1)); v.|:ush_hack(l|umer(3)); x
v.push_haek(l4umer(l)); v.push_hack(uumr(s)); ‘x
vLerasﬂvaeDnOﬁ \
wannabmmm; L
vector<Numer>::1ter-tur 1 - when“);
at!!! u < “mm i
r "

mmmam Hm“);
w;

y

)

> ﬁrs coﬂe compiles aria works correcE y.

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
STL - Vector
> other operators that are overwritten are relationship operators I), < , !:, .4.)
> Two vectors are considered to be equals if they have the same number of elements
and elements with the same index in those two vectors are equal‘
APP~¢PP
<1.” mm"
l
mm mum-n l
i a
vecrumumll‘) v1; l
veetmdlumen v2; z
m 1m n e n; n < n; n») ‘i
‘ i...,u,i_h.mimmm;
VLFIASVLDIckUthEFHFI); E
if m e: v2)
mmlm 1; "in with v2");
11;!
prsnrfﬁﬂ As “(femur m“ wy;
)
> This example will not compile as Number does not have an operntnr== deﬁned l

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
> Make sure that you define aperator== as const. vector iemplate requires a ‘
const OPEIEIGI== t0 work, ‘
> This code will not compile. ‘
APMPP I
(his mm. \
( ‘
bun] agar-(m-(znnsl mm" m; ( return v.1“! .. “mu; y
n
void nimble“)
(
"(mm-m.» n;
“(ml-(Human n;
m (m u - n; u < 1|; w“:
(
nyusnjickﬂlumnvhﬂli
V1_I!IASI7BICKUIIAMIF(¢F));
if (v: n v2)
Frinﬂ’!!! As em! mm v2‘);
.15. ,,
antﬂ'Vz 1s different (hm V2");
)

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
> Now this code compiles and work as expected.
> You can also replace operat0r== with a friend function with the following
syntax: “m1 mm mm": (cans! um" a "1, must Number a "1);"
APP~¢PP
ch55 um"
(
m1 “Mm-(m! M" In!)-{ mm v.1“! .. nLV-lue; , ‘
mu "mu/m) 1
c x
"(mm-m.» n; i
vulnrmwrhen n; \
m (m u - I; u ( 1|; u“:
nip-immmm-mm; 1
nJ-isnjnuum-m'n;
i
u m .. m
FrinKﬂ’!!! As equal mm v2‘);
.15-
vmmm n different m“ v2");
)

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
STL - Vector
> For < and > compare operations, vector template uses the following
algorithm (see the pseudo-code below) to decide if a vector is bigger/smaller
than another one‘
mm”. {miner mm» is. vemr in pp. pp
5m - mmvmm. v1.51“) we mum“,
m (H; 1611:; a”) 4
u mm < mm qum v1;
mm m 15 Mn" m" w; vemrunt) v1; ‘
m u x
m m “mu-(km); l
u (‘11.51" < v1.51") vz-pusmmzs); vZ-PHSLBIKKKZQ); l
rm". wt is win-r my. v2‘; x
m 1r u m < m i
mm w: is m mu" my. v2’; mmmmm; i‘
m rumm- )
> One important observation here is that operator) is not needed {only I
operator< is needed to decide),
> The previous code will print “v2<v1 " (even if “v2” has two elements, and
“v1 " only one),

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
> Let's analyze the following example: ‘
APMPP ‘
a»: mm» ‘
(
law] wnnwﬂnmsl Hum-v in!) csmsl ( "tum Vzlun < nLVﬂlAI; ) ‘
)i l
m mum“; l
l l
vectmmunhen v1:
vlcloKNumn) n;
v1.push_hack(r4umlr(lll; v1.nush_hack(r4umar(1n; v1.nush_hack(r4umar(3n;
v2~llush_hack(r4umer(1771 “JUSLWMMWW V2.|JUSh_hi¢l<(NMhEr(l771
‘f (n < m
prnmﬂmﬂ‘);
else ,
printﬂWvV'DK");
>—
> This code compiles and upon execution prints “OK” 0n the Screen as v1,[2]=3
and vZ[Z]=4, and 3<4

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
> This code will not compile as aperator< is not defined.
APMPP
a»: mm»
(
m1 w-mw>(mn mm.’ m1) (mist ( mm m“- < mm“; )
);
in“ milllvnid)
i
vecmRNunl-ien v1: ‘
"stadium-n n; i
v1.|zush_hack(r4umll‘(ln; vl-nush_hack(r4umer(1n; u.m._h.<n~ummn; l
v2.|aush_hack(Numer(1771 v2~push_hack(Numer(277: v2.push_hack(r4umer(lyyz i
if (n > m
nr1n1f(‘m'); 1
u“
mmuwv'wn
)—
> veztcr template requires 0peral0r< t0 be defined in class Number. Similarly,
operated: is not needed, only operat0r== is‘

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
> You can also copy the values from one vector into another. 3
APMPP 3
dass Hume!‘ ‘
( l
wan nun-(wan) r
i venmdlunhen v11 ‘

"(mm-m.» n;
v1.|zush_hack(l|umlr(ln; v1.|:ush_hack(llumer(1n; v1.|:ush_hack(l|umer(3n;
fur (1n! 1 - B; 1 < H.311“); 1»)
prunﬂm ~, mum“);
l ,,
> This code compiles and prints 1 Z 3

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
STL - Vector
> The following methods from template vector can be used to obtain different
information:
> sizel) —> the amount of elements stored in the vector
> capacityl) —> the pre-allocated space in the vector
> mauizeu —> maximum number of elements that can be stored in the vector
> emptyu —> returns “true” if the current vector has no elements ‘
t dataO -> provides direct access (a pointer) te all of the elements m the vector.
APP-CPI’ ‘r
<1.” Hume!‘ t ); g
ma mutant
vectmdlumen v; "
mausnjnklllumnrlllli v-vusnjnkWum-rﬂlli
mum ~. mum”;
prinlﬂ'ld ~, “new;
mum-n a v.:anaeﬂy())l
Hunter 'n e v.4:li1);
pnntfl"lid 14]"v "DJ-VII“, llll]-\II]IAI);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
STL - Deq ue
> The "deque" template is very similar to “vertor”.
> The main different is that elements don't have consecutive memory
addresses‘ That is why the “data” method is not available for a deque. This
also goes [or the “reserve” and “capacity” methods‘
> But deque has new methods (pusthont and poeront]
> The rest of the methods behave just like the ones in the “vector” class l
k > In order to use a deque: “#include <deques"

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
STL - Deq ue
This is an illustrative picture that shows the difference between vector and I‘
deque. It should be NOTED that this is but am illustrative picture and does not j‘
reflect how the algorithms actually work‘ I
rt Object 1 1 ptr m Object 1 Object 4 1
Object z ‘ ' ptr to Object 2 \ — 1
Object 3 ptr to Object 3 g‘ — I
ma- mowm ‘mm- *
Object 2
Vector Deque —

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Let's retest the previous algon'thm r this time we will use deque as well,
Vec-1.cpp Vec-Z.cpp
mu MAW/aid) vnld “Iv-mm
t 4
vactwdntlllw v; vuterdntuem v;
Integer 1; lmc=|=r a;
m (m n- . n w < mm; ‘my ‘(Juan/100m);
( m (m u - a; u t am; m.)
1.5mm; 4
v_pu§n,n.ck(1;; 1.5mm; ‘
) “mmmkm; x
) ) ‘x
— ) \
Deq-l .Cpp E
mu "mum;
“tn-“mun” v;
Integer x;
m (m u . .1 u < sum: Ir»)
(
1.5-lltr);
v.9u5h7blckll);
)
1

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
STL - Deq ue
Results:
EE-I-I-I-I-I-
Vec- lnit l7 U D O 0 D O 0 D l7
1 Set 1955 1911 1937 1911 1911 1953 1937 1938 1911 1911
VEC- ll'llt 140 115 157 115 109 110 110 109 11D 110
Z SE! 531 515 515 516 516 515 531 516 515 500
Deq lnit 0 0 D l7 0 0 3509 0 0 0
.1 Set 6B7 657 656 640 656 640 656 641 641 640
> Vec-1 and Vect-Z 9 two methods using vector
> Deq-1 9 same algorithm using deque '
> “lnit” 9 the series of times recorded when we initialize the container
b “Set” 9 the series of times needed to add the data in in container,,~~
> T1 ., T10 9 result times

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
STL - Deq ue

Results: Execution time
nan ‘a
1m ‘a
.m a
11w \
1m ‘x
m ‘a
m x
m
ma

" Vet-1 v=<-1 Deq-i
mt u i205 n
user ma w W
.m .w

b Vec-1 and Vect-Z -) two methods using vector

> Deq-1 -) same algorithm using deque ﬂ/

> “lnit” -) the series of times recorded when we initialize the container

v “Set” -) the series of times needed to add the data in in container

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
STL - Array

> The "array" template has been introduced in the Cw11 standard.

> It represents a fixed size vector x1‘

> It has almost the same support as the vector class (iterators, overloaded
operators, etc)

> It doesn't have any add methods [having a fixed size, it doesn’t need them)

> For the same reason, it doen't have any methods that can be used to erase an x
element

> It has some methods that vector doesn not have (eg. fill)

> In order to use an array: “#include <array>"

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
STL - Array ‘
> An example on how to use array template: ‘
APPIPP
chss mm“ ‘
t i
ma mihlvniﬂ) ‘
i straw-mu» v1
Lanai-mum;
m (m u - a; u < 14.31110; Ir»)
uni-(“"14 "mm-1m;
m ("Indium-r, Swat-rater n e Lit-mi); n < “ii-:0; 1m)
“Om-la - an;
whiff” v.ﬂ(37.va!u:71
> In case of array template, the size is predefined -> this means that is
somehow equivalent to a vector template that is initialized with using
resizeO method,

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
STL - Array & vector
> Both array and vector have 2 ways of accessing elements: the [] operator
and the “at” method
> They both return an object reference and have z forms:
, Type& operator[](slze,typei
~ const Typeﬁ uperawr[]lsize_type) const
C Type& at(size_type) i
C const TypeB atlsize_type)
C sizegype is deﬁned as size; (typedef she; sizegype»
b There are diﬂerences between these two implementations that will be
discussed in the next slides ,7

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
STL , Array & vector
> Let's see how uperatar” and method “at” are deﬁned 2
APP-CPD APP~CPD
MW“ “MUM Ml 7mm Wimmnum y“)
( 1F (75112 <- 305)
,Xmo.
Nturn (_Elen§[_Pn§])l
)—
,mlysls,=§§m,<,m < ,Smyl
rum lianyuqn
)
mm
mm, 7.".l,,l,r.,,l.l,lw1 H m mm
Compile method Value of ilTERATORiDEBUGiLEVEL ,
Release 0
Release (isECUREiscL) 1
Debug 2

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
STL - LlSt

> The “list” template is a doubly-linked list ‘1

> Elements do not share a contiguous memory block ‘1

> Element access is possible only by moving through the list using iterators, The l‘
first and last element are easier to access r

> The list iterator doesn't implement the < operator a the elements aren't
stored in consecutive memory addresses, and so this type of Comparison r
between these addresses is pointless‘ lt does, however, implement the ==
operatol:

> The list iterator does not implement the + and - operators; only +0 and -- are
implemented

> Methods used to add elements: push_back and push_front

> To remove elements: erase, pop_front, or pop_back can be used

> It supports a series oi new methods: merge, splice (work with otherylist's)

> In order to use a list: “#lnclude <llst>"

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
STL — L1 St
> An example of using the list template
APP-cw
(1.5; mm { );
um nun-(wad)
l
listmumcn v;
vJulebickUlumINlnF wwmmmm-mn; “William-1mm»;
mmnjunuu-mrun; ~.W§Umuuumrln:; l.pu§Umuu-mrls::;
lisrmumenuinrﬂ ~ l
m m Z “llmulmw a
mmlm: "Y ~ v v . 2
n - wheﬂnlyq; 3
vAnserKlAn Numerlzln: ‘a
m m Z v.h:|inl); it I: mm); ml)
pnnlﬂ'id ~, “mm-m);
i! - ~~v.hagjn(); "””
V.:ris!(£()1
m m Z mum); n I: mm); a»)
mmlm: ", 1mm“);
)
> This code will not compile as (he list template does not have operator< and
operatop deﬁned,

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
> An example of using the ‘is! template
APP-CPD
(1.5; uumer ( ); ‘
um mum-1:
l ‘
listmumcn v;
"Minimum-mu); wwme-m-mn; “Minimum-run;
v-Dushifrunllllumerlini v-liushjrunllllumerllni V.W§Umz(uumr(s::;
lAsRNunbenuinrﬂu m
m m Z v.h=|inl); it x: v.:|\l“)l n»)
mmm: ", “mm-m;
‘I -
vAn l w - my):
m m Z v.h=|inl); it x: v.:|\l“)l n»)
mmm: ", “mm-m;
n - “Luann;
v.2ris!l£()1 H
m m Z mum); n x: mm); a»)
mmm: ", 1mm“);
> This code will not compile as (he list template does not have operatop'ﬂ'eﬁned.

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
STL - LISt ‘
> An example of using the n5: template ‘
APP-CPD
(1.5; uumer ( ); ‘
mm "mum:
1 ‘
lismmnnn v;
vJulebickUlumINlnF wummmm-mn; vJushJackWum-NZU;
v-IiushifrullﬂHIAMQFUIH v-uusnjrunﬂllumarll”; v.pu§njmz(uumr(s::;
lisrmumenuinrﬂu m
m m Z whqim); n I: “mm; ma
mmm: ", “mm-m;
‘I - v.hegjn();£!~~;£!~~;£!~~;
vAnserKML “umrum:
m m Z mum); n I: mm“); n»)
mmm: ", “mm-m;
n - “Luann;
V.!ri5!(i()1 H
m m Z mum); a I: mm“); a»)
mmm: ", 1mm“);
> Now the code compiles and prints: “5 4 3 011 5 4 3 10 011 5 3 71,0611“

***************Ending Page***************


***************Beginning Page***************
***************page number:51**************
STL - Forward LlSt
> The "forwardJist” template is a single linked list container, It has been
added in the C++11 standard
> It respects almcvst the same logic as in the case of the doubly linked list,
> The iterator doesn't overload the -- operator, only ++ (the list is
unidirectional)
> Sorne methods that list has are no longer iound here: push_back and l
popiback
k > In order to use a forward_list: “#include <farward_list>“

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
STL - Forward LlSt ‘
> An example of using the fnrwurdJist template ‘
APP-CPD
(1.5; um" ( ); ‘
m.‘ mum-1:
i :mrummm» v; ‘
LmUmuum-mn; v_mnﬂmwm-m>n vJushJ'rmqumﬂﬂlli
(Mu-I'thlolumen:durum‘ 1!; ‘
m (n - mew-u; n 1- mm); n»)
pmmm ~, iwvn“);
n - “mm;
‘!“; ‘!‘~;
vAnserLafnrun mnberaa»:
m m Z whqinﬁx n 1: mun“); n»)
pnntﬂ'id ~, 1mm“);
n . “Luann;
v.2rise_iﬂel‘(ﬂ)1 "
m m Z VJEIXIIU; n 1: mun“); a»)
pnntﬂ'id ~, 1mm“);
> Now the code compiles and prints: “2 1 0 1 1 0 20 Z 1 10"

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
STL
mam-———“
Access operatorl] operatorl] operatorl] ‘frontU .frontU
‘at() ‘at() ‘am .back()
Jronq) ‘fronto .front()
.back() .back() .back()
.data() ‘dataO
lterators ,beginU ‘beginU ,begim) .begin() ‘begino
.endO ‘end() .endU vend() .end1)
Reverse ‘rbegino ‘rbegino .rbegim) .rbegin()
Iterator ,rendO ‘rend() .rendU ‘rendU
Information ,emptyU ‘emptyU .empty1) .ernpty() .empty()
.si1e() .size() .size1) .size(] .max_size()
,max,size() ‘maxisizeo ,maxisizeo .max,size(]

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
mm-——-——
Size/ .resizel) .resizei) .resize() .resizei)
Capacity .reserveO

.capacityo
Add .push_back() .pusthackO .push_back() .push_front0
.insertO .push_fr0nt1) .push_front() .inserLafterU
.insertU ‘inserto
Delete .clear() .clear() .clearU .clear()
.erase() .erase() .erase(| .popjronq)
.pop_back() .pop_back() .pop_back() .erase_after()
-P0P_fl'°nt() .pop_front1)

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
‘ > Adaptors
\

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
STL - Adaptors
> Adaptors are not containers - in the sense that they do not have an
implementation that can store, they use an existing container that have this
feature for storage
> Adaptors only work if the container that they use implement some specific
functions
> Adaptors do NOT have iterators, but they can use iterators from the container
that they use internally
> Adaptors:
. stack
~ queue
e priority_queue

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
STL - Stack
> This adaptor implements a stack (LIFO , Last In First Out)
> To use : M“include <stack>“
> The deiault container is “deque” (in this example “s” uses deque while “sZ”
uses vector)
APP~¢PP
Wm mum-1) ‘
( ‘x
s!.(k<1n1> s; l
“mum “mum S-PushBI); l‘
sticktinl, vectwtint» n; ‘i
sum-u»); sl-Dushllb); ‘La-15mm; x
> Has the following methods: pushI pop, top, empty, size I
> It alsu implements a method called “_Get_c0ntainer" that can be used to
create iterators based on the container that is being used internally,

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
STL - Queue
> This adaptor implements a queue (FIFO r First In First Out)
> To use : “ﬁnclude <queue>“
> The deiault container is “deque” (in this example “s” uses deque while “sZ”
uses list)
APP~¢PP
Wm mum“) i
( ‘i
lueue<1nl> s; r
“mum “mum S-PushBI); x‘
mud-n, llama» $2; l‘
sum-u»); ‘La-1mm; gamma»); i
> Has the following methods: pushI pop, back, empty, size I
> It alsu implements a method called “_Get_c0ntainer" that can be used to
create iterators based on the container that is being used internally,

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
STL , Priority Queue
> This i5 a queue where each elements has a priority. All elements are sorted out based
on their priority (so that the element with the highest priority is extracted first),
> To use: “#include <queue>"
> The default container i5 “vertor”
APMPP
vam nah-item
‘ amen-"mm s; i
s.pu§h(lbl; s-pusnli); S-Dusnllb); S-puslilli); l
amt (5.0.2!le -- mae, i‘
l aitnmmi n slept”; l
s-FWU? i
> This code prints: “20 15 10 5"
> Has the iouowing methods: push, pap, top, empty, size
> It also implements a method called "_Get_container" that can be used to create
iterators based on the container that is being used internallyt

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
STL e Priority Queue
> A priority_queue can be initialized with a class that has to implement
“operatoro”. This operator is used to compare two elements (it should return
tme if the first one is smaller than the second one)‘
APP-cup
n.” (MD-mule
‘ m Mam;
mm:
mplrdmuléﬂnt v) = mammv) t) i
m) npermro (must m u, must m m must x‘
‘ return m x wavsm) < m x Mil“); ‘E
2 x
); ‘a
void mum“) L
( prwicmwmim vencrdmm culﬂirmll1=> 5(Cmnarmu1=(3)); ‘1
5.9mm); win-ls); 5mm»); “Mm;
while (Slam -- mm
( mmww -. S.WP())£
szFOi
2
)—
> This example prints: "5 20 10 15”

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
STL - Adaptors
-——M
push Container, pushiback Containen pushiback Containen pushiback
pop Container. popihack Containen popjrnnt Containen popiback
top Container. back Container. front
back Containenback

size Containensize Containen size Containen size
empty Containerempty Containen empty Containen empty
stack YES YES YES

queue YES YES

priority_queue YES YES

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Associative
> containers

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
STL (assoc1at1ve conta1 ners - pal r)
> "pair" is a template that contains two values (two different types)
> For use “winclude <ut111ty>“
> Two objects of type pair can be compared because the I operator is
overloaded
> It's internally used by associative containers ‘
> The declaration of pair template:
APP~CPP l
t-wht- (ch55 v1, (his m a
mm pnr
r
v1 farsri
v2 second;

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
STL (assocratlve contar ners - map)
> Map is a Container that store pairs of the form: key/value; the access t0 the
value field can be done using the key
b For use “winclude <map>”
> The key field is constant: after a key/value pair is added into a map, the key
cannot be modiﬁed - only the value can be modified, Other pairs can be
added and existing pairs can be deleted‘ a‘
> The declaration of Inap template: ‘i
APP~¢PP ‘I
(anal-u < (1.5; my, (1.5; v.1“, (1.5; tam-re . 115mm > <1.“ DID ‘
i ,,

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
> An example of using map:
APP~CPP
vain m.1n<vu1n>
<
mmmt Kw‘. inn mm;
Gradeﬁl“PnPeszu‘l Z w;
Grad:5["1un:s<u“l Z a,
aranasF'nann“! - v;
wmmmmn grin: . mm, EradeS["Innas<kl“l)?
Primmm" B1 Wm Z mm‘, Gradessneﬂl;
mipqnnst my‘. 1m>==1terwtnr m
m m Z mmmqho, a: ‘Z Gradcsxmﬂ), it“)
ppm““man-mn“, 1(->ﬂrs(, 1(.>;E<m.¢>;
A! . mm.mnmmm“);
6r:ﬂ=s.=ris=(it)i
1m X Z arms [my-“ml; Output
prinmuumw; grad: Z m (Fmv-u Grad:s["lun:s<u“ln<)
) printﬂwumbar uf pairs - xnvl“, mmmqm Masai-5 grade Z q
Number of paws : 3
Grades[Pupesm]:m
Gradesﬂonescuk‘?
GradES[Marm]:7
lonescu's grade : 0 (x:0)
Number m pairs Z 3

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
STL (assoc1at1ve contamers - map)
> An example of using map:
APFWFF'
m, WW)
( mucous: char’, inn Gram;
Gran=s[“Pva=sm‘l Z 10;
Frimiﬂnmhzr oi pair: : “\n’, Gradsaixﬂn;
for (it : iridujqinﬂ; it i: Gridas.arli(); it") ‘
Prsnrﬂ'analsuspmw', “mm, “Oman”; 3

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
STL (associative contai ners - map)
> The methods supported by the map container:
Assignment (opei'atnr= )
Accessing and inserting values 1nperatorl] and at, Insert methods)
Deletion 1Qrase, clear methnds)
Search Into ii map mna mmhod)
Iteratovs {heglm end, rbegln, rend, :begin, cend, “begin, crend (the last 4 from
cﬂm P
lnfOrmatiOnS 15in, empty, makslle)

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
STL (assoclatlve conta1 ners - map)
> Accessing elements {[1 operator and at, ﬁnd methods):
APP-CPD
void m21ﬂ(vnld)
(
miu<<uns¢ (sir“ ,“¢> ﬁrings;
Grid:5[“PaD:S€u“] Z 1n;
pr1n1f("ﬁradz Z ld\n“, Grad25|“70925(u“])r
l______________________________________________
APP-CPP
vain ms1n<vs1n>
<
mip<zbn$t zhsr', inky Grades
6r:d:£l“PnP:szu“l Z 1B
prirIt((“Grad:: raw‘, Grad:s.R("PuD:s<u"))?
1
prp
vuid mainKvuid)
(
map<<nnst <har‘, 1n!) GrantS
Grad:$['PuP:szu'l Z 1e; ,
Printf(‘$rad:: 1¢\"". Grades.find("PuP:x<u")'>s:<un¢7i
1

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
Accessing elemems {[1 operator and at, find methods]:
wm malﬂvuld?
<
mneq mew 1 Z 1e,
pH“U(“(-rade , m" ‘ WM Popesm 17,
)—
App.cpp1“lnne§cu" key does not exist)
vnkn main(vnin)
<
mum Popﬁzu 1 Z w.
anﬂ'mrme: 1mm‘, uranes.m!("mnes<u‘))l
>—
Appxpp (“lonescu" key does not exist)
vulq ma1"(vu1ﬁ)
<
mm WW 1 Z ID,
anf("nran== MM . mmjwvmmm >V>§=<W>.
>

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
STL(assoc1at1ve contamers - map) ‘
> Checking whether an element exlsts m a map can be done using find and ‘
count methods:
APP-cup
vain mainKvuidi
<
Grade5[“PnPeszu"l Z w;
a‘ (Grad:s.ﬂnd("1un:s<u")aGradqudUi
mmmumm m; m1! mu 1" m! gum 115w);
‘—
APP-CPD
vula malnzvulav
(
mawcunsl m», in!) Grams;
mmwnpmm Z an;
1‘ (emunmr leesnl‘ we)
Vrzrlﬂ(“1un:xcu dun nwt :xnt 1n m was 11mm
1

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
STL(assoc1ative containers - map)
> The elements from a map containers are stored into a red-black tree ‘a
> This represents a compromise between the access/insertion time and the
amount of allocated memory for the container
> Depending on what we are interested in, a map container is not always the it‘
best solution (etg. if the number of insertions is much bigger than the number
of reads, there are containers that are more efficient)
> We do the following experiment a the same algorithm is written using a map
and a simple vector and we evaluate the insertion time
> The experiment is repeated ten times for each algorithm and the execution
times are measured in milliseconds

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
STL (assoc1at1ve conta1 ners - map)
> The two algorithms:
Map-1.:pp
vnld “mum
( swim. my mu
a» (m v Z a; v < 1mm; w’)
1mm] - m
’—
Map-Z.cpp ‘
m WM“) ‘i
( mt rm: - n91 mum]; ‘i
m (m tr Z a; tr < 1m; cw) x
“mm - tr; x
> Even if it is obvious that App-Z is more eificient, the hash collisions must be ‘
considered‘ For the above case, there are no hash collisions because the keys
are integers.

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
STL (assoclatlve contamers - map)
> Results:
III-I-II-I“
Mlp~1 20156 20625 20672 20453 199211954719219 19516 1956319344 19901
Map-1 0 16 0 0 16 o 15 o 16 o 6.3
\
‘1
> The specifications of the system: \\
6 os: Windows 8.1 Pro \
~:~ Compiler: cl.exe [1a.00.z1005.1 for x86] \
- Hardware: Dell Latitude 7440 '17 460W, 2.70 6H1, a cs RAM

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
STL (assoc1at1ve conta1 ners - multlmap)
> “multimap” is a container similar to maps The difierence is that a key can
contain more values.
b For use “winclude <map>”
> Accessing elements: the [] operator and the at method can not be used
anymore,
> The declaration ot multimap template:
APP~CPP l
tnmvhtn < chss Kly» chss Vilul, chss (www- : llss<Kly> > (lass mlnrup ‘l
( /~

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
STL (assoclatlve contamers - multlmap)
> An example of using mummap:
APP~CPP
VD,“ m.1n(vu1n>
(
@5me Hm‘, m mm;
Gradesdnsertlpalrnnnst m». mwmw‘. 1877:
Gradcsdnscrﬂpaincunst my», in!>(“lun:s<u“, a»,
Gradasdnsarﬂpairuuns! m», 1n!>(“1unes<u“, 1));
GraﬂaansarqpaAraunsl m“, mvmm“, a»;
mummmm m». 1m>==1terwtnr m
‘ur m Z Grad:s.b:gin(); it ‘Z Grad:s.:nd(), it“)
( Prlhlf(“XS Hahn“, Al->ﬂrsl,A{->s!<nﬂﬂ)‘,
1 1 Output
lonescu [10]
lonescu [a]
lunescu [7]
Popescu [9]

***************Ending Page***************


***************Beginning Page***************
***************page number:76**************
STL (assoclatlve conta1 ners - multlmap)
> An example of using mummap:
APP~CPP
M mmmn»
(
MMMMWWQN “w, mvpmm“, g»;
mum-mm (awn Momma» m
k . Mammy,
prinﬂ(“is»in\n“. “mm. WWW";
Output
it Z W“.“upwmmmiw,
pnnzf(“xs->xn\n“, 1mm“, Mm“); mescuum
it : Griﬂrslupprrihwnnﬁt'Mil-st); P0pescu~9
1 mmmwmn“. 1mm“. “Qatar-67; Georgescu- .3

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
STL (assoclatlve conta1 ners - multlmap)
> An example of using mummap:
APP~CPP
Wm mar-(wan)
(
MMMWMQM “W, Ann(“>uvas<u“, g»,
mum-Wm W, WWW” 1!;
m m . Grammy“); k ‘. Grammy, n . mm.u,w,mm.mm>>
<
mmwm-m: k:y: inn‘. ‘warm; Output
) um“? key: \unescu
1
Umque key: Papescu
Umque kev: Georgescu '

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
> An example of using mummap:
APP~CPP
vain m.1n<vu1n>
<
memmt my‘, inn mm.
Gradadnartlpnrnnnst mp. inbl 1W5”. 1877:
Gradudnsvﬂpainmnst KW», 1nt>(“lun:s<u“, a»,
GradEansarqpaiNmnst m», 1nn(“1unas<u“, m;
GranaansarqpaAraunsl m», “Dvmmm, s»;
6Piﬂ=$dn$=rﬂpiir<zunst my‘, 1nt>(“Pup:s:u“. 5));
Gradadnartlpnrnnnst mp. 1m>L‘G:urg:szu‘. m;
mullimiwcuns! m», innzzimrazur n;
n . Granasmagirﬂ);
m“ (it ‘Z arin=s.=nn(>>
<
rang! - arenas.EqualjangEUz-ersz);
Dummy; mm; Alwﬂrsi);
1Br (it Z r.nx=.1irst; it ‘Z rang:.$=:bnﬂi at..>
mum ‘1a. ‘. Kimmy-av. OUtF'Ut
1 WM" ‘" >’ Imescu’; grades: ‘0.8.7
1 Popescu's glades:9.6
Georgescu’§ gradesﬂ

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
STL (assoclatlve conta1 ners - multlmap)
> An example of using mummap:
APP~CPP
vain m.1n<vu1n>
<
whimwmmt :har‘, int) 6mm
Gradesdnsertlpalﬂznnst m». 1M ‘Xunesnﬂ. mm
Gradudnsvﬂpainmnst my», in!>(“lun:scu“, a»,
Gradasdnsarﬂpairuuns! m», 1n(>(“1unes<u“, 1));
GranaansarqpaAraunsl m“, An!>(“>uvas<u“, 9));
emudnwmmﬂmn :har‘, hwvmw“, 5));
Gradesdnsertlpalﬂznnst m». 1M ‘Geariesnﬂ. an:
Mum-Wm.“ m», innzzkaramr 11,111;
A! . mm.mavmmm
m Z Gradesmpprrihuunﬂﬁt'vﬁrsﬂi
Output
Print‘(“PuD:s<u’s mm. w,
2mm m \- nu) Popescu's grades: 9,6
prinﬂ(“!ﬂ.“. it'vsrwnﬂli
1t“;
1
]—

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
STL (assoclatlve conta1 ners - multlmap)
> An example of using mummap:
APP~CPP
vuid m.1n<vu1n>
<
whimpmmst Hm‘, int) mm;
Gradesdnser'tlpalmznnst m». 1M>L‘Xunesnl‘. 1577:
Gradcsdnsﬂﬂphiruunst KW», int>(“1un:s<u“, m,
Gradeanserqpairuuns! m", movlmm“, m;
GranaansarqpaArauns! m", mmmmm, a»;
6riﬂ=$dn$=rﬂpiir<zunst Hm‘, int>(“Pup:s:u“. 5));
Gradesdnser'tlpalmznnst m». 1m>1‘6eurgeszu‘. s77:
mullimiwcunsl m", innzziurazur 1mm
m m . Granasmagirﬂ); k \. Granasmmﬂ); n . mm.uppﬂjmum-mrﬂ»
< printﬂ“%s m 1a iraduw‘. 1mm“. Gramnmuwmmn
1
) Output
lonescu has 3 grades ,
Popescu has Z grades
Georgescu has 1 grades

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
STL (assoclatlve contamers - multlmap)
> An example of using mummap:
APP~CPP
vain m.1n<vu1n>
<
memmr Hm‘, inn mm;
Gradesdnser'tlpalrunnst mp. mmwwg mm
Gradudnsvﬂpiiruunst mar‘, int>(“lun:s<u“, a»,
GradEansarqpaiNmnst m", 1n(>(“1unas(u“y m;
GraﬂaansarqpaArauns! m", Ann(“PnDas<u“, 9));
Gradesdnserﬂpiinwnst Hm‘, “bppmmu 5));
Gradesdnser'tlpalrunnst mp. mwmmw‘. s77:
mullimiwcunsl m», innzzizarazur 1mm
A! . mm.mnwmmm“);
it“;
em=s.=m=zm=
m m Z m¢=;.b=gin(>, a: ‘Z Gm=;.=m:>, kn)
( Oquul /
“mums mm“, koﬂrsl, At-namnﬂ)?
) > lonescu [10]
lonescu [7]
Popescu [9]
Popescu [6]
Georgescu [8]

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
STL (assoclatlve conta1 ners - multlmap)
> An example of using mummap:
APP~CPP
Wm mar-(wan)
(
mm.“m<,m<<m “w, Anu(“>uvas<u“, g»,
1f (Grains.f1nd(“1unas<u“) \- arenas (andO)
prmlﬂﬁmscu manswu“);
1f (Grad:s.f1nd(“Mar-v|“7 Z: Granazcr-YIUV
WWW!" m; W “WW,
) Output /
Ionescu exists!
Marin DOES NOT eXiSt‘.

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
STL (associative containers - multimap)
> The methods supported by the multimap container:
Assignment (uperater= 1
insertion (insert)
Deletion (erase, clear methods)
Accessing elements (find method]
Iterator: (begin, end, rbegln, rend, :be-gln, send, :rbegln, (rend
lniorrnatiens (size, empty, max_slze methods)
Special methods (upper_hound and lower_bound e to access the intervals in witch
there are elements with the same key; equal_range ~ to obtain an interval for all the
elements stered ier a ke'y)

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
STL(assoc1at1ve contamers - set)

> “set” is a container that store unique elements ‘E

> For use “winclude <set>"

> The declaration o‘ set template:

l
k 22mm“ l class w class cw." - mm“) , ‘1m an

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
STL (assoc1at1ve conta1 ners - set)
> An example of using set:
APP~KPP
m, MW.”
( any“) s;
s.ins=rt(1ﬂ)3
sdnseﬁui);
“mm”;
ansuﬂsn);
satantmxzaratar m
m m - mum); a: 1- 5.17.40; a“) ‘
mnm'n -, at); 3
Output
5 10 20 ‘

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
STL (assoclatlve conta1 ners - set)
> An example of using set:
APP~CPP
m“ “Wm (
m1 “Mum km M 11mm, (m M “mam (m
< return Llemalue / 287 < (rlgm'value / 207i
); 1
vuiﬂ miinuiﬂ)
(
5mm, “mm” 5;
5.1mm“);
xmmm;
“mm
s.1ns:rﬂw7i
5mm, mwmmmm it,
Ompul
m m . may“); k \. mm; n»)
) WWW ‘in; 1o 20 ,

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
STL (assoclatlve conta1 ners - set)
> The elements from a “set” follows a specific order.
> This brings a performance penalty.
Set-chp
void Emma)
l
seninv s;
m (m v e n, v < 1mm, (M)
5 “mum.
)—
> Let's remake the previous experiment:
-I-mu-i-II
Map-1 ZU156 20615 10672 20453 19921 19547 19219 19516 1956319344
Map-Z D 16 O O 16 D 15 O 16 O
Set-1 15375 15469 16407 16563 16359 15750 16094 16615 171131 15906

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
STL (associative contai ners - set)
> The methods supported by the set container:
Assignment (opei'atnr= )
Insertion (insert method)
Deletion 1erase, clear methnds)
Accessing elements (ﬁnd method)
Iteratovs {heglm end, rbegln, rend, :begin, cend, “begin, crend (the last 4 from
cﬂm P
\ lnfOrmatiOnS 15in, empty, makslle methods)

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
STL (assoclatlve contamers - multlset)

> “multiset” is similar with set, but duplicate elements are allowed ‘E

> For use “winclude <set>"

> The declaration o‘ multiset template:

l
k 22mm“ ( class w class cw." - mmw , ‘1m mlnsu

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
STL (assoc1at1ve conta1 ners - multlset)
> An example of using multiset:
APP~=PP
M mm“)
( mummy.» s;
s.ins=rt(1ﬂ)3
sdnseﬁui);
“mm”;
5.,"Smw
mmmm 1mm” m
m m - mum); a: 1- 5.17.40; a“) ‘
mnm'n -, at); 3
Output
5 10 10 20 ‘

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
STL (associative containers - multiset)
> The methods supported by the multiset container:
Assignment (dperater= 1
insertion (insert)
Deletion (erase, clear methods)
Accessing elements (ﬁnd method]
Iterator: (begin, end, rbegln, rend, :be-gln, cend, :rbegln, crend
lniorrnatiens (size, empty, max_slze methods)
Special methods (npper_l>dund and lower_bound e [0 access the intervals in witch
there are elements with the same key; equal_range ~ to obtain an interval that
includes all the elemems which have a speciﬁc key}

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
STL (assoc1at1ve conta1 ners -

unordered_map)

> The elements from an unordered_map container are stored into a hash-table

> Introduced in C++11

> For use “winclude <unordered_map>"

> Supports the same methods as map plus methods for the control of buckets‘

> The declaration of unordered_map template: r
APP~CPP
“Mm < chss Key, chss v.1“, chss m», chss w.‘ > chss “Manet-P ‘

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
STL (associative containers -
unordered_map) 1
> How hash tables works: m-
1
Hash function(transforms ‘
a string into a index)
k

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
STL (assoc1at1ve contamers -
unordered_map)
IE5-
» How hash tables works. 0 NULL
1 NULL
We consvder the 2 NULL
foUowwg hashing 3 NULL
Yunctmn:
HashFunction 5 NULL
G int lenrunniankanst (mr' 51 6 NULL /"
EDI’ escu . ‘ ,
_ $130:in u 7 NULL
‘ u“;- ('57; a NULL
Em m 1 m 9 NULL
7— 10 NULL
11 NULL

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
STL (associative containers -
unordered_map)
> How hash tables works: gm-
1 NULL
Popescu z NULL
3 Popescu
|:| Hash (“Popescu”) 4 NULL \
= 3 5 NULL \i
- 6 NULL \i
Georgescu
7 NULL \
B NULL
9 NULL
10 NULL
11 NULL

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
STL (associative containers -
unordered_map)
> How hash tables works: gm-
1 NULL
3 Popescu
E Hash ("lonescu"b I 4 NULL ‘i
6 5 NULL
- 6 Ionescu ‘i
Georgescu ‘
7 NULL i
B NULL
9 NULL
10 NULL
11 NULL

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
STL (associative containers -
unordered_map)
> How hash tables works: 0
1 NULL
3 Popescu
|:| Hash(“Georgescu"| 4 NULL ‘i
Z 8 5 NULL
6 Ionescu ‘i
Georgescu ‘
7 NULL i
B Georgescu
9 NULL
10 NULL
11 NULL

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
STL (associative containers -

unordered_map)

> Consider the following code:

Umap-chp
1
vesxhrhr,
)—

b Let's remake the previous experiment:
--"--m
Map-1 20156 20625 20672 20453 19922 19547 19219 195161956319344
Map-2 0 16 0 U 16 0 15 0 16 U ,
Set-1 15375 15469 16407 16563 16359 15750 16094 166251703215906
Umap»1 14891 15984 15578 15063 15251] 15224 15704 149531526515186

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
STL (assoclatlve contamers -

unordered_map)

> Consider the following code:

Umap-Z.cpp
t mmwtmmmmmn
)

b Let's remake the previous experiment :
-IIm--H
Map-1 20156 20625 20672 20453 19922 19547 19219 195161956319344
Map-1 0 16 0 0 16 0 15 0 16 0
Set-1 15375 15469 16407 16563 16359 15750 16094 166251703215906
Umap»1 14891 15984 15578 15063 15250 15234 15704 149531526515186
Umap-Z 9594 9703 10610 9090 10672 9922 10047 9984 9703 993B

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
STL (assoc1at1ve conta1 ners -
unordered_set)
> “unordered_set“ is similar with the set container, but the elements are not
sorted
> Introduced in C++l1
> For use “#include <unordered_set>"
> Supports the same methods as set plus methods for the control of buckets ‘
> The declaration ot unordered_set template:
APP~CPP
unghu < chss m, chss m», chss w.‘ > chss unwinraanu ‘
)—

***************Ending Page***************


***************Beginning Page***************
***************page number:101**************
STL (assoclatlve contamers -
unordered_set)
> COnSldEI' the following code:
User-Lepp
(
)—
> Let's remake the prekus expenmem:
-I--iI--W
Map-1 20156 20625 20672 20453 19922 19547 19219 195161956319344
Map-2 D 16 0 0 16 0 15 0 16 0
Set-1 15375 15469 16407 16563 16359 15750 16094 166251703215906
Umap-114891 15984 15578 15063 15250 15234 15704 149531526515186
Umap»2 9594 9703 10610 9890 10672 9922 10047 9984 9703 9938
Uset-1 12140 11625 12047 11904 12109 12078 11609 115701178211672

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
STL (assoclatlve contamers -

unordered_set)

> And the vanant with reserve:
User-Lepp
(
)
------ﬂ!%
Map-1 20156 20625 20672 20453 19922 19547 19219 19516 19563 19344
Map-Z 0 16 0 0 16 0 15 0 16 0
Set-1 15375 15469 16407 16563 16359 15750 16094 16625 17032 15906
Umap-114891 15984 1557B 15063 15250 15234 15704 14953 15265 15186
Umap~2 9594 9703 10610 9890 10672 9922 10047 9984 9703 993B
Uset-1 12140 11625 12047 11984 12109 1207B 11609 11578 11782 11672
Uset-Z 6516 6328 6575 6844 6812 6453 6453 6531 6500 6515

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
STL (assoc1at1ve containers)
> Besides the presented containers, two other associative containers exists: ‘l
> unorderedimultimap
> unorderedimultlset ‘E
> Similar with multimap/multiset (the diiference is that hash tables are used, ‘3
not sorted trees) ‘a
> When choosing between map and unordered_map (set and unordered_set,
m), the amount of available memory and the execution times (insertion,
deletion, access of elements, m) must be considered‘

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
l l/O Streams

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
STL 005)
iosibase
ios clog
cm istream — iostream _ ostream mm E1‘
vistream lstnngstream ostrmgslream oisneam
(stream stringstream ,7

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
> From the previous presented classes, the most used are istream, ostream and ‘a
iostream,

> These classes allows the |/0 access to miscellaneous streams (most well-
known is the file system) ‘a

> Another use is represented by the cin and cout objects, which can be used to
write to! read from the terminal

> Two operators are overloaded for these classes loperator» and operator“),
representing the input from stream and the output to stream, respectively

> Besides the two operators, manipulators were also added to these classes
(elements that can change the way of processing the data that follows them)

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
STL (IOS , manipulators)

endl Adds a line terminator (“\n" , “\ﬂn", etc) and ﬂush

ends Adds ‘\U' (NULL)

flush Clears the stream‘s intern cache

dec The numbers will be written in the base 10.

hex The numbers will be written in the base 16.

oct The numbers will be written in the base 84 \

ws Extracts and discards whitespace characters {until a non-
whitespace character is found) from input

showpoint Shows the decimal point

noshowpoint Doesn't show the decimal point

showpos Add the “+" character in front 0f the positive numbers

ndshowpos Does not add the “+“ character in front of the positive numbers

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
STL (IOS , manipulators)

boolalpha Bool values will be written using “true” and "false"
noboolalpha Bool values will be written using 1 and U

scientific Scientific notation for float/double numbers

fixed Floating-point values will be written using ﬁxed-point notation
lelt Left alignment

right Right alignment

setfill(char) Sets the fill character

setprecisionln) Sets the precision for real numbers

setbaselb) Sets the base

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
> Strings

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
STL (ba51c_str1ng)
> Template that provides the most used operations over strings
> The declaration:
APPJPP
template (class Chivutcﬂypc, ms; trans Z chargransdllannuYyPﬂ»
(1m “signing
i
> The most common objects that implements this template are string and
wstring
APP-cop
tyvmd “ﬂurry-mm» mm;
typed“ baskistrirlgmcharin “string?
> Other Objects introduced CH1 based 0n this template:
APP-CPP
"we wmjtmgmme,» new“.
typedé Daslcistnﬂitcharilib msmm

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
> “char,traits" is a template that provides a list of operations aver the strings
(not necessarily characters of type char) used by hasic_string for some
operations
> The main methods of charitraits are:
Deﬁnition Functionality
mm bwl w (tw- nt ﬂyv- <27 Petumstruullcl lsequalwlthel
mm bani n (awe t1, In»! =1) Returns true Ir =1 u lower than c2
sutlc mu mm (ms! (we s); ktumstheslnnflﬂrilll
53:3 void issiII‘ (mm (“mun wrist mm WWW‘ {dumﬁulm
sutk m (er-u ((nnxt {Upl' n. camp-mmnrinns; IEWMH im “Loim -=z L
cans! nm- in, she; n1; Illﬂ-l rm < =1
sutk cons! mum- mm tasting)!!!‘ 1. MUM“anmmmlmme‘ “Naming
m5; (“Lam Q; "“"‘"*“"""

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
STL (ba51c_str1 ng)
> The main methods 0| charitraits are:
Definition Funcliunality
mm (“new m (amp/we’ an,
cum! ("gum- m. m the carnentvfa sum] between two mum
mu n z
mm mww ‘°”“'ZZZ;§’Z§L'§“;- m Couinllle:mteutufaslrilvgfmmnnelucalimto
mu m1’ w ' ‘"m'"
mm muwe mu Returns I value m :or r umuy -1 l
> “char_traits“ has specializations for <char>, <wchar> which are using elficient
functions like memcpy, memmove, etc. l
> For normal use of strings, a charitraits object is not needed. However, it is A
useful (or the cases where we want a particular behavior (some comparisons
or assignments to be made differently r elgl case insensitive)

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
v “basic,string" supports various forms of initialization:

APP~CPP

vain main(vuidi

<

Sm"; Sqwbmwm“);

5m»; 51m“ x'n KB ‘7;

string 53m, 3, 3),

string “(WWW 1111 gu (u my (Wynn, 11>;

mm SSWJWSUWB»;

Sm"; 35m. w);

pr;nu("x;\nx;\nx;\nx;\nx;\nxs\n“, “Kym,
“£51m,
53.17501),
smastﬂh
55.t75ﬂ‘(7- Output
mkwm,

) ‘lbmorrow
Tomorrow i'Ll go
arr
Tomorrow I'll
I’ll go m
H1i1ii1i1

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
STL (basic_string)
> Methods/operators supported by (he objecxs denved (mm the basicisrring template:
Assignment (operamr= 1
Append (operatun: and append, push Jzack memods]
Charactels insertion (inseﬂ method)
Access to characters (operatorﬂ and at , from (c“1 1) , back (on 1) methods)
Substrlngs (substr methodj
Replace (replace method]
Charactels deletion (erase, clear, and pop_back (CHM) memuds) ,
Search (ﬁnd, rﬁnd, ﬁnd_lirst_ol, find_last_0f, lindJirsLnOLol, find_la§t._n0Lv/f /'
methods) '
Comparations (operamn , ppermr< ,ppermr== , apermrl= , operator» ,
uperator<= and compare method)
lcteraiojrs (begin,end,rbegin,rend,cbegln,cend,crbegln,crend (the Last (our from
H1 1
Information: (size, length, empty, max_§ize, capacity methods)

***************Ending Page***************

***************Beginning Page***************
***************page number:115**************
STL (ba51c_str1 ng)
> An example of working with String objects:
APP~CPP
vuid m.1n<vu1n>
<
Sm"; 3,;
51 "NW";
printH'Sil: Z raw‘, 51.1:ngth())?
51-51,“ “'51;
prAn{f(“51 . “w, sa.nan())?
s!.=l‘i5=(1. A);
prlnth“Sl Z 15w. “awn:
51.375"va L");
Sump“), L“);
prAn{f(“51 . xsw‘, “gum;
simzphcﬂsingirﬂh ‘mum; . 1, muss“);
1 pmntffm Z 15w‘. inﬁrm; Output
Size 1 3
51 : New How
51 : New
s1 : FLDiW
5| : ‘23456uiw

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
> Some example of using char_!raits (a string with ignore case ):
APP~CPP
struzt xlnﬂrlc-SE = Dubliz (n-r,‘r-1‘§‘<»-r) 4
static >501 llithar =,, char =21 4
raturn (unw=r(:1)) 1: <uaa=r<==));
}
stitiK haul 1¢<<nir <1, (nip <2) (
} rlturn (unplr(<111 < (uvvar(<2));
Stitii int :ﬂmnar:(:anst char’ $1, censt char’ :1, Silg_§ n) (
uni}: (">a)
(
("Ir <1 . uDPArK'sill
char =1 - “FFQIK-sz);
1e (:1 < =2) raturn V‘;
1: (‘1 > ‘1) r=turn '1;
51.’; 51.’; "'7;
)
rnurn a;
)
n '
vaid l-1n<va1¢1
(
has!:_strln|<:har, I'nar!(as:> 51(“Sa1ut’);
hasic>strin|<char, IlﬂuraCasa> SZ(“SA1“C“); ,
1: <51 Z: 5:)
Frintf(‘51ruri ‘1-1! 1-1;
)

***************Ending Page***************

***************Beginning Page***************
***************page number:117**************
> Initialization lists

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
Initialization lists
> Initialization lists work with STL as well:
APPIPP
"no maeswce m;
Mia. (MW,
MM. an»
an." Smdem
‘ W (w - a." l
in GM; i
Mi “no ‘i
murmur-ll‘) 5 I ( 'Pm', ‘tn' )i ‘
vechSwdenm er - ( ( 'Wiﬂl', w )- ( 'lwscu', s ) )z
) "News! char“. [an sil - ( ( "Pwesw'. W )- ( "lmescu'. 9 ) )i
> The code complies 0k and all objects are initialized properly.

***************Ending Page***************

***************Beginning Page***************
***************page number:119**************
Initialization lists
> Initialization lists work with STL as well:
APPIPP
um “mm mi
mm (MW,
MM. l...»
M“ Wm
( i
mi (w . in; i
1m Wu i
)i i‘
Mi lah\() ‘i ,
‘ vector-(ﬂit) v - i l, 1. 3 );
veclomsludeﬂ!) s! - l l 'Popescu', w ). ( ‘Maw. a ) )i
napumsx char'. hm n1 1 ( ( ‘PMsw'. W )- ( ‘Imesw'. 9 ) )i
)

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
Initialization lists
> STL also provide a Special Container (called stdliinitialileLIiSt that can be
used to pass a initialization list to a function).
APP-CPD
“5w lulublce m;
"Mme <Mllhll1gr_llsn
m 54-(std::lmtnhxer_hstunt) a) ‘
‘ m “it . a; l
swulnllhluerJIsRMH:ltermr It; x
For (u - mum); i: l- “no; u») ‘x
mink e um; x
Mum min“; 1
M4 um) i
‘ vim-Si. . W, “(-11;
>
> This code will compile and will print to the screen the value 154

***************Ending Page***************

***************Beginning Page***************
***************page number:121**************
b If std::initiali1er_list is used in a Constructor the following expression for
initializing an object can be used:
APP-cup
uslﬂl unable! m;
mum (Mkhnmyw
(his nan
i
1M vim;
Mm:
ha!i(s(d::iniiiilherJhRiM) a)
i
m m1.‘ . a;
m: :mnulmr-Juuum: “mm” n;
m (I! . z-MMO; (u I. “mm u (lMexdﬂ); lumlnﬂex”)
Yuma - (-m:
) ,
);
m4 "mo
(
nan am 1. 1. a. 4. s m
Datidl:(l,1, 3.‘. s);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
Initialization lists
> Let's consider the following code:
APP-cw
‘deﬁne mummim) X
vow Iaan ( W,SilEINHK-(Drllw7('ie5l')i)i )
> This code will work 0k, and the compiler will print “Test” to the screen. Now let's
consider the (allowing one: ‘
APP-cw ‘l
mm»: mynmmlx) x ‘l
valid "mo r w,smmu=(— ); ) ‘l
> In this case the code will riot comﬂile. When analyzing a MACRO the compiler does
not interpret in an! wagrthe “{“ c aracter. This means that irom the compiler
point of view, DO, OM HING macro has received 3 parameters:
> vezturdnt) >41
> 2
> a)

***************Ending Page***************

***************Beginning Page***************
***************page number:123**************
Imtlahzatlon hsts
> In this cases the solution is t0 Change the macro from:
APP-cw
mm“ “Lg-Emma) X
to
APP-cw ‘
mm- no_smiml»6(-) _vums_ ‘a
vuln "m0 ( nwsmm vector-(Int) X“, z, a); >; 2 ‘a
> This code will compile and run correctly “

***************Ending Page***************

***************Beginning Page***************
***************page number:124**************
y my

***************Ending Page***************

