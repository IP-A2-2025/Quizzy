***************Beginning Page***************
***************page number:1**************
00 P X Gavrilut Dragos
Course 2

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
> Pointers and References
> Method overloading
Summary b NULL pointer
> “cunst” speciﬁer
k > "friend" specifier

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
\
Pointers and
> References

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Pomters and References
App-Pointer App-Reference
M1 seumum n1 void smmm m
( (
m1 - s; £ - s;
> )
Wm mm void mm
x x
m! X; m x;
5mm; mm;
> )
App-Pointer (asm - Setlnt) App-Reference (asm - 5mm)
Sen“: Seum:
Wsh a» push m
mu ehmew wv chines?
mv m4m~s1 mv w. leDW]
M mm; mv [w];
M eSmﬁBD M 259mb?
m ehn m m ,
m m

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
P01 nters and References
> The resulted Code is identical (both the “Pointer” and “Reference” program
will link into the same assembler code.
> However, from the programmer point of view, using a relerence fixes some
possible problems (perhaps the most know one is that one does not need to
use the “->“ operator e instead the “4” operator can be used)‘ Another
important one is that a check for NULL pointers is no longer required. r‘
struct m mm om x
1 c a
m x; mt x;
l “ks; l M15;
) )

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Pomters and References ‘
> References and pointers are created in the (allowing manner: I
t
mt w e ht m are“ e 1; ‘
> The difierence is that pointers can remain uninitialized. ‘
m w, m mu,
This forces the programmer to initialize a reference.
lt also guarantees that a reference points t0 a valid memury location.

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Pomters and References
> A pointer value can he changed (that is a pointer can point to diiferent I
memory addresses). A reference can only point to a variable and once it is “
initialize the memory address Where It points l0 can not be Changed.
r
m 1 - 1w, m 1 - 1a, ‘
m1. 1a, m 1 . 1a; i
m ‘p Z a)‘ m "m Z 1;
9:10; yam];
> A pointer can have the value NULL.
A reference can only point to a memory address
that exists.

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Pomters and References
> Pointers accept certain arithmetic operations 1+, - , w, etc). This is not valid I
for references. “
m A - 1e, m A - m; i
m1. 1a, m 1 . 1a; ‘
m ‘a e s1; m arm e a; i
(‘i=7 e an, _ (lufllnr
> In case of pointers, variable “i” and “j” are allocated consecutively on the
Stack‘ The Operation “pH” moves the pointer p from the memory address 0i
the variable “i” to the memory address of the variable "j". At the end of the
execution "j" will have the value 30.

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Pomters and References
> A pointer can be converted to another pointer (cast). In particular any pointer I
can be converted to a void pomter lvoid'). A reference can not be converted “
to another reference‘ r
‘a
m 1 - 1a, m 1 - m: t
ma ~a - (thar “m, ma arm . a; E t
> This thmg guarantees that a reference points to a memory address where a
Certain type 0f variable resides.

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Pomters and References
> A pointer may point to another pointer and so on. This is not possible for I
references s a reference refers only a variable. “
if
m 1 - 1a; m 1 - w; r
m -, . u; w m" . i‘ r
1m ‘Ltoj e iv, m u hwy.“ e "m
"mu e 10; E
> It IS important in this example to differentiate between “a a" (two
references separated with a space 1‘ ‘) character] and “&&" (two consecutive ,7
references).

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Pomters and References ‘
> A pointer can be used in an array and be dynamically initialized. This is not I
possible for references. “
r
> However, a reference may paint w a temporary (or constant) value.
m ~p Z hnclsﬂ), mm m sun Z mum; '
This code will not complle if the
"const" specifier is not used as it
refers tn a constant numerical
value.

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Pomters and References ‘
> A pointer can be used in an array and be dynamically initialized. This is not I
possible for references. “
r
> However, a reference may paint w a temporary (or constant) value.
(em me seen e mtlﬂ), (em m seen e mtln);
Int ~p e (ins ')lrefI,
It is however possible to create a
pointer that points to a
reference of a lempnraly
[constanti value.

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
> Method overloading

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Method overloadmg
> Method overloading i5 a technique used m C“ where one can deﬁne 2 or multiple I
functiuns/metnods wrtn tne same name {or operatorsl. r
> Afrmctrorr / method is uniquety rdentmed by its svgnalure: 1
return>type FunctionName (param1-type, paramZ>type, J r‘
A funnion/method signature is form out of:
1| function name
2| Parameters type In parameters ale present!
> Smce parameters are part of the function signature, multrpte functions/methods
with the same name but drfferent parameters are passipte.
> However, trns does not apply to return type [meaning that funcuons wrth't'ne same
name and parameters but dvfferent return type can not exit).

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
APP-(PP
‘1.55 mu
(
mm:
m ma (m u, m m;
in! Md (1n! v1, in‘ v2, in‘ v37!
in! Add (in! v1, in! v2, in! v3, in! v47:
ﬂan Add (ﬂan v1, ﬂan v2);
);
m mnmladnn! u, m m
(
)
m Mama." n, m v1, m m
(
mm v! ‘ w ‘ v3;
)
1m Muzzmdkim v1, 1m v2, 1m v3, int v4)
(
1
flan mmuuﬂflna v1, flan v27
( ,
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Method overload] ng
> Method overloading is NOT possible if the methods have the same signature
(same name, same parameters)
> In the next case, both methods are named Add and have two parameters of
type in! is The return type (even if in this case is different) will not be
Considered , thus the [W0 Add functions are Consider duplicates l
APP-CPP
(lass mm
r
Publixz ‘
.mrm v1, 1m m; x
lung mum n, m m; ‘a
35-‘ Farmzldﬂllnx u, m m
( mm v1 . m H
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Method overload] ng
> Be careful when you are using parameters with default value‘ From the
compiler point of view, using this ieature does not mean that a (unction has
fewer parameters l
> This code will NOT compile as Add has the same signature 1
APP-Cw
class mt:
t
vun111=
m “aim v1, m n e
Jan! “aim a,‘ \
1;“ Muzzmdlim v1, 1m v2)
in". mnumnim v1, m m
( mu". n . n; l
)— '

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Method overload] ng
> Another special case are methods with van'adic parameters (“m”). However,
they are not recommended in case of method overloading as the
interpretation can be misleading.
APP-WP
class m»
t
vun11¢=
m mu“ vi, m m;
m. mu“ “437; l
gin Muzzmdlim v1, 1m v2)
L". Wilma“ a, ".7
( mu". n; x
)— '

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Method overloading
> When a function/method that was overloaded is called, the compiler
determines which one oi the existing definiens of that function/method it E
should use. This process is called overload resolution 1‘
> It is possible that the result of this process will be inconclusive (erg. r the
compiler can not decide the best fit for a specific name)‘ In this case a
compiler error will be raised, and the ambiguity will be explained‘

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Method overloadmg

Overload resoluﬂon steps: ‘I

1v Check if an exact match is possible (a method exists with the same name and at‘
the exact same parameters type) ‘1
void Computeﬁnt X, dnuble y, char z} “1
Called Compute1100, 15, ‘A‘) ‘1

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
Method overload] ng
Overload resoluﬂon steps:
2' Check if a numerical promotion is possible (convert a type into another one
without loosing precision and the value).
v bool, char, short, unsigned char and unsigned snon can be promoted to in int
v flea! can be promoted to double
v Any enumeration (enum) without an explicit type can be convened to int
void Computeﬁnt x, double y, char z) \
Called Compute(true, 1.5f, ‘A‘) l‘
Promotion Computeﬂ, 1.5, W) \
\
true is promoted to in: value 111
1le [a float value] is promoted to double value 145

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Method overloading
Overload resolullon steps:
3' Check if a numerical conversion is possible (convert a type into another one
with the possibility of loosing the actual value / precision).
void Compute(int x, double y, char z)
Called Compute(345, 1.5, ‘A’)
Conversion Compute(3, 1.5, ‘A')
l
l
3.5 (a double value) will he converted to in! value 3 ‘\
(loosing precision) l
lt is possible that the conversion may apply to several overloaded methods. ll l
this is a case, an ambiguity error will be thrown, and the program will not
compile

***************Ending Page***************


***************Beginning Page***************
***************page number:23**************
Method overload] ng
Overload resoluﬂon steps:
4' Casts are attempted:
¢ Every non-const pointer can be casted m ixs cons! pointer form
, Every non-const pointer can be casted m void ‘ or canst void ~
¢ Every canst painter can be casted to canst void *
¢ NULL macro (deﬁne) can be Converted t0 numerical value 0
void Computeﬁnt x, const void‘ y, char 1) \
Called Compute(NULL, “C++“, ‘A‘) ‘\‘
Cast Compute“), (const void‘)"£++”, 'A’) l
\
NULL i5 Converted w in! value U
“C++H (a const char " pomterj IS cast to const void "

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Method overloading
Overload resoluﬂon steps:
5' Explicit casts (if any) are applied, We will discuss more on this topic when we
will study inheritance and CH operators. ‘1
s, If none or these attempts result in finding a match - a fallback method /
function (if any) is used. A fallback method is a method that only has van'adic ‘1
parameters
k 7v If there isn't such a method , the compiler will produce an error.

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
Method overloading
> 100 is considered an “int” type value‘ Since there i5 a method by the name
Inc that has a parameter 0f type “int”, the Compiler will use that method.
b In this case we have an exact-match situation.
APP-CPP
class Hath
4
wm“
in! !n((1n( va,
float In((f)ua( v1),
<
return v1 . 1,
>
(Juan Hath 1n¢<¢1u=t v1)
‘ r=turn v1.1.ut.
i
void ma1"()
{ ,
~=g~ m,
m.In((lﬂﬂ)|
’—

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Method overloading
> 1.0f is a “ﬂoat” vatue. Since there is a method by the name Inc that has a
parameter 0i type "flout", the compiler will use that method.
b In this case we have an exact-match situation.
APP-CPP
class Hath
4
wm“
1n< 1nt<1n< v17»
float Ih((f)ua( v1),
<
return v1 . 1,
>
final Hath 1n¢<¢1u=t v1)
‘ r=turn v1.1.u¢.
i
void ml1h()
{ ,
~=g~ m,
m.Ih((1.Hf)-
’—

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
Method overloadmg
> ‘a’ is a “char” type value. As there ts no method With the name Inc that has
one parameter 0i type "char", the compiler promotes the char value t0 int
eh uses the In: methed with ehe parameter er type “iht" .
APP-CPP
class Hath
4
wm“
in! !n((1n( v17,
(10a! tht<¢1tet v1),
<
return v1 . 1,
>
final Hath tttttteet v1)
‘ return v1.1.et.
r
void ml1"()
{ ,
Neth m,
hmqeu.
’—

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Method overloading
> ‘a’ is a “char” type value. As there i5 no method With the name Inc that has
one parameter 0i type "char", the compiler promotes the char value t0 int
and tries again. Since there is he Inc method that has an int parameter (but
there are two Inc methods, an ambiguity case will be declared, and the code
will not compile. Event if, a char can iully be Converted (without any value
lost] into a short , promotion only works for int and double types.
APPIPP
(less Mith
l
vohiit
,rt Inclshur: v1)’
float In((fluat v1).
{ return r, . 1,
>
rrrrr Mith 1rrrr1rrr v17
( return v1t1.uf,
t
vuzd hrrh<>
l
Halh r.
rude»,
t

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
Method overloading r

> If during the promotion phase the compiler DOES NOT find any possible l‘
promotion, but there are at least two methods/functions with the same name ‘a
as the one attempted to be promoted the compiler will throw an error (this ‘I
will be considered to be an ambiguity case). Having at least two methods with E
the same name is an indicator that method overloading is desired and another 3
overload (or the speciﬁc call is required, I

> However, if the promotion fails and there only ONE method with that name, a
conversion is attempted (in this case it is considered that method overloading
was not something desired by the programmer and the compiler attempts to
match the parameters even if this means losing precision / value)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Method overloading
> 1.0 IS a double value. As there is not any Inc method that receives a double
parameter, promotion ls attempted. Uniortunately e can not be promoted
(WithOUl loosing value] w either int or flout.
> Since there are two In: function, this code will not compile, and an ambiguity
C389 will be ex-lained as an error.
APPIPP
(1i§§ MiKh
i
Public
,"g Inellng v‘),
float InKlfluat v17.
‘ re=urn v, . 1,
>
r1ui< MaKh Inllfloil v17
( return v1l1.uf,
l
void maln<v
i
ni<~ m,
mMﬂLM’
l

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
In thvs case, 1'0 is a double value, and as there is no Inc function that has one
parameter 0f type double, promotvon vs attempted. Unfortunately. double
can not bc converted to char wwhout Loosing prcusion.
However, as there vs only ONE funcnon \nc, the compvler wvlt convert double
w char 1even 1v thvs means tosmg precvslonte This code Wm (Qmpvle wvth
warnmgs.
(lass HaKh
(
Pubh:
,"r Ineirhar v11 t
rernrrv v1 t 1.
>
>,
<
Ham m.
i
)

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
In thvs case, 1'0 is a double value, and as there is no Inc function that has one
parameter 0f type double, promotvon vs attempted. Unfortunately. double
can not bc convcrtcd to char wrthout Loosing prccrsion.
However, as there vs only ONE functuon \nc, the compvler wvlt try to convert
double to char '. As this vs not possvbte {only conversions numerical
conversvons are possible) the compiler Wm produce an error and the code will
not Compile.
(1,55 len
<
Mr"
ant Int(<har‘ v17 r return r. >
35m “1va
<
Mar» m
r
error C2664: 'int Mathitlnqchav "b':
cannot convert argument 1 (rom
‘double' to ‘char "

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
Method overloading
> Pointer conversions are also impossible. “&d" is a “double "" that can not be
converted to “char ‘”.
b This code wili produce a compiler error.
APPIPP
(less Mith
r
Public
,"g 1"‘4‘~,r~ v1),
3;‘ m mm.» m
r
return 1,
r
vulq maln<r
r
,
mrxn‘ aa ,
)
error C2664: ‘int Mathxlncichar *)‘:
cannot convert argument 1 from
'duuble "' to ‘char *' "

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Method overload] ng
> Pointer conversions are also impossible. “Gd” is a “double '” that can not be
converted to “char "K
> However, using an explicit cast will solve this problem‘ In this case, the code
will compiles
APMPP
ms; Math
t
puhiicz
Ant Inﬁlthir~ v17: ‘
1;! mum"- m ‘a
‘ m a; a
) a
W14 miilll)
Huh m; i
mm l . ..
) ml *7:

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
Method overload] ng
> However, any non-constant pointer can be converted to “void "K The next
example will compile.
> A constant pointer can not he converted to a non-constant pointer implicitly
(without a cast), A non'constant pointer can always be converted to its
Constant equivalence, That is why, if you don't need t0 modify the value
where the pointer points, it is best to use const pointers for method/function
parameters‘
APP-Cup ‘
class Hi"! ‘a
i ‘x
mm; z
m mm“- m; ‘a
‘ mm a; ‘
) ,
vain mainll
( v
anm;
i

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Method overloadlng
> Methods with variadic parameters: ‘K
rs Fallback methods -> methods with only one parameter that is variadic (with a ‘l
signature in the iorrn <name> (m), These methods are the last to be used (only if ‘r
there is no possiole conversion, cast or promotion or if there is no ambiguity in a
terms or promotion/conversion. These functions are not allowed in c language. l
z‘ Regular methods -> methods that have et least one parameter that is not variadic
and ONE variadic parameter (esgs <norne>(inz,..,) or <norne>(ohar,short,...) )4
These methods are used just like the regular methods and the sarne rules apply to
them as Well.

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Method overloadmg
> In case of methods with variadic parameters the compiler will use the best fit
(in terms 01 exact parameters), This code compiles and the method Inc(int) is
used.

APP-CPP

(lass mm

r

Public:
m mam m;
in! In((---);

1?.‘ mmmum m

t Mm v1 . 1;

)

m run-numb»)

(
mum a;

)

“51¢ m-1nza

( ~ '
mm

)

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Method overloadmg
> In this case, as there is no Inc method that has a parameter of type char, the
compiler promotes ‘a‘ (char value 97) to int and uses the Inc(int) method.

APP-CPP

(lass mm

(

Public:
m mam m;
in! In((---);

1?.‘ muzzlnﬁint m

t mm v1 . 1;

)

m mmmt»:

(
mum a;

)

“51¢ m-1»<>

( ~ '
mm!

)

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
Method overloadmg
> 1.0 IS a double value. We can not apply numerical promotion to int to use
Incﬂ'nt) method. However, we can Convert the double to an int (with possible
loss uf value) and then use In£(inl) method. The code compiles. The fallback
function is used onl if no “emotion/conversion is -ossv'ble.
APP-CPP
class Halh
l
wm“
in! 1"(<1"< v17,
m ml u,
n
,"t Kath 1n<llnt v1)
l
r=<lrn v1 . 1,
>
“(mm mdud
l
r:turn 1.
l
void mllﬂl)
l; '
~=g~ m,
mthm.
’——

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Tm 15 an ambvguous case. There ‘5 no promohon possvble. However, the
double value 1,0 can be converted w both int land use Inc(int) method, or
flout and use Inz(flou£) mcihodr As thcrc arc two posmbvlmcs, ms code vs
consudered ambiguous and an error vs thrown.
‘JASS Malh
(
Pubhr
vvr Mm m‘
m “(mm v1),
ml m >,
w.
‘WK HRK» v",(vn( v1)
<
mun" v) ‘ 1,
>
,n‘ Math Ink4¢‘ua‘ v1)
<
rernm v1 ‘ 1‘
)
f" M‘ M‘ > error czssx: 'Math::Inc': ambiguous call to ovzrloaded function
mm 1. note: could he '1'.‘ Math::In((Float)'
> note: ar- mn Math::1nc(int)'
vow mmo ( note: wmla trying m match the argument 1m '(mwmy
>—

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
Method overloading
> In this case the parameter used is a const char ' 1a pointer)‘ There is no
promotion and no conversion possible. Thus, the compiler must use the
fallback method Ind...)
APP-CPP
(his mm
r
Public:
m mum m;
in! In((---);
1?.‘ muzzlnﬁtnt m
t mm v1 . 1;
)
m mmnanL»)
(
mum a;
)
void m-1»<>
( ~ '
)——

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Method overloadmg
> A similar case —> there is no method overloaded with Z parameters, so the
compiler uses the fallback method Ind“)

APP-CPP

(‘I55 mm

(

vun11=1
m mam m;
in! In((---);

1;‘ muzzlnslim m

t Mm v1 . 1;

)

m mnmlnzb»)

(
mum a;

)

“51¢ mliﬂll

L I

mm

)

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
> This ‘s an ambiguous case. 123 is an in! value and there are two methods that
match exactly with the call Inc(123| 1 Inc(1'nt) and Incﬁntw). The Code will
NOT compile.
APP-CPP
(lass Hath
4
Pubhz
1"‘ !n((1n( v17,
m IntUnz v1, x,
v,
,"t Hath 1n<4,nt v1)
<
rQKMr" v1 . 1,
L‘ Hm m4,“ W“) warning c4325: return type 0f ‘main’ 5mm he 'int' instead of ‘mm
‘ error- c2555: ‘Math::1nc': ambiguous (all tn overloaded funtlinn
"m" 1. note: could be ‘int Mathnlnqintpu)‘
in“ mm ﬂute: or ‘int Mith::IM(inU'
‘ mm: whﬂe mung m match the argument 115x ‘(inc)’
>< h m
)——

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Thvs 15 an ambvguous case. true vs a bDDl value and We dorﬂ have an exact
method m match Inc(bool), m ths case numervcal prnmouon vs apply, boo! vs
promoted to int and now wc have two mcihods that match: Inc(int) and
In: int ) The code WM NOT com Zvle.
‘JASS Malh
(
Pubhr
vvr Mm m‘
m mu“ v1, >,
>,
,n‘ Math Ink4xn‘ v1)
<
rernm v1 ‘ 1‘
)
M M, WM v1, >
( mm 1 errar c2555: ‘Math: mm: ambiguous cal] to overloaded function
> ' note: could be ‘int Math::In:(in(..U)'
void m-UWO note: or‘ 'm Math::In:(int)'
< M m nottz while vying to mam‘ m argument 1m ‘(booll'
)—

***************Ending Page***************


***************Beginning Page***************
***************page number:45**************
Method overloading
> This code wilt NOT compile. None of the methods Inc(int) and Inqintw)
matches the cons! char “ parameter and there i5 r10 fallback method.
APP-CPP
(lass Hath
4
Mm
in! !n((1n( vii,
in! IMUHK v1, u,
v,
ins Hath instins v1)
<
return v1 . i,
>
An! Hath instint V1,...)
t r t m 1 error c2554: ‘in! Math::1nc(int,...)‘: (alum! convert
} H ' argument 1 from ‘cans! min [51' tn ‘inr
void maleU note: There is no context in which this conversion is
r possibls
>4 n n
)——

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Method overloadmg
> This code will compile‘ ‘a’ (char) is promoted to int and since there is only
one method that accepts two parameters, the compiler will use it‘
APP-CPP
(lass mm
r
Public:
m mam m;
m 1mm ‘aw-1;
1?.‘ muzzlnslim m
t Mm v1 . 1;
)
m mnmnqm up»:
( mum a;
)
void m.1»<>
( ~ '
)——

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
Method overloading
> This code will compile. ‘a’ lchar) is promoted to int and since there is only
one method that accepts two parameters, the compiler will use it.
b Fallback methods llnc(...)) are used only if nu match is possible.
APP-CPP
class Hath
l
wmu
in! lnilin! v17,
m IntUn! v1, i,
An! Intl...)’
lél Kath In€(1nt v1) l
TQKMTH V1 . 1,
int Hath Inﬁll"! v1,...) l
return 1,
>
mzmm MG“J(
rQKMrn z,
\::::l:__ I
val, malnl>
l
MiKh m.
m 1"(<‘.',<rlt>,
l

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Method overloading
> This code will compile. However, in this case there is no match possible from
Inc(corist char ', boo!) (including promotions and conversions] to the existing
methods Inc(int) and lrlC(ir|t,...). However, as a fallback function is also
available the com-iler will choose to use ill
APP-CPP
class Halh
l
wmu
in! !n((1n( vii,
m mu“ v1, i,
An! Intl...),
lél Kath I"€(1Ht v1) l
r=<irn v1 . 1,
In‘ Halh Intlinl V1,...) i
return 1,
>
mzmm MG“J(
ii<iin z,
l::::i:__ I
onli m,i»l>
l
MIKh m,
m Inll~<i§<i,<iii>,
l

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
Method overloading
> When dealing with overloaded methods with multiple parameters, promotion and ‘1
conversion rules are evaluated for each parameten ‘1
> Overload resolution will choose the combination of promotion/conversions that
covers highest number of unique parameters. r‘
> If there are at least two solutions that have at least one different parameter that
each one of the solution can cover {match l promote or convert) an ambiguous
case is considered and an error will be thrown,
> If nothing matches, a promotion is considered stronger than a conversions , and
can be used to resolve overload resolution lin fact a promotion is sometimes
considered equal as importance with an exact match)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
Method overloading
> This code wilt compile. There iS an exact match (a function Add with two
parametersv ﬁrst of type char and the second of type int).
APP-CPP
class Hath
4
wm“
void Add((har x, in! yr,
vain Add(1n( x, tn.’ y),
< pr1n<r<“iddrtnir,1n<>“i,
amid Hath ldﬂ(1n( X, char y)
‘ pr,nt§<“n¢¢<1~t.‘»ar>“>.
acid ml!"()
{ ,
m.Ad¢('a‘,lﬂﬂ)-
i________________________________________________

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
Method overloadmg
> This code compiles‘ The compiles promotes the second parameter from boo!
to int and uses Addfcharﬁnt)
APP-CPP
(his mm
r
public:
vuid mm." x, m y);
was Minn! x. (m y);
3;“ muzzuﬂcnar X, 1m n
t mmwmtcmdmm:
3,“ nan-1:14am“ X, (m y,
( printﬂ“lddlim,chir)“);
3m mu ,
‘ .
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
Tm 15 an ambvguous case as we have two possvbvhtves:
100 7 in! _ we com/m 200mm to char and MC Addlinl,:har)
100mm vs converted (0 than ZOO \S Lonsvdeved an in! and we use Add(:hcr,int)
‘JASS Malh
(
Pubhr
vm mum X‘ m y»
wm mu“ X, chm‘ y),
>,
v0,“ Math Adazkhar X, ,nx v)
<
Wm“ mamamm >‘
)
vuld Malh add<‘nl X, ("Ar y)
( error czsss: ‘Mathzmdd': z overloads have similar conversions
> WW“ “““"""'"”1 1' note: could he ‘void Macm=Add(1m,<har)'
Wm who notn: nr ‘void Math::Add(char,int)'
< note: while trying m match the argument 1m ‘on, int)‘
>

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
> This code compiles‘ We also have two possibilities, but the ﬁrst one is better:
a 100 = int, 1.5 IS convened w char and We use Addlintxha!) [ one conversmn i one exact
match]
b iOU um i5 converted w chm, i.5 m int and we use Add(char,int) [ two (BHVE'VSIDHS1
APP-CPP
class Hath
4
Publzt
void Add((hir x, 1"‘ yv,
void Add(1n( x, (her y),
n
vu,¢ Hath Addiehar X, ,"e y)
<
Pr1n(‘(“ldd((hir,1ni7“7»
)
void Hath ldﬂ(1n( X, char y)
4
Print‘(“kdd(lnt,(hir)“)|
) ,
void ml1"()
i
m.Ad¢(1HH,1.5).
J.____________________________________________________________________

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
> This code compiles‘ We also have three possibilities: I
a ‘a’ = char lexact midi)‘ 1.5 (a double IS converted 10 inn and 2.51a duuble l5 converted to ‘
inn -) 1 x exact iiimn, 2 x cunversiun i
D '2' l mi IS prumulsd to inn, i513 double l5 (unvaried tn [nail and 1.5 (a duublé IS 1
converted to inn -) 1 x promotion, z x conversion ‘
t. ‘a’ l Ola! IS converted [0 (loan, i.5 (a double IS convened {D bonl) and 2.5 (a double IS ‘
convened w "\l) -) 3 x conversion ‘
> Sulutiun a) has an exact match and since there is no other solutions that can I
match another -arameter than the first one this Will be selected.
APP-(PP
class ~==n
l
Pub11(
m mun-i ii, m y, m I) i mm 1, i
m “nun: x, (m y, m 2i i mm z, i
m mm“: X, m1 y, m 1) 4 ism» 3i i I,
void mi1"(7
i
Main m
in‘ X Z n.l¢¢<‘=‘, 1.5, z.s>i
l

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
> This code will NOT compile. We also have three possibvlities:
a ‘a’ = char lexacl match), v.51 la noel vs convened l0 vnu and 2's la double vs converted l0
mll -) 1 x exact match, 2 x cunversiun
n ‘2' v char vs promoted In mt], v.5! (a (lozl vs eenverled Lu cnerv and 2.512 ceume vs converted
m vnn -) 1 x promoﬂan, 1 x converslon
e ‘a’ = char levacl vnevcrvv, v.5! la (loan vs convened m bcolv and 1.51a double vs convened m
vnll -) 1 x exact match, 2 x conversion
> Since both solutions a) and cl have an exact match for the w parameter, this
will be consv'dered an ambi-uit case.
APP-(PP
‘lass Kath
l /
publir
m mum x, m v, m z) v "(urn 1, >
m ma m v m, y, m 2v r mm Z, v A
1n: A¢¢_ bun) y, m 1) 4 rem» 3, >
>, error (255:: ‘Metlvzmmf: Imblﬂuuui (Ill m overloaded functiun
ma vvnnvv note: could h: v1" Hath::Addlmanboullinll'
l note: or ‘m Hathzlddlzhanxnhinl)‘
ante: Hme trying m nutdv the argument 115! rem, Float. mm)
r

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
> This code wilt NOT compile. We also have three possitnlities:
a ‘a’ = char1e><act match), ‘a’ 1a char 15 promoted to mu and 1 51a double vs converted to mu -)
1 x exact match, 1 x wrwersiun, 1 x prunwtion
b ‘2'1charls promoted to mt], '2' : (har (met match] m 2.5 12 doubts 1; (unvaried to mt] -)
1 x exact match. 1 x conversion. 1 x promotion
t ‘a’ = char1exactmatchlr‘a'ia char vs converted to bnol) and 2.51a double vs converted to mu
-) 1 x exact match, z x conversion
> Solution a) and c) have an exa(t match for trre 1SK parameter (but not for the
second one). Solut1'0r1 bl has an exact match {or the 2"“ parameter (but not for
the ﬁrst one). This ls Considered an ambiguity.
APMPP
(lass nit»
1
Publjt
mt “new X, mt y, mt I) 1 rem" 1, 1 ,
1n: 1¢¢<1~t X. ‘har y. Int z) 1 return 1‘ >
W “'“m' “I “"1 Yr W 17 < "m" i» > errm (25613: ‘mm :Add‘: 1 overlaids Have 5mm (“Mme-15
3;“ mm note: can!!! he ‘1" Math:tnddrrhambaairinn'
1 note: or 1M nittr==murrt.<tar,ir.t>
_ _ “ "01c: n! a" Hath::Add(thar31n!.mt)‘
note; Mule \rymg to mite» the argument 1m ‘(sham chin Gamble)‘
)

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
Method overloading
> Let's consider the ioliowing code:
APMPP
Strut! H11»
‘ tn! r¢¢<tn=r X‘ tn! yr tn! z) 4 return 1; >
t"! Add(douhlc X, t": y, t"! z) t r=1~r~ 2, >
in! Add(chzr X, boo) y, (“In 1) r Illurn s, >
>;
> and Let's consider that we cail MathzzAdd with the ioliowmg parameters:
Math r"; moAddi1.5, true, 1.5)
I_ X (doubler Y WWI) 1 (doublw
1. Add (char x, int y, int z) conversion promotion conversion
Z. Add (double x, int y, int z) exact match promotion conversion
3, Add (char x, boo! y, char z) conversion exact match conversion '
> Solution 1 [has an exact match (or the ﬁrst parameter], Solution Z has an exact
match for the second parameter -)

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
Method overloading
> Let's consider the iollowing code:
APMPP
Strut! H11»
‘ tn! r¢¢<tn=r X‘ tn! yr tn! z) l return 1; >
1n! Add(douhlc X, 1n! y, 1n! z) l r=1~r~ 2, >
in! Add(cnzr X, boo! y, (“In 1) r Illurn s, >
>;
> and let's consider that we call MatnzzAdd with the iollowrng parameters:
Math nl; rn.Add(ialse, true, 145)
I_ X (Ml) Y WWI) 1 (doublet
1. Add (char x, int y, int z) conversion promotion conversion
Z. Add (double x, int y, int z) conversion promotion conversion
3, Add (char x, boo! y, char z) conversion exact match conversion '
> One Solution that has a match (SDlUUDﬂ 3). There is no promotion or exact
match for “X” or “Z” in solution 1 or 2 -) code Will compile

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
Method overloading
> Let's consider the ioliowing code:
APMPP
Strut! H11»
‘ tn! r¢¢<tn=r X‘ tn! yr tn! z) 4 return 1; >
t"! Add(douhlc X, t": y, t"! z) t r=1~r~ 2, >
in! Add(chzr X, boo) y, (“In 1) r Illurn s, >
>;
> and Let's consider that we cail MathzzAdd with the ioliowmg parameters:
Math r"; moAddi1.5, true, 1.5)
I_ X (doubler Y WWI) 1 (doublw
1. Add (char x, int y, int z) conversion promotion conversion
Z. Add (double x, int y, int z) exact match promotion conversion
3, Add (char x, boo! y, char z) conversion exact match conversion '
> Solution 1 [has an exact match (or the ﬁrst parameter], Solution Z has an exact
match for the second parameter -)

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
Method overloading
> Let's consider the iollowing code:
APMPP
Strut! n11»
l tut Ann<tnar Xi tut yr tut z) l return 1; >
1n! Add(dounln X, 1n! y, 1n! 1) t r=1~r~ 2, >
in! Add(chzr X, boo) y, char 1) r Illurn s, >
>;
> and let's consider that we call MatnzzAdd with the iollowmg parameters:
Math m;m.Add(‘a',true,1.5)
I_—Y1h°°l> 1 (doublet
1. Add (char x, int y, int z) exact match promotion conversion
Z. Add (double x, int y, int z) conversion promotion conversion
3, Add (char x, boo! y, char z) exact match exact match conversion '
> Solution 3 has two exact matches lior X and V), Solution 1 has one match (just
for X). As solution 3 covers solution 1, and solution 2 does not have apromotion
or exact match (or “Z”, code Will compile and solution 3 will be Selected

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
Method overloading
> Let's consider the (allowing code:
APMPP
strut! mm
( int Add(char Xi int yr int 17 t Flturn 1; >
Ln! Add1dounl: X, Ln! y, Ln! z) r 'ttu.“ 2; >
1n! Add1char x, haul y, tn.’ z) r return z; >
r;
> and Let's consider that we call Math::Add with the (allowing parameters:
Math m; m.Add(‘a’, true, 100)
I_— v (bool)
1. Add (char x, int y, int z) cxaat matcr promotion cm: waxh
2‘ Add (double x, int y, intz) conversion promotion am; VQZJi
3. Add (char x, baoi y, char z) watt Hmtti' 0m; moth conversion '
> Solution 3 matches parameters 1 and Z, solution 1 matches parameters 1 and 3
(there is no clear solution) -) ambiguity case

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Method overloading
> Let's consider the iollowing code:
APMPP
Strut! a)!»
‘ tn! naa<tn=r X‘ tn! yr tn! z) l return 1; >
t"! Add(douhle X, t": y, t"! z) t return 2, >
in! Add(chzr X, boo) y, than 1) t Illurn 3, >
>;
> and let's consider that we call MathzzAdd with the iollowmg parameters:
Math m; m.Add(l.5, true, ‘a’]
I_ X (doubler Y WWI)
1. Add (char x, int y, int z) conversion promotion promotion
Z. Add (double x, int y, int z) exact match promotion promotion
3, Add (char x, boo! y, char z) conversion exact match exact match '
> Solution 3 matches parameters Z parameters (V and Z) but not parameter “X'Z
Since there is also a solution that could match parameter "X" (solution'll this
will be considered an .

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
Method overloading
> Let's consider the ioliowing code:
APMPP
Strut! H11»
‘ ins Add(cnir Xi ins yr ins z) 4 return 1; >
1n! Add(douhle X, 1n! y, 1n! z) i r=1~r~ 2, >
in! Add(chzr X, boo) y, (“In 1) r Illurn s, >
>;
> and Let's consider that we cail MatnzzAdd with the ioliowmg parameters:
Math "l;rn.Add(100,1,5,145)
I_— v wow» z (doubler
1. Add (char x, int y, int z) conversion conversion conversion
Z. Add (double x, int y, int z) conversion conversion conversion
3, Add (char x, boo! y, char z) conversion conversion conversion '
> N0 cases with exact match, all suiutiuns have 3 Conversions -)

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
Method overloading
> Let's consider the iollowing code:
APMPP
Strut! H11»
‘ int r¢¢<tn=r Xi int yr int z) l return 1; >
1n! Add(douhle X, 1n! y, 1n! 11 l r=1~r~ 2, >
in! Add((hzr X, boo) y, (“In 1) t return s, >
>;
> and let's consider that we call MathzzAdd with the iollowmg parameters:
Math m;m.Add(140f,1.5,1.5)
I_X<ﬂw> “doubler who
1. Add (char x, int y, int z) conversion conversion conversion
Z. Add (double x, int y, int z) promotion conversion conversion
3, Add (char x, boo! y, char z) conversion conversion conversion '
> No cases with exact match, however there IS one case that has an accepted
promotion while the rest only have conversions. No promotion/exact,match for
"Y" and "Z" for Solution 1 and 3. Solution 2 is selected and code compiles.

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
Method overloading
> Let's change the previous definitions a little bit:
APMPP
Strut! Hzlh
l int l¢¢<tn=r Xi int yt int z) l return 1; >
1n! Add(douhl: X, 1n! y, 1n! zi l return 2, >
in! Add(chzr X, boo! y, double 11 r return s, >
>;
> and let's consider that we call MatnzzAdd with the iollowmg parameters:
Math iii; m,Add(1.0f, 145, 1.0ij
I_ X (ﬂoat) Y idoublw 1mm,
LMWManWn mmm mmmncwmm
Z. Add (double x, int y, int z) promotion conversion conversion
3, Add (char x, boo! y, double z) conversion conversion promotion '
> Solution Z is valid ior "X" (due to promotion), Solution 3 is valid for “Z” [due to
promotion). -)

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Method overloading
> Let's change the previous definitions a little bit:
APMPP
Strut! Ms!»
‘ int r¢¢<tn=r Xi int vi int z) i return 1; >
1n! Add(douhle X, 1n! y, 1n! zi l return 2, >
in! Add(cnzn X, boo! y, double 11 r return s, >
>;
> and Let's consider that we call MatnzzAdd with the ioliowmg parameters:
Math m;m.Add(14Uf,1.5,1.5)
I_ X ("can v (double 1 (doubler
1. Add (char x, int y, int z) conversion conversion conversion
Z. Add (double x, int y, int z) promotion conversion conversion
3, Add (char x, boo! y, double z) conversion conversion exact match '
> This is a case Where promotion and exact match are Seeii as equals. Solution Z
is valid for “X” (due to promotion), Solution 3 is vaiid for “Z” {due toexact
match]. -)

***************Ending Page***************


***************Beginning Page***************
***************page number:67**************
Method overloading
> Let's change the previous definitions a little bit:
APMPP
Strut! is!“
l int l¢¢<tn=r Xi int yr int z) l return 1; >
1n! Add(duuhle X, 1n! y, 1n! zl t return 2, >
in! Add((hzr X, has) y, double 11 r return s, >
>;
> and let's consider that we call MathzzAdd with the iollowmg parameters:
Math rn;rn.Add(1.0i,1.5,100]
I_ X ("can Y double
1. Add (char x, int y, int z) conversion conversion exact match
Z. Add (double x, int y, int z) promotion conversion exact match
3, Add (char x, boo! y, double z) conversion conversion conversion '
> Solution Z Covers “X” (due to promotion] and “ZH [due t0 exact match!‘ There
is no other solution better , or one that can cover "Y" -) Solution Zyisyselected
and the code compiles.

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Method overloading

> When dealing with the const keyword there are also some dilferences in

terms of method overloading and overload resolution ‘3

> For numerical types (types that are transmitted to a method by value) const

is ignored from the method / function signature
I > For pointers and references, const is used in the method / Iunction signature.

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
Method overloading
> This case will NOT compile r but not due to a ambiguity problem, but rather
to the (act that both Inc(int) and Inc(corvst int] are considered to have the
Same Signature: Inc(int)
APP-CPP
class Hath
4
Pubhz
in! !n((1n( x7 < rQKMrn X . 2, >
i,
vu,e m.,r4>
<
he» m, i
314;?’ error- c2535: ‘int Math::Iric(irit)': member function already defined ur- declared
i note: See eemreue" of ‘Math::Inc'

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
Method overloadmg
> In this case , the two Inc methods are considered to have a derrent
signature and therefor are used in the overload resolution. As “&d" \s an int ‘
\heh \he best malch ( mearwvg Im:(inf 7 will be eheseh). The code compHeS.
APP-CPP
class Hath
4
Wm“
1ht thttrht ~ r7
<
rttrrr ~t . z,
t
1ht 1ht<trh§t 1ht ~ r7
ii‘ (
rttrrr ~t . 1,
t
h
void he1h<>
< ,
Hath h.
trt t e ‘a,
h.:h<<tr>.
) ,

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
Method overloadmg
> Similarly, if we change “x” local variable from main function to be a constant,
the second function Inc(const int *) will be chosen as a perfect match.
APP-CPP
class "=1"
l
Fuhlxs:
1"! XnKlln! ~ x7
(
Illurn -l . z;
l
Iliiiilillll
(
Illurn -l . 1;
n
void mainll
l ‘ ,
vanK(lx)|
) ,

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
Method overloadmg ‘
> The same logic applies for references as welL ‘
APMPP APMPP ‘
(his mm <1.“ mm
( ( \
Public: nub * - ‘
m mam l x) m "mm l x) ‘
) >
m mum‘ m |. x) m lmknnxt mt l n
( rum-n X . 1; ( Mum X ‘ 1;
>
n n
void mm) vuld "mo
"
Mum); moo;
)— ’—,

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
Method overloading ‘
> The same logic applies ior references as welL
> In particular, when dealing with constant numerical values they will always be ‘
translated into a consl reference.
APP-CPP
ch55 Mn
t
puhiizz
1m mum u x7
t Mm X . 2;
)
1m Intlsnnst 1m u n
t return x . 1;
)
);
i=1: mainll
W

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
Method overloadmg
> In this case the code will not compile as a constant (constl value CAN NOT be
converted t0 i non'constant value.
APP-CPP
(1.§§ Hath
l
Public
l": 1n<llnt l x)
l
r¢<lrn K . 2,
>
n
val, m=lnl>
l
Milh m,
m Intliﬂﬂ)»
‘kl ,

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
Method overload] ng
> The rest of the promotion / conversion rules apply‘
> In this example, ‘a’ is of type char. As there is no Inc method that reoeives a
char parameier, ‘a’ will be convened m an int and then to a cons! int 6. This
code will compile.
APP-CPD
a»: m»
(
vun11¢1
m mum l x)
( rliﬂrﬂ x ~ z; l
> x
m Xntlzuns! m l x) ‘E
( mm x ~ a; a: ,
w“ mm
( n m~
m

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
l NULL pointer

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
NULL pomter p
> Let's consider the followin code: I
APP-cw 1
vnd Prmtﬂnt valul)
( Prlmﬂ'M-her: MVI', value); t
an“ Prlmkonst mar‘ text) t
( prmtﬂ'Ym: Xnn', tut);
)
vow IainO
( Drintﬂﬁ);
vumt'cw use);
PrintOlll-L); ,
> The code compiles correctly. What is the output of this code Z

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
NULL pointer
> Let's consider the IolLowin- code:
APP-CPD
void mum“ mm
( vmmﬂ'mmh»: mm’, mm;
>
void anwnn cm‘ an»
( Drum-mu amn‘, text);
>
W, “w
( a , Number: 1U
mm?“ ,5 . , Text: CH zest
mm CM U/' Number: n
anmu»; ,
)—
> Why the Last call of Print funcuon is considered to be a number?

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
N U LL p01 n te r
> Let's consider the iollowin. code:
APP-cup
vnln "mm mm
‘ ﬁrm-“w: 1mm‘, um);
3m Wham“ m»- m»
‘ WWW: -' -- \
r Mfdelicplnsplus \
Mn “ho “Genuine nun o \\
( Prlntﬂh); Mean: NULL {(vuld no} \
"um-t” - ilendif \
"mm i ilendif
} i
> Why the last call of Pn'nt function is considered to be a number Z

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
N U LL poi n te r
> So , NULL is defined as a numben While during promotion, value O can be
translated into a NULL pointer, there are often cases (similar to previous one)
where the intended parameter is a pointer [ a NULL pointer l and not a
number
> The solution was to create a new constant (keyword) that relers only to null
pointers. This constant is called nullptr i‘
APP-cw l
mu "mm mu) l L > l
“w Vrlnﬂconst char‘ um ( 7 ) l
vnld "no
i mam-n
> In the previous example, the compiler will now call “Print(cunst char')"
function‘

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
N U LL p01 nter
> The following assignments are valid mi NULL cunstarll and all variable will be
set to o false or a null ol'nter.
APP-CPP
van! mull)
4
in X a nlll;
m, y a lull;
vim v . null;
baa. a a mill.
“m ‘mi a a Will
in v l a nlll;
)—
> The following assignments are invalid (code will NOT compile):
APP~CPP ,
vain mainl)
(
m X a "law;
an» y a "an";
am f . "aim;
l

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
N U LL p01 nter
> The following assignments are valid and the code will compile.
APMPP
Vela mainl)
l
haul n e nullvl';
(ans! (hav' D e nullitrr
in! . 1 - nullvlr;
l_________________________________________________
> Keep in mind that nullptr can mu be used as a bonl value [equal w false).
However, even if this cast is possible, nullptr will always chose a pointer to a
bool. The following example works and does not yield any ambiguity:
APP-CPD ,
void Prln!(hool value) ( e )
vnkd Pr‘nl(consl char‘ 1.x!) 1 e )
mm nullm" );
)

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
N U LL pol nter
> However, the following example will produce an ambiguity and the Code will
not com-ile:
APP~CPP
“w mm»): vahue) ( . )
vnln mmm- mm) t - )
V0“ Iaan l‘
( Prlnﬂ muptr ); l‘
l l
> The compiler will yield an error that states that it does not know what to ‘
chose for the call of “Print (nullptr)” and that it has two possible variants to ‘
chose from‘

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
> “const” specifier

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
n ll . .
Classes (methods) - the const specrfier ‘
> Whenever a method is declared within a class, a special keyword can also be
used t0 Specify a certain behavior for that method: “const” r
> The following code compiles without problem. At the end of execution
member x irom object “d“ will be 1;
APP-ﬁrm
‘lass Date
r
private
An! x,
pus1,(
1H=i s=cK()l
I 3;“ mm)
r
X:K
r==urn Xi
>
void main(7
r N
D.KE a,
a.s==K()'l.
i________________________________________________

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
Classes (methods) e the const spec1f1er
> This code will not compile because GetX function (i returns a constant
reference to a numben This means that the operator “++" from "dsGetX () H"
has to modify a number that is considered constant.
APP-CPP
‘1,55 Dill
t
Private:
in! x;
Puhll ~ i
=
n ‘i
(ans! ‘m mum“) z
rtlurn X;
wan mm!) ‘
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
n rr . .
Classes (methods) - the const specrfier
> The code compiles. Method GetX 1| returns a reference to a constant integer
whose value is 0. In the main function, “x” maintains a copy of the value
returned by GetX() function [a copy that can be modified).
> This is the recommended solution if we want to give read-only access to a
member variable l in particular if it is uo'r a basic type i.
APP-(PP
‘lass Date
t
PrivaKQ
Ant u,
puuite
‘onst inti E:tK()t
i
Xee
return Xi
i
void maln(7
i
neee d,
int X e d.E:tK()r
) K ,

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
When deahng with pmnters or references, “const” speclfier can be used m
the followmg ways:
vuld mal~<v
( nt
imam ~ W, Thvs code will not compile as ptr points w a
constant mt that CAN NOT BE modvﬁed.
>
Irv the prevvous example r the Cohst Speciﬁer vs part 0t the value. This means
that we can modtfy the pointer (NOT the value} without any issue.
vmd mm
<
m X,
tr Z LX
—
> p‘ This code will run as we DO NOT mudify the
actual value, we just modify the painter.

***************Ending Page***************


***************Beginning Page***************
***************page number:89**************
When dealing with pointers or references, “const” specifier can be used in
the following Ways:
vnld malhll
< m X This code will not Compile as ptr IS a
mt ~ W. constant pointer that puth towards a non-
) w constant value.
lh the previous example r the Cohst Speciﬁer refers w the pointer and NOT
the value it points t.
— /
:md mal"(7 This code will run as it initialize the
. constant pointer from the beginning,
This code will also run. “ptr” painter puints
l towards a non-const value that can be
modified.

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
Wheh deaiirig with puwters or references, “when specifier Cari be used if‘
the ioliowing Ways:
vnid hethtv
< M X This code will "Di. Compile as ptr IS a
m ~ w. constant pumter that points towards a Hun-
) constant vatue.
|h the previous exampie e the COnSt speciﬁer reiers to the pointer and NOT
the valuc it points t.
:m mm This code will run as it initialize the
. constant pointer from the beginning,
p This code Wilt NOT ruh as we try to modify a
> constant painter.

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
When deahng Mm Bowlers or references, “const” spemﬁer can be used m
me inﬂowmg ways:
vum memo
(
m ~ W e ax.
, P" " “ In this case both the pointer and the value
it pomts to are constant. The code will not
compile e one can not modify the pointer or
the value‘

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Classes (methods) , the "const" specifier
“corist” speciﬁer respects the Clockwise/Spiral Rule for c language.
value Pointer
int ' ptr; Non-const pointer to a non-const value YES YES
const int " ptr; Non-const pointer to a const value N0 YES
int const " ptr; Non-cunst pointer to a const value N0 YES
int " const ptr; Const pointer to a non-const value YES N0
const int ' const ptr; Const pointer to a const value N0 NO
In particular, a syntax like “int * cons! ptr" is equivalent to a reference lint &) I
and “const int * cunst ptr” to "const int &"

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
Classes (methods) , the "const" specifier

“const” speciﬁer respects the Clockwise/Spiral Rule for c language.
int " ptr; Non-const pointer to a non-const pointer to a non-const

value
const int "' ptr; Non-const pointer to a non-const pointer to a const value
int “ const ptr; Const pointer to a non-const pointer to a non-const value
int " const " const ptr; Const pointer to a const-pointer to a non-const value
const int ' const ' const ptr; Const pointer to a const-pointer to a const value
,/

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
Thvs code wvlt not compile. The usage 0f "const" keyword at the end of the
method declaratvon specvhes that Wlthvh that method data members 0t that
(Lass can not bc modiﬁcd. lh thc ncxt CXamplc, “X” is a data mcmbcr from
ctass Data and assigning value o to it contradicts the “must” keyword tram
method defmvtlon.
{tatt Dara
t
Private
m Xt
Pubh:
>.
(unst tntt Date Ectx<> (unst
t
Qt, error C3490: ‘x‘ cannot be modvfied because
3m mm) it is bevng accessed through a const object
‘ Date a.
w X Z a ﬁerXO.
J____;_______________________________________________

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
n II . .
Classes (methods) - the const spec1f1er
> Let's assume that we have the following code:
APMPP
(lass Date
<
Private
An! X’
,"t y,,,t,
Pub11(
(ans! 1n<t ﬁ=<l<> ions!»
l
K1“
return K,
v
vain Natal)
l
nit: 4.
in! K Z ¢.==<l<>,
, be
> And we want to make sure that access to data members "y", “2" and “t” are '
ready only, but for data member “X” we have read/Write access.
> If we use a "const" function {as define in this example] -) “x” wvll beread-
only as well.

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
n ll . .
Classes (methods) - the const spec1f1er
> Let's assume that we have the following code:
APMPP
(1:55 Dar:
<
PrivaKQ
Mutable An! 1;
‘Ht y,z,t,
Dual}:
(ans! Anti ﬁl<x<> tons!»
lam m. W Gem) W
l
Kza
return x,
i
vu,¢ malnl>
l
Ds<¢ a,
in! x - n ﬁl<x<>,
l'—
> Starting with C++11 there is a new specifier called “mutubie” that allows '
Write access t0 a data member even ii "const" specifier is used.
> This code will compile.

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
n ll - -
Classes (methods) - the const spec1f1er
> Let's assume that we have the following code:
APMPP
(lass Date
t
Drivel!
cans! Mutable t“! ~ 1;
Int y.1.t.
phs11t
(ans! ‘ﬁts aeKX() tons!»
lam m. use em) W
l
set»
return ~s,
1
sets mstsl>
l
Di(: a,
in! x - n ettxtu,
l'—
> “const” can be used with “mutuble'ﬂ In the previous example mutable refers '
t0 the value of the pointer and does not interfere with the const qualiﬁer.
This translates that you can mudify the pointer [through the mutnble
qualifier] but you can not modify the value (due to the const qualifier'at the
end 0f the GetX() method).

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
n II - -
Classes (methods) - the const spec1f1er
> Let's assume that we have the following code:
APMPP
(lass Date
i
PrivaKQ
(Bus! Mutable An! ~ <nﬂ§t 1;
‘Ht y.1.t.
Dual}:
(ans! Anti Ettxlu tons!»
lam m. W Gem) W
l
Kziw
relurn ‘x,
i
vu,¢ mstnl>
l
nit! a,
in! x - n Et<x<>,
l'—
> This code will not compile as “x” being a const pointer (not a pointer to a '
const value! can not be mutable at the same time (it will lmply that it can be
changed). At the same time, “X=&y" can not run as “>0 is a const pmngen

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
n u - - ‘k
Classes (methods) - the const specifier x
Usually mutable speciﬁer is used when:
> A class is run in a multi-threaded environment and you need a variable that
can be used between multiple threads
> Lambda expressions
> As a way to control what data members can be modified within a class from a ‘r

k const method.

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
n u - -
Classes (methods) - the const spec1f1er
> The code compiles correctly because "x" is no longer a member of an instance
but a global static member (it does not belong to the object)‘

APP-(PP
‘1iss Dill
(

Privlte:

51.11< in! x;
Public:
must in“ mm mm

3;.‘ Mm . m;
(ans! 1m mammal; (ans!
l

X Z a:

mu". x;
)
‘ma mun ,
l

nae a;

1m X - 4.6mm

),——

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
n It - -
Classes (methods) - the const spec1f1er
> The code does not compile because the “const” modmer from the end of
GetX declaration can not be used for Static functions as It needs and instance
td appty td (access td (his pdintdr that in impussvble if the methdd is declared
as const)
APP-(PP
‘1:55 Date
t
Privaze
St.ttt An! x,
pdbttt
stat1( ‘unst ‘ntt E:tK() ‘unstt
St.ttt (ans! tntt d.tt tt<x<> tans!
‘ X:t
rttdr" x,
>
vain milﬂ()
4
Date d.
in! X Z d.dt<x<>,
, mm

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
Classes (methods) , the const spec1f1er
> This code compiles‘ “const” speciﬁer refers to the current object/instance
alone. It does not apply to another instance of a difierent type lit will only
apply to the instance represented by “this").
APP-WP
SliSS Dill
t
Privlte:
in! x;
Public: i
ma mum/Mme ~ 47- l
I ‘ M . n; g
) x
h l
ma mm ,l
Date 11.12; l
a1.ma1fyx(mn; '
)

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
Classes (methods) , the const spec1f1er
> This code will NOT compile as a “const” method refers to the current instance
(“this" pointer),
APP-WP
‘lass Date
(
Privlte:
in! x;
Public: i
ma mum/Mme ~ my must i‘
I ‘ ‘a
) x
h 3
ma mm ,i
Date 11.11; \
a1.ma1fyx(m2); '
)

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
Classes (methods) - the const spec1f1er
> “const” i's part of object type
> Aclass method/(uncuon can not modify a parameters ii It is defined as
"const"
Without const specifier wmi const specifier
i t
M1,‘ mm
rm M, rm mo,
,r );
mm Date Ind) van! Dauiinizk)
( i
v ' ) '
< mo‘ ‘ “mi:
) )
vain mam) void mam) '
i t
rimmriri. Mimi-1i.
>— >—,_

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
Classes (data members) , the const
spec1f1er
> “const” can be used fur data members as well. The following code Wlll not
compvle as the const value ‘s not Invuallzedv
APP-(PP
(
3514 ma1"(7
l
l—
> To instantiate such a code , a value has tn be added in t0 the const data member
in the class deﬁnition (more on ms topic in the course related w constructors).
APP-CPP ,
l
b

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
> “friend” specifier

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
u ' n ~ -
friend spec1fier
> For a class a “friend” function is a function that can access methods and data
members that with private modifier define within that class’
> A “fn'end” function does not belong to the class iin this case to the Date
Class). From this point 0f View access Specifier is irrelevant (it doesn’i~ matter
if the “friend” function is written in the private or the public section)
APP~¢PP
:hss Dime i
l z
mt x; z
mm: i
nateﬂm value) 1 male) 0 i
mm mm Primatelhate m); i ,
vnid vunmnemna m)
; vim-x . “w, 6.x);
vnid an
r
um aw);
2 Primmldx):

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
u ' n ~ ~ ‘
friend spec1f1er
App.cpp > “friend” specifier can be applied to an I
:hss um enu re class I
l I
mug": x; > In this case , all methods from the ‘
l v A = X v m u “iriend” class can access the members ‘
2. w from the original class leg, all methods ‘
ch“ "Mm from class Printer can access the private ‘
sum“ data from class Data). I
ma Primeclnallnm u). .
ma Prtmﬂuaxldlilﬂ'lih n);
3;... >..~...==>..m....-m.... m)
‘ "mm-X - new. a“).
3.... >......==>..m.......m.... m
( mmm . 1mm‘. 6.x):
3.... n...)
( ,
hm mun);
mm» pi
ammm-sum.
p.Pr1m1¢-xannlal(d1);

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
u ' n ~ ~ ‘
friend spec1f1er
App.cpp > A method from a class can also be I
=1”; um; declared as friend for a class. I
this Min-r 1
smut > The declaration must include the exact ‘
Wia Seaman | a. m value); method signature and the return type. ‘
In i
2h“ "m > In this case, method SetX(Dute& , int) ‘
m x; from class Modifier can access private i
pm}? WM‘) l "m" ‘i l data from class Data. “
);
WM memensetxmna a a. m mm
( mama-fl) 1 mm;
1
vow “no
( um a;
Miﬂer I;
1.59am, 1a);
} prlmvwh'. 0.690(0):

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
y my

***************Ending Page***************

