***************Beginning Page***************
***************page number:1**************
0 O P Gavrilut Dragos
Course 2

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
b Pointers and References
> Method overloading
Summary > NULL pointer
b “const” specifier
\ > “friend” specifier

***************Ending Page***************


***************Beginning Page***************
***************page number:3**************
Pointers and
> References

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
App-Pomter App-Reference
void SetInt(int *i) void SetInt(int &i)
{ {
(*i) = 5; i = 5;
} }
void main() void main()
{ {
int x; int x;
Set(&x); Set(x);
} }
App-Pomter (asm - SetInt) App-Reference (asm - SetInt)
SetInt: SetInt:
push ebp push ebp
mov ebp,esp mov ebp,esp
mov eax,[ebp+8] mov eax,[ebp+8]
mov [eax],5 mov [eax],5
mov esp,ebp mov esp,ebp
pop ebp pop ebp
Pet Pet

***************Ending Page***************


***************Beginning Page***************
***************page number:5**************
Pointers and References
b The resulted code is identical (both the “Pointer” and “Reference” program
will link into the same assembler code.
> However, from the programmer point of view, using a reference fixes some
possible problems (perhaps the most know one is that one does not need to
use the “->” operator - instead the “.” operator can be used). Another
important one is that a check for NULL pointers is no longer required.
struct Date struct Date
{ {
int X; int X;
} }
void SetInt(Date *d) void SetInt(Date &d)
{ d->X = 5; { d.X = 5;
} }

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Pointers and References
b References and pointers are created in the following manner:
int i = 16; int i = 19;
int *p = &i; int &r~efI = i;
b The difference is that pointers can remain uninitialized.
int i = 19; ini- i = 18:
This forces the programmer to initialize a reference.
It also guarantees that a reference points to a valid memory location.

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
A pointer value can be changed (that is a pointer can point to different
memory addresses). A reference can only point to a variable and once it is
initialize the memory address where it points to can not be changed.

int i = 19; int i = 19;

int j = 20; int j = 29;

int *p = &i; int &r‘e-FI = i;

p = &j; —l
A pointer can have the value NULL. Compiler error ‘ trying
A reference can only point to a memory address to change a reference
that exists. that was already

initialized.

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Pointers and References

b Pointers accept certain arithmetic operations (+, - , ++, etc). This is not valid
for references.

int i = 19; int i = 19;
int j = 29; int j = 29;
int *p = &i; int &r\efI = i;
(*p) = 30; _ (&r‘efI)++;

b In case of pointers, variable “i” and “j” are allocated consecutively on the
stack. The operation “p++” moves the pointer p from the memory address of
the variable “i” to the memory address of the variable “j”. At the end of the
execution “j” will have the value 30.

***************Ending Page***************


***************Beginning Page***************
***************page number:9**************
Pointers and References
b A pointer can be converted to another pointer (cast). In particular any pointer
can be converted to a void pointer (void*). A reference can not be converted
to another reference.
int i = 19; int i = 10:
char *p = (char *)&i; char &r~efI = i; E
b This thing guarantees that a reference points to a memory address where a
certain type of variable resides.

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Pointers ancl References
b A pointer may point to another pointer and so on. This is not possible for
references - a reference refers only a variable.
int i = 10; int i = 19;
int *p = 811; in'l' RmP-FT = i:
int *p_to_p = &p; int & &ref_to_refI = refI;
**p_to_p = 20; :[
b It is important in this example to differentiate between “& &” (two
references separated with a space (‘ ‘) character) and “&&” (two consecutive
references).

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
Pointers and References
b A pointer can be used in an array and be dynamically initialized. This is not
possible for references.
b However, a reference may point to a temporary (or constant) value.
int *p = &int(10); const int &r‘e-FI = int(12),' '
This code will not compile if the
“const” specifier is not used as it
refers to a constant numerical
value.

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Pointers ancl References
b A pointer can be used in an array and be dynamically initialized. This is not
possible for references.

b However, a reference may point to a temporary (or constant) value.

const int &refI = int(12); const int &PefI = int(12);

int *p = (int *)&refI;

It is however possible to create a
pointer that points to a
reference of a temporary
(constant) value.

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
‘\ > Method overloading

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Method overloadi ng
b Method overloading is a technique used in C++ where one can define 2 or multiple
functions/ methods with the same name (or operators).
> A function / method is uniquely identified by its signature:
return-type FunctionName (param1-type, paramZ-type, )
A function/method signature is form out of:
1) function name
2) Parameters type (if parameters are present)
> Since parameters are part of the function signature, multiple functions/ methods
with the same name but different parameters are possible.
> However, this does not apply to return type (meaning that functions wit he same
name and parameters but different return type can not exit).

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
Meth cl l d’ g
APP-CPP
class Math
{
public:
int Add (int v1, int v2);
int Add (int v1, int v2, int v3);
int Add (int v1, int v2, int v3, int v4);
float Add (float v1, float v2);
};
int Math::Add(int v1, int v2)
{
return v1 + v2;
}
int Math::Add(int v1, int v2, int v3)
{
return v1 + v2 + v3;
}
int Math::Add(int v1, int v2, int v3, int v4)
{
return v1 + v2 + v3 + v4;
}
float Math::Add(float v1, float v2)
{
return v1 + v2;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Method overloadi ng

b Method overloading is NOT possible if the methods have the same signature
(same name, same parameters)

b In the next case, both methods are named Add and have two parameters of
type int ). The return type (even if in this case is different) will not be
considered , thus the two Add functions are consider duplicates l

APP-CPP
class Math
{
public:
int Add(int v1, int v2);
long Add(int v1, int v2);
int Math::Add(int v1, int v2)
{ return v1 + v2;
long Math::Add(int v1, int v2)
{ return v1 + v2;
i

***************Ending Page***************


***************Beginning Page***************
***************page number:17**************
> Be careful when you are using parameters with default value. From the
compiler point of view, using this feature does not mean that a function has
fewer parameters l
b This code will NOT compile as Add has the same signature l
Apncpp
class Math
{
public:
int Add(int v1, int v2 '
long Add(int v1,
};
int Math::Add(int v1, int v2)
{
return v1 + v2;
}
long Math::Add(int v1, int v2)
{
return v1 + v2;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
> Another special case are methods with variadic parameters (“...”). However,
they are not recommended in case of method overloading as the
interpretation can be misleading.
Apncpp
class Math
{
public:
int Add(int v1, int v2);
long Add(int v1, );
h El
int Math::Add(int v1, int v2)
{
return v1 + v2;
}
long Math::Add(int v1, ...)
{
return v1;
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:19**************
Method overloadi ng

b When a function/ method that was overloaded is called, the compiler
determines which one of the existing definiens of that function/ method it
should use. This process is called overload resolution

b lt is possible that the result of this process will be inconclusive (e.g. - the
compiler can not decide the best fit for a specific name). In this case a
compiler error will be raised, and the ambiguity will be explained.

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Method overloadi ng

Overload resolution steps:

1. Check if an exact match is possible (a method exists with the same name and
the exact same parameters type)
void Compute(int x, double y, char z)
Called Compute(100, 1.5, ‘A’)

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
Method overloadi ng
Overload resolution steps:
2. Check if a numerical promotion is possible (convert a type into another one
without loosing precision and the value).
/ bool, char, short, unsigned char and unsigned short can be promoted to in int
~/ float can be promoted to double
~/ Any enumeration (enum) without an explicit type can be converted to int
void Compute(int x, double y, char z)
Called Compute(true, 1.5f, ‘A’)
Promotion Compute(1, 1.5, ‘A’)
true is promoted to int value (1)
1.5f (a float value) is promoted to double value 1.5

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Method overloadi ng
Overload resolution steps:
3. Check if a numerical conversion is possible (convert a type into another one
with the possibility of loosing the actual value / precision).
void Compute(int x, double y, char z)
Called Compute(3.5, 1.5, ‘A’)
Conversion Compute(3, 1.5, ‘A’)
3.5 (a double value) will be converted to int value 3
(loosing precision)
It is possible that the conversion may apply to several overloaded methods. If
this is a case, an ambiguity error will be thrown, and the program will not
compile

***************Ending Page***************


***************Beginning Page***************
***************page number:23**************
Method overloading
Overload resolution steps:
4. Casts are attempted:
/ Every non-const pointer can be casted to its const pointer form
~/ Every non-const pointer can be casted to void * or const void *
~/ Every const pointer can be casted to const void *
\/ NULL macro (define) can be converted to numerical value 0
void Compute(int x, const void* y, char z)
Called Compute(NULL, “C++”, ‘A’)
Cast Compute(O, (const void*)”C++”, ‘A’)
NULL is converted to int value O
“C++” (a const char * pointer) is cast to const void *

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Method overloadi ng

Overload resolution steps:

5. Explicit casts (if any) are applied. We will discuss more on this topic when we
will study inheritance and C++ operators.

6. lf none of these attempts result in finding a match - a fallback method /
function (if any) is used. A fallback method is a method that only has variadic
parameters

I 7. lf there isn’t such a method , the compiler will produce an error.

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
> 100 is considered an “int” type value. Since there is a method by the name
Inc that has a parameter of type “int”, the compiler will use that method.
b In this case we have an exact-match situation.
APP-CPD
class Math
{
public:
int Inc(int v1);
Float Inc(float v1);
};
_____- int Math::Inc(int v1)
{
return v1 + 1;
}
float Math::Inc(float v1)
{
return v1+1.0f;
}
void main()
{
M- h m'
i
}

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
> 1.0f is a “float” value. Since there is a method by the name Inc that has a
parameter of type “float”, the compiler will use that method.
b In this case we have an exact-match situation.
APP-CPD
class Math
{
public:
int Inc(int v1);
Float Inc(float v1);
};
int Math::Inc(int v1)
{
return v1 + 1;
}
‘4444* float Math::Inc(float v1)
{
return v1+1.0f;
}
void main()
{
M- h m'
i
}

***************Ending Page***************


***************Beginning Page***************
***************page number:27**************
> ‘a’ is a “char” type value. As there is no method with the name Inc that has
one parameter of type “char”, the compiler promotes the char value to int
an uses the Inc method with one parameter of type “int” .
APP-CPD
class Math
{
public:
int Inc(int v1);
Float Inc(float v1);
};
_____- int Math::Inc(int v1)
{
return v1 + 1;
}
float Math::Inc(float v1)
{
return v1+1.0f;
}
void main()
{
M- h m'
i
}ﬁ

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Method overloadi ng
b ‘a’ is a “char” type value. As there is no method with the name Inc that has
one parameter of type “char”, the compiler promotes the char value to int
and tries again. Since there is no Inc method that has an int parameter (but
there are two Inc methods, an ambiguity case will be declared, and the code
will not compile. Event if, a char can fully be converted (without any value
lost) into a short , promotion only works for int and double types.
APP-CPP
class Math
{
public:
int Inc(short v1);
float Inc(float v1);
int Math::Inc(short v1)
{ return v1 + 1;
}
float Math::Inc(float v1)
{ return v1+1.9f;
}
void main()
{
Math m:
m.Inc(‘a’);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:29**************
Method overloading

> If during the promotion phase the compiler DOES NOT find any possible
promotion, but there are at least two methods/ functions with the same name
as the one attempted to be promoted the compiler will throw an error (this
will be considered to be an ambiguity case). Having at least two methods with
the same name is an indicator that method overloading is desired and another
overload for the specific call is required.

b However, if the promotion fails and there only ONE method with that name, a
conversion is attempted (in this case it is considered that method overloading
was not something desired by the programmer and the compiler attempts to
match the parameters even if this means losing precision / value).

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Method overloadi ng
b 1.0 is a double value. As there is not any Inc method that receives a double
parameter, promotion is attempted. Unfortunately — can not be promoted
(Without loosing value) to either int or float.
b Since there are two Inc function, this code will not compile, and an ambiguity
case will be exlained as an error.
Apncpp
class Math
{
public:
int Inc(int v1);
float Inc(float v1);
iht Math::Inc(int v1)
{ return v1 + 1;
}
float Math::Inc(float v1)
{ return v1+1.0f;
}
void main()
{
Math m;
m.Inc(1.6);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:31**************
In this case, 1.0 is a double value, and as there is no Inc function that has one
parameter of type double, promotion is attempted. Unfortunately, double
can not be converted to char without loosing precision.
However, as there is only ONE function Inc, the compiler will convert double
to char (even if this means losing precision). This code will compile with
warnings.
class Math
{
public:

int Inc(char v1) {

return v1 + 1;

}
};
void main()
{

Math m;
}—.—

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
In this case, 1.0 is a double value, and as there is no Inc function that has one
parameter of type double, promotion is attempted. Unfortunately, double
can not be converted to char without loosing precision.
However, as there is only ONE function Inc, the compiler will try to convert
double to char *. As this is not possible (only conversions numerical
conversions are possible) the compiler will produce an error and the code will
not compile.
class Math
{
public:
int Inc(char* v1) { return 1; }
};
void main()
{
Math m'
}
error C2664: ‘int Math::lnc(char *)':
cannot convert argument 1 from
'double' to ‘char *'

***************Ending Page***************


***************Beginning Page***************
***************page number:33**************
Method overloadi ng
b Pointer conversions are also impossible. “&d” is a “double *” that can not be
converted to “char *”.
b This code will produce a compiler error.
Appmpp
class Math
{
public:
int Inc(char* v1);
int Math::Inc(char* v1)
{ return 1;
}
void main()
{ ~
m.Inc &d 3
}
error C2664: ‘int Math::lnc(char *)':
cannot convert argument 1 from
‘double *' to ‘char *'

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
> Pointer conversions are also impossible. “&d” is a “double *” that can not be
converted to “char *”.
b However, using an explicit cast will solve this problem. ln this case, the code
will compile.
Appmpp
class Math
{
public:
int Inc(char* v1);
};
int Math::Inc(char* v1)
{
return 1;
}
void main()
{
Math m;
double q = 5'
mindﬁw
}

***************Ending Page***************


***************Beginning Page***************
***************page number:35**************
Method overload] ng

b However, any non-constant pointer can be converted to “void *”. The next
example will compile.

b A constant pointer can not be converted to a non-constant pointer implicitly
(without a cast). A non-constant pointer can always be converted to its
constant equivalence. That is why, if you don’t need to modify the value
where the pointer points, it is best to use const pointers for method/function
parameters.

Apncpp
class Math
{
public:
int Inc(void* v1);
int Math::Inc(void* v1)
{
return 1;
}
void main()
{
Math m:
double d = 1.6;
m.Inc(&d);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Method overloading
> Methods with variadic parameters:

1. Fallback methods 9 methods with only one parameter that is variadic (with a
signature in the form <name> (...). These methods are the last to be used (only if
there is no possible conversion, cast or promotion or if there is no ambiguity in
terms of promotion/ conversion. These functions are not allowed in C language.

2. Regular methods 9 methods that have at least one parameter that is not variadic
and ONE variadic parameter (e.g. <name>(int,...) or <name>(char,short,...) ).
These methods are used just like the regular methods and the same rules apply to
them as well.

***************Ending Page***************


***************Beginning Page***************
***************page number:37**************
> In case of methods with variadic parameters the compiler will use the best fit
(in terms of exact parameters). This code compiles and the method Inc(int) is
used.
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(...);
};
_____- int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(...)
{
return 1;
}
void main()
{
M- h m'
i
}ﬁ—

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Method overload1 ng
> In this case, as there is no Inc method that has a parameter of type char, the
compiler promotes ‘a‘ (char value 97) to int and uses the Inc(int) method.
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(...);
};
_____- int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(...)
{
return 1;
}
void main()
{
M- h m'
i
%—

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
Method overloading
b 1.0 is a double value. We can not apply numerical promotion to int to use
Inc(int) method. However, we can convert the double to an int (with possible
loss of value) and then use Inc(int) method. The code compiles. The fallback
function is used onl if no romotion/conversion is ossible.
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(...);
};
int Math::Inc(int v1)
{ return v1 + 1;
}
int Math::Inc(...)
{
return 1;
}
void main()
{
M-th m'
%—

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
This is an ambiguous case. There is no promotion possible. However, the
double value 1.0 can be converted to both int (and use Inc(int) method, or
float and use Inc(float) method). As there are two possibilities, this code is
considered ambiguous and an error is thrown.
class Math
{
public:
int Inc(int v1);
int Inc(float v1);
int Inc(...);
};
int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(float v1)
{
return v1 + 1;
}
int Math::Inc("') error C2668: ‘Math::Inc': ambiguous call to overloaded function
return 1; note: could be 'int Math::Inc(float)‘
} note: or 'int Math::Inc(int)'
‘mid “31:51) { note: while trying to match the argument list '(double)'
a m'
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:41**************
> In this case the parameter used is a const char * (a pointer). There is no
promotion and no conversion possible. Thus, the compiler must use the
fallback method Inc(...)
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(...);
};
int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(...)
{
return 1;
}
void main()
{
M- h m'
i
}ﬁ—

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
> A similar case 9 there is no method overloaded with 2 parameters, so the
compiler uses the fallback method Inc(...)
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(...);
};
int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(...)
{
return 1;
}
void main()
{
M- h m'
i
}ﬁ—

***************Ending Page***************


***************Beginning Page***************
***************page number:43**************
b This is an ambiguous case. 123 is an int value and there are two methods that
match exactly with the call Inc(123) : Inc(int) and Inc(int,...). The code will
NOT compile.
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(int v1,...);
h
int Math::Inc(int v1)
{
return v1 + 1;
intpmthxlncﬁnt\u’_u) warning C4326: return type of 'main' should be 'int' instead of 'void'
{ error C2668: ‘Math::Inc': ambiguous call to overloaded function
"eu"“ 15 note: could be ‘int Math::Inc(int,...)'
ioﬂimaﬂﬂ) note: or ‘int Math::Inc(int)‘
{ note: while trying to match the argument list '(int)'
Math m'
}ﬁ—

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
This is an ambiguous case. true is a bool value and we don’t have an exact
method to match Inc(bool). In this case numerical promotion is apply, bool is
promoted to int and now we have two methods that match: Inc(int) and
Inc(intz...2. The code will NOT compile.
class Math
{
public:
int Inc(int v1);
int Inc(int v1,...);
h
int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(int V1,...)
{ error C2668: ‘MathzzInc': ambiguous call to overloaded function
return 1; . .
} note: could be ‘int Math::Inc(1nt,...)'
vonimanm) note: or ‘int Math::Inc(int)'
{ Mth note: while trying to match the argument list '(bool)'
a m'
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:45**************
b This code will NOT compile. None of the methods Inc(int) and Inc(int,...)
matches the const char * parameter and there is no fallback method.
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(int v1,...);
h
int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(int V1,...)
{ error C2664: ‘int Math::Inc(int,...)': cannot convert
return 1; I I I, I
} argument 1 from const char [5] to 1nt
vohimahﬂ) note: There is no context in which this conversion is
{ possible
Math m'
}ﬁ—

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
> This code will compile. ‘a’ (char) is promoted to int and since there is only
one method that accepts two parameters, the compiler will use it.
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(int v1,...);
};
int Math::Inc(int v1)
{
return v1 + 1;
}
int Math::Inc(int V1,...)
{
return 1;
}
void main()
{
M- h m'
i
}ﬁ—

***************Ending Page***************


***************Beginning Page***************
***************page number:47**************
> This code will compile. ‘a’ (char) is promoted to int and since there is only
one method that accepts two parameters, the compiler will use it.
b Fallback methods (Inc(...)) are used only if no match is possible.
APP-CPD
class Math
{
public:
int Inc(int v1);
int Inc(int v1,...);
int Inc(...);
};
int Math::Inc(int v1) {
return v1 + 1;
}
_ int Math::Inc(int V1,...) {
return 1;
}
int Math::Inc(...) {
return 2;
}
void main()
{
Math m'
i
}

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
b This code will compile. However, in this case there is no match possible from
Inc(const char *, bool) (including promotions and conversions) to the existing
methods Inc(int) and Inc(int,...). However, as a fallback function is also
available the comiler will choose to use it.

APP-CPD

class Math

{

public:
int Inc(int v1);
int Inc(int v1,...);
int Inc(...);

};

int Math::Inc(int v1) {
return v1 + 1;

}

int Math::Inc(int V1,...) {
return 1;

}

int Math::Inc(...) {
return 2;

}

void main()

{
Math m;
m.Inc(“test”,true);

}

***************Ending Page***************


***************Beginning Page***************
***************page number:49**************
b When dealing with overloaded methods with multiple parameters, promotion and
conversion rules are evaluated for each parameter.

b Overload resolution will choose the combination of promotion/ conversions that
covers highest number of unique parameters.

b If there are at least two solutions that have at least one different parameter that
each one of the solution can cover (match / promote or convert) an ambiguous
case is considered and an error will be thrown.

> If nothing matches, a promotion is considered stronger than a conversions , and
can be used to resolve overload resolution (in fact a promotion is sometimes
considered equal as importance with an exact match).

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
> This code will compile. There is an exact match (a function Add with two
parameters, first of type char and the second of type int).
APP-CPD
class Math
{
public:
void Add(char x, int y);
void Add(int x, char y);
};
444444 void Math::Add(char x, int y)
{
printf("Add(char,int)");
}
void Math::Add(int x, char y)
{
printf("Add(int,char)");
}
void main()
{
4
}

***************Ending Page***************


***************Beginning Page***************
***************page number:51**************
> This code compiles. The compiles promotes the second parameter from bool
to int and uses Add(char, int)
APP-CPD
class Math
{
public:
void Add(char x, int y);
void Add(int x, char y);
};
444444 void Math::Add(char x, int y)
{
printf("Add(char,int)");
}
void Math::Add(int x, char y)
{
printf("Add(int,char)");
}
void main()
{
i
}

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
b This is an ambiguous case as we have two possibilities:
a. 100 = int , we convert 200(int) to char and use Add(int,char)
b. 100(int) is converted to char, 200 is considered an int and we use Add(char,int)
APP-CPD
class Math
{
public:
void Add(char X, int y);
void Add(int x, char y);
h
void Math::Add(char x, int y)
{
printf("Add(char,int)");
}
void Math::Add(int x, char y)
{ ‘ n . n error C2666: ‘Math::Add': 2 overloads have similar conversions
} pr“¢f(Am“1“LChmﬁ )5 note: could be ‘void Math::Add(int,char)' }
vonjmanﬂ) note: or ‘void Math::Add(char,int)'
{ note: while trying to match the argument list '(int, int)‘
}

***************Ending Page***************


***************Beginning Page***************
***************page number:53**************
> This code compiles. We also have two possibilities, but the first one is better:
a. 100 = int, 1.5 is converted to char and we use Add(int,char) [ one conversion + one exact
match]
b. 100 (int) is converted to char, 1.5 to int and we use Add(char,int) [ two conversions ]
APP-CPP
class Math
{
public:
void Add(char x, int y);
void Add(int x, char y);
};
void Math::Add(char x, int y)
{
printf("Add(char,int)");
}
‘4444* void Math::Add(int x, char y)
{
printf("Add(int,char)");
}
void main()
{
i
}

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
b This code compiles. We also have three possibilities:
a. ‘a’ = char (exact match), 1.5 (a double is converted to int) and 2.5 (a double is converted to
int) -) 1 x exact match, 2 x conversion
b. ‘a’ ( char is promoted to int), 1.5 (a double is converted to char) and 2.5 (a double is
converted to int) -) 1 x promotion, 2 x conversion
c. ‘a’ ( char is converted to float), 1.5 (a double is converted to bool) and 2.5 (a double is
converted to int) -) 3 x conversion
b Solution a) has an exact match and since there is no other solutions that can
match another arameter than the first one this will be selected.
APP-CPP
class Math
{
public:
int Add(char x, int y, int z) { return 1; }
int Add(int x, char y, int z) { return 2; }
int Add(float x, bool y, int z) { return 3; }
};
void main()
{
Math m:
int x = m.Add('a', 1.5, 2.5);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
b This code will NOT compile. We also have three possibilities:
a. ‘a’ = char (exact match), 1.5f (a float is converted to int) and 2.5 (a double is converted to
int) -) 1 x exact match, 2 x conversion
b. ‘a’ ( char is promoted to int), 1.5f (a float is converted to char) and 2.5 (a double is converted
to int) -) 1 x promotion, 2 x conversion
c. ‘a’ = char (exact match), 1.5f (a float is converted to bool) and 2.5 (a double is converted to
int) -) 1 x exact match, 2 x conversion
b Since both solutions a) and c) have an exact match for the 1St parameter, this
will be considered an ambiuit case.
APP-CPD
class Math
{ /
public:
int Add(char x, int y, int z) { return 1; }
int Add int x char y, int z) { return 2; } 4
int Add_ bool y, int z) { return 3; }
}; error C2668: ‘MathzzAdd': ambiguous call to overloaded function
void main() note: could be ‘int Math::Add(char,bool,int)'
{ note: or ‘int Math::Add(char,int,int)'
note: while trying to match the argument list '(char, float, double)‘
}

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
b This code will NOT compile. We also have three possibilities:
a. ‘a’ = char (exact match), ‘a’ (a char is promoted to int) and 2.5 (a double is converted to int) -)
1 x exact match, 1 x conversion, 1 x promotion
b. ‘a’ ( char is promoted to int), ‘a’ = char (exact match) and 2.5 (a double is converted to int) -)
1 x exact match, 1 x conversion, 1 x promotion
c. ‘a’ = char (exact match), ‘a’ (a char is converted to bool) and 2.5 (a double is converted to int)
-) 1 x exact match, 2 x conversion
b Solution a) and c) have an exact match for the 1st parameter (but not for the
second one). Solution b) has an exact match for the 2nGI parameter (but not for
the first one). This is considered an ambiguity.
APP-CPP
class Math
{
public:
int Add(char x, int y, int z) { return 1; } I
int Add(int x, char y, int z) { return 2; }
}_ 1nt Add(char X’ b001 y, 1nt Z) { return 3; } error C2666: 'Math::Add': 3 overloads have similar conversions
void main() note: could be ‘int Math::Add(char,bool,int)'
{ note: or ‘int Math::Add(int,char,int)'
“_ i n. note: or ‘int Math::Add(char,int,int)'
note: while trying to match the argument list '(char, char, double)‘
}

***************Ending Page***************


***************Beginning Page***************
***************page number:57**************
Method overloadi ng
b Let’s consider the following code:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(1.5, true, 1.5)
E_ X (double) Y (bool) Z (double)
1. Add (char x, int y, int z) conversion promotion conversion
2. Add (double x, int y, int z) exact match promotion conversion
3. Add (char x, bool y, char z) conversion exact match conversion
b Solution 1 (has an exact match for the first parameter), Solution 2 has a xact
match for the second parameter -)

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
Method overloadi ng
> Let’s consider the following code:
APP-CPP
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
> and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(false, true, 1.5)
EI_ X (boon Y (boon Z (double)
1. Add (char x, int y, int z) conversion promotion conversion
2. Add (double x, int y, int z) conversion promotion conversion
3. Add (char x, bool y, char z) conversion exact match conversion
b One solution that has a match (solution 3). There is no promotion or exa
match for “X” or “Z” in solution 1 or 2 -) code will compile

***************Ending Page***************


***************Beginning Page***************
***************page number:59**************
Method overloadi ng
b Let’s consider the following code:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(1.5, true, 1.5)
E_ X (double) Y (bool) Z (double)
1. Add (char x, int y, int z) conversion promotion conversion
2. Add (double x, int y, int z) exact match promotion conversion
3. Add (char x, bool y, char z) conversion exact match conversion
b Solution 1 (has an exact match for the first parameter), Solution 2 has a xact
match for the second parameter -)

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
Method overloadi ng
> Let’s consider the following code:
APP-CPP
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
> and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(‘a’, true, 1.5)
IZI_ X (char) Y (boon z (double)
1. Add (char x, int y, int z) exact match promotion conversion
2. Add (double x, int y, int z) conversion promotion conversion
3. Add (char x, bool y, char z) exact match exact match conversion
b Solution 3 has two exact matches (for X and Y), solution 1 has one match 'ust
for X). As solution 3 covers solution 1, and solution 2 does not have a omotion
or exact match for “Z”, code will compile and solution 3 will be ected

***************Ending Page***************


***************Beginning Page***************
***************page number:61**************
Method overloadi ng
b Let’s consider the following code:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(‘a’, true, 100)
E_ X (char) Y (bool) Z (int)
1. Add (char x, int y, int z) exact match promotion exact match
2. Add (double x, int y, int z) conversion promotion exact match
3. Add (char x, bool y, char z) exact match exact match conversion
b Solution 3 matches parameters 1 and 2, solution 1 matches parameters 1 d 3
(there is no clear solution) -)

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Method overloadi ng
b Let’s consider the following code:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(1.5, true, ‘a’)
E_ X (double) Y (bool) Z (char)
1. Add (char x, int y, int z) conversion promotion promotion
2. Add (double x, int y, int z) exact match promotion promotion
3. Add (char x, bool y, char z) conversion exact match exact match
b Solution 3 matches parameters 2 parameters (Y and Z) but not paramete ”.
Since there is also a solution that could match parameter “X” (soluti 2) this
will be considered an .

***************Ending Page***************


***************Beginning Page***************
***************page number:63**************
Method overloadi ng
b Let’s consider the following code:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(100, 1.5, 1.5)
E_ X (int) Y (double) Z (double)
1. Add (char x, int y, int z) conversion conversion conversion
2. Add (double x, int y, int z) conversion conversion conversion
3. Add (char x, bool y, char z) conversion conversion conversion
b No cases with exact match, all solutions have 3 conversions 9//

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
Method overloadi ng
> Let’s consider the following code:
APP-CPP
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, char z) { return 3; }
};
> and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(1.0f, 1.5, 1.5)
E_ X (ﬂoat) Y (double) Z (double)
1. Add (char x, int y, int z) conversion conversion conversion
2. Add (double x, int y, int z) promotion conversion conversion
3. Add (char x, bool y, char z) conversion conversion conversion
b No cases with exact match, however there is one case that has an accep
promotion while the rest only have conversions. No promotion/ exact atch for
“Y” and “Z” for Solution 1 and 3. Solution 2 is selected and code mpiles.

***************Ending Page***************


***************Beginning Page***************
***************page number:65**************
Method overloadi ng
b Let’s change the previous definitions a little bit:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, double z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(1.0f, 1.5, 1.0f)
E_ X (ﬂoat) Y (double) Z (ﬂoat)
1. Add (char x, int y, int z) conversion conversion conversion
2. Add (double x, int y, int z) promotion conversion conversion
3. Add (char x, bool y, double z) conversion conversion promotion
b Solution 2 is valid for “X” (due to promotion), Solution 3 is valid for “Z” e to
promotion). -)

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Method overloadi ng
b Let’s change the previous definitions a little bit:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, double z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(1.0f, 1.5, 1.5)
EI_ X (ﬂoat) Y (double) Z (double)
1. Add (char x, int y, int z) conversion conversion conversion
2. Add (double x, int y, int z) promotion conversion conversion
3. Add (char x, bool y, double z) conversion conversion exact match
b This is a case where promotion and exact match are seen as equals. Solu ' n 2
is valid for “X” (due to promotion), Solution 3 is valid for “Z” (due to act
match). -)

***************Ending Page***************


***************Beginning Page***************
***************page number:67**************
Method overloadi ng
b Let’s change the previous definitions a little bit:
APP-CPD
struct Math
{ int Add(char x, int y, int z) { return 1; }
int Add(double x, int y, int z) { return 2; }
int Add(char x, bool y, double z) { return 3; }
};
b and let’s consider that we call MathzzAdd with the following parameters:
Math m; m.Add(1.0f, 1.5, 100)
EI_ X (ﬂoat) Y (double) Z (int)
1. Add (char x, int y, int z) conversion conversion exact match
2. Add (double x, int y, int z) promotion conversion exact match
3. Add (char x, bool y, double z) conversion conversion conversion
b Solution 2 covers “X” (due to promotion) and “Z” (due to exact match). ere
is no other solution better , or one that can cover “Y” -) Solution 2 i elected
and the code compiles.

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Method overloadi ng
> When dealing with the const keyword there are also some differences in
terms of method overloading and overload resolution
b For numerical types (types that are transmitted to a method by value) const
is ignored from the method / function signature

I > For pointers and references, const is used in the method / function signature.

***************Ending Page***************


***************Beginning Page***************
***************page number:69**************
b This case will NOT compile - but not due to a ambiguity problem, but rather
to the fact that both Inc(int) and Inc(const int) are considered to have the
same signature: Inc(int)
APP-CPD
class Math
{
public:
int Inc(int X) { return X + 2; }
int Inc(const int x) { return x + 1; }
};
void main()
{
Math m; k
[Tinaiﬁm error C2535: ‘int Math::Inc(int)': member function already defined or declared ’
} note: see declaration of ‘MathzzInc'

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
Method overloadi ng
> In this case , the two Inc methods are considered to have a different
signature and therefor are used in the overload resolution. As “&d” is an int *
than the best match ( meaning Inc(int *) will be chosen). The code compiles.
APP-CPD
class Math
{
public:
____ int Inc(int * x)
return *x + 2;
}
int Inc(const int * x)
{
return *x + 1;
}
};
void main()
{
M- h m'
int x = 10;
}ﬁ

***************Ending Page***************


***************Beginning Page***************
***************page number:71**************
> Similarly, if we change “x” local variable from main function to be a constant,
the second function Inc(const int *) will be chosen as a perfect match.
APP-CPD
class Math
{
public:
int Inc(int * x)
{
return *x + 2;
}
444' int Inc(const int * x)
{
return *x + 1;
}
};
void main()
{
M- h m'
const int x = 10;
m.Inc(&x);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
> The same logic applies for references as well.
APP-CPD Appmpp
class Math class Math
{ {
public: public:
int Inc(int & x) ___. int Inc(int & x)
{ {
return x + 2; return x + 2;
} }
444' int Inc(const int & x) int Inc(const int & x)
{ {
return x + 1; return x + 1;
} }
}s };
void main() void main()
{ {
M- h m' M. h m'
const int X = 10; int x = 10;
m.Inc(x); m.Inc(x);
} }

***************Ending Page***************


***************Beginning Page***************
***************page number:73**************
> The same logic applies for references as well.
b In particular, when dealing with constant numerical values they will always be
translated into a const reference.
APP-CPD
class Math
{
public:
int Inc(int & X)
{
return x + 2;
}
444' int Inc(const int & x)
{
return x + 1;
}
};
void main()
{
Math m'

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
b In this case the code will not compile as a constant (const) value CAN NOT be
converted to a non-constant value.

APP-CPD
class Math
{
public:

int Inc(int & X)

{

return x + 2;

}
h
void main()
{

Math m'
}
error C2664: ‘int Math::Inc(int &)': cannot
convert argument 1 from 'int' to ‘int &'

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
Method overloadi ng

> The rest of the promotion / conversion rules apply.

b In this example, ‘a’ is of type char. As there is no Inc method that receives a
char parameter, ‘a’ will be converted to an int and then to a const int &. This
code will compile.

APP-CPD
class Math
{
public:
int Inc(int & X)
{
return x + 2;
}
444' int Inc(const int & x)
return x + 1;
}
};
void main()
{
Math m'

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
‘\ > NULL pointer

***************Ending Page***************


***************Beginning Page***************
***************page number:77**************
b Let’s consider the following code:
APP-CPP
void Print(int value)
{
printf("Number: %d\n", value);
}
void Print(const char* text)
{
printf("Text: %s\n", text);
}
void main()
{
Print(10);
Print("C++ test");
Print(NULL);
}—
b The code compiles correctly. What is the output of this code ?

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
b Let’s consider the following code:
APP-CPP
void Print(int value)
{
printf("Number: %d\n", value);
}
void Print(const char* text)
{
printf("Text: %s\n", text);
}
Output
void main()
{ Number: 1O
Print(10); .
Print("C++ test"); TeXt' C++ teSt
—|
}—
b Why the last call of Print function is considered to be a number?

***************Ending Page***************


***************Beginning Page***************
***************page number:79**************
b Let’s consider the following code:
APP-CPP
void Print(int value)
{
printf("Number: %d\n", value);
}
void Print(const char* +ev+\
{
printf("Text:
} #ifdef _cplusplus
_ _ #define NULL 0
1/01d ma1n() #else
print(1@); ‘ #define NULL ((void *)0)
Print("C++ t #endif
_ #endif
Prlnt -;
}—
b Why the last call of Print function is considered to be a number?

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
N U LL poi nter
b So — NULL is defined as a number. While during promotion, value 0 can be
translated into a NULL pointer, there are often cases (similar to previous one)
where the intended parameter is a pointer ( a NULL pointer ) and not a
number.
> The solution was to create a new constant (keyword) that refers only to null
pointers. This constant is called nullptr
APP-CPP
void Print(int value) { m }
void Print(const char* text) { m }
void main()
{
Pr'int(-);
}—
b ln the previous example, the compiler will now call “Print(const char*)”
function.

***************Ending Page***************


***************Beginning Page***************
***************page number:81**************
N U LL poi nter
b The following assignments are valid for NULL constant and all variable will be
set to O false or a null ointer.
APP-CPP
void main()
{
int x = NULL;
char y = NULL;
float f = NULL;
bool b = NULL;
const char* p = NULL;
int * i = NULL;
}—
b The following assignments are invalid (code will NOT compile):
APP-CPD
void main()
{
int x = nullptr;
char y = nullptr;
float f = nullptn;
}
-------------------------------------::7”------

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
b The following assignments are valid and the code will compile.
APP-CPP
void main()
{
bool b = nullptr;
const char* p = nullptr;
int * i = nullptr;
}—
b Keep in mind that nullptr can still be used as a bool value (equal to false).
However, even if this cast is possible, nullptr will always chose a pointer to a
bool. The following example works and does not yield any ambiguity:
APP-CPD
void Print(bool value) { m }
void Print(const char* text) { m }
26°10‘ main() The compiler will choose to call “Print (const char* )” function
Print( nullptr );
}
é

***************Ending Page***************


***************Beginning Page***************
***************page number:83**************
N U LL poi nter
b However, the following example will produce an ambiguity and the code will
not compile:
APP-CPP
void Print(bool value) { m }
void Print(int* value) { m }
void main()
{
Print( nullptr )3
}—
b The compiler will yield an error that states that it does not know what to
chose for the call of “Print (nullptr)” and that it has two possible variants to
chose from.

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
‘\ > “const” specifier

***************Ending Page***************


***************Beginning Page***************
***************page number:85**************
II II 0 o

Classes (methods) - the const specifier
> Whenever a method is declared within a class, a special keyword can also be
used to specify a certain behavior for that method: “const”
b The following code compiles without problem. At the end of execution
member x from object "d" will be 1;
Apncpp
class Date
{

private:

int x;

public:

int& GetX();
int& Date::GetX()
{

x = 0;

return x;
}
void main()
{

Date d;

d.GetX()++;

\ } :

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
" II O 0
Classes (methods) - the const specifier
> This code will not compile because GetX function () returns a constant

reference to a number. This means that the operator "++" from "d.GetX () ++"
has to modify a number that is considered constant.
Apncpp
class Date
{

private:

int x;

public:
zonst int& Date::GetX()
{

x = 0;

return x;
}
void main()
{

Date d'
}ﬁ

***************Ending Page***************


***************Beginning Page***************
***************page number:87**************
" II O 0
Classes (methods) - the const specifier
b The code compiles. Method GetX () returns a reference to a constant integer
whose value is 0. In the main function, “x” maintains a copy of the value
returned by GetX() function (a copy that can be modified).
b This is the recommended solution if we want to give read-only access to a
member variable ( in particular if it is NOT a basic type ).
APP-CPP
class Date
{
private:
int x;
public:
const int& GetX();
zonst int& Date::GetX()
{ x = 9;
return X;
}
void main()
{
Date d;
int x = d.GetX();
w%

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
When dealing with pointers or references, “const” specifier can be used in
the following ways:
void main()
{
int x; , , . .
const int * ptr‘; This code Will not compile as ptr p01nts to a
constant int that CAN NOT BE modified.
}
In the previous example - the const specifier is part of the value. This means
that we can modify the pointer (NOT the value) without any issue.
void main()
{
int x;
const int * ptr;
ntP = &X'
} This code Will run as we DO NOT modify the
actual value, we just modify the pointer.

***************Ending Page***************


***************Beginning Page***************
***************page number:89**************
When dealing with pointers or references, “const” specifier can be used in
the following ways:
void main()
{ int X_ This code will not compile as ptr is a
int * ’ _ ptr; constant pointer that points towords a non-
} constant value.
In the previous example - the const specifier refers to the pointer and NOT
the value it points t.
zoid main() This code will run as it initialize the
-. - constant pointer from the beginning.
This code will also run. “ptr” pointer points
} towards a non-const value that can be
modified.

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
When dealing with pointers or references, “const” specifier can be used in
the following ways:
void main()
{ int X_ This code will not compile as ptr is a
int * ' _ ptr; constant pointer that points towords a non-
} constant value.
In the previous example - the const specifier refers to the pointer and NOT
the value it points t.
goid main() This code will run as it initialize the
-. - constant pointer from the beginning.
This code Will NOT run as we try to modify a
} constant pointer.

***************Ending Page***************


***************Beginning Page***************
***************page number:91**************
II II ' '
Classes (methods) - the const specifier
b When dealing with pointers or references, “const” specifier can be used in
the following ways:
APP-CPP
void main()
{
int x;
const int * const ptr = &x;
} ptr += 1’ ln this case both the pointer and the value
it points to are constant. The code will not
compile - one can not modify the pointer or
I the value.

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Classes (methods) - the "const" specifier
“const” specifier respects the Clockwise/Spiral Rule for C language.
value Pointer

int * ptr; Non-const pointer to a non-const value YES YES
const int * ptr; Non-const pointer to a const value NO YES
int const * ptr; Non-const pointer t0 a const value NO YES
int * const ptr; Const pointer to a non-const value YES NO
const int * const ptr; Const pointer to a const value NO NO

In particular, a syntax like “int * const ptr” is equivalent to a reference (int &)

and “const int * const ptr” t0 “const int &”

***************Ending Page***************


***************Beginning Page***************
***************page number:93**************
Classes (methods) - the "const" specifier

“const” specifier respects the Clockwise/Spiral Rule for C language.
int ** ptr; Non-const pointer to a non-const pointer to a non-const

value

const int ** ptr; Non-const pointer to a non-const pointer to a const value
int ** const ptr; Const pointer to a non-const pointer to a non-const value
int * const * const ptr; Const pointer to a const-pointer to a non-const value
const int * const * const ptr; Const pointer to a const-pointer to a const value

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
This code will not compile. The usage of “const” keyword at the end of the
method declaration specifies that within that method data members of that
class can not be modified. In the next example, “x” is a data member from
class Data and assigning value O to it contradicts the “const” keyword from
method definition.
class Date
{
private:
int x;
public:
const int& GetX()-
};
const int& Date::GetX() const
{
return X; error C3490: x cannot be modified because
$01 d main() it is being accessed through a const object
{
Date d;
int x = d.GetX();
X++;
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:95**************
II ll ° °
Classes (methods) - the const specifier
b Let’s assume that we have the following code:
Appmpp
class Date
{
private:
int x;
int y,z,t;
public:
const int& GetX() const;
zonst int& Date::GetX() const
{ X = 0;
return X;
}
void main()
{
Date d;
int x = d.GetX();
}X,—
b And we want to make sure that access to data members “y”, “z” and “t” are
ready only, but for data member “x” we have read/write access.
b If we use a “const” function (as define in this example) -) “x” will be ead-
only as well.

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
II ll ° °
Classes (methods) - the const specifier
> Let’s assume that we have the following code:
Appmpp
class Date
{
private:
mutable int x;
int y,z,t;
public:
const int& GetX() const;
zonst int& Date::GetX() const
{ x = 0;
return x;
}
void main()
{
Date d;
int x = d.GetX();
} X ’
b Starting with C++11 there is a new specifier called “mutable” that allows
write access to a data member even if “const” specifier is used.
b This code will compile.

***************Ending Page***************


***************Beginning Page***************
***************page number:97**************
" II O 0
Classes (methods) - the const specifier
b Let’s assume that we have the following code:
Appmpp
class Date
{
private:
const mutable int * x;
int y,z,t;
public:
const int& GetX() const;
zonst int& Date::GetX() const
{ X = 8w;
return *x;
}
void main()
{
Date d;
int x = d.GetX();
}’—
b “const” can be used with “mutable”. In the previous example mutable refers
to the value of the pointer and does not interfere with the const qualifier.
This translates that you can modify the pointer (through the mutable
qualifier) but you can not modify the value (due to the const qualif' at the
end of the GetX() method).

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
" II O 0
Classes (methods) - the const specifier
b Let’s assume that we have the following code:
Appmpp
class Date
{
private:
const mutable int * const x;
int y,z,t;
public:
const int& GetX() const;
zonst int& Date::GetX() const
{ X = 8w;
return *x;
}
void main()
{
Date d;
int x = d.GetX();
}X’—
b This code will not compile as “x” being a const pointer (not a pointer to a
const value) can not be mutable at the same time (it will imply that it can
changed). At the same time, “x=&y” can not run as “x” is a const point .

***************Ending Page***************


***************Beginning Page***************
***************page number:99**************
II II 0 0
Classes (methods) - the const specifier
Usually mutable specifier is used when:
> A class is run in a multi-threaded environment and you need a variable that
can be used between multiple threads
b Lambda expressions
b As a way to control what data members can be modified within a class from a
const method.

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
II ll ' °
Classes (methods) - the const specifier
> The code compiles correctly because "x" is no longer a member of an instance
but a global static member (it does not belong to the object).

Apncpp
class Date
{

private:

static int x;
public:
const int& GetX() const;

int Datezzx = 100;
const int& Date::GetX() const
{ x = 0;

return x;
}
void main()
{

Date d;

int x = d.GetX();
} X ’

***************Ending Page***************


***************Beginning Page***************
***************page number:101**************
" II O 0
Classes (methods) - the const specifier
b The code does not compile because the “const” modifier from the end of
GetX declaration can not be used for static functions as it needs and instance
to apply to (access to this pointer that in impossible if the method is declared
as const)
Apncpp
class Date
{
private:
static int x;
public:
static const int& GetX() const;
int Datezzx = 100;
static const int& Date::GetX() const
{ x = 9;
return x;
}
void main()
{
Date d;
int x = d.GetX();
} X++,

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
II II O o
Classes (methods) - the const specifier
> This code compiles. “const” specifier refers to the current object/ instance
alone. It does not apply to another instance of a different type (it will only
apply to the instance represented by “this”).
Apncpp
class Date
{
private:
int x;
public:
void ModifyX(Date * d)-
{ d->x = 0;
| }
};
void main()
{
Date d1,d2;
d1.ModifyX(&d2);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:103**************
II ll ' °
Classes (methods) - the const specifier
> This code will NOT compile as a “const” method refers to the current instance
(“this” pointer).
Apncpp
class Date
{
private:
int x;
public:
void ModifyX(Date * d) const
I i
}
};
void main()
{
Date d1,d2;
d1.ModifyX(&d2);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
" II O 0
Classes (methods) - the const specifier
b “const” is part of object type
b A class method/function can not modify a parameters if it is defined as
“const”
Without const specifier With const specifier
class Date class Date
{ {
private: private:
int x; int x;
public: public:
void Inc(); void Inc();
}; };
void Date::Inc() void Date::Inc()
{ {
X++3 x++;
} }
void Increment(Date &d) void Increment(const Date &d)
{ {
d.Inc(); d.Inc();
} }
void main() void main()
{ {
Date d; Date d;
Increment(d); Increment(d);
} }

***************Ending Page***************


***************Beginning Page***************
***************page number:105**************
Classes (data members) - the "const"
specifier
b “const” can be used for data members as well. The following code will not
compile as the const value is not initialized.
Apncpp
class Data
{
const int x;
public:
int GetX() { return x; }
};
void main()
{
Data d;
}—
b To instantiate such a code , a value has to be added in to the const data member
in the class definition (more on this topic in the course related to constructors).
APP-CPD
class Data
{
const int x = 10;
public:
int GetX() { return x; }
};

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
‘\ > “friend” specifier

***************Ending Page***************


***************Beginning Page***************
***************page number:107**************
a ' d v ' '

frien specifier

b For a class a “friend” function is a function that can access methods and data
members that with private modifier define within that class.

b A “friend” function does not belong to the class (in this case to the Date
class). From this point of view access specifier is irrelevant (it doesn’t matter
if the “friend” function is written in the private or the public section)
APP-CPD
class Date
{

int x;
public:
Date(int value) : x(value) {}
void friend PrintDate(Date &d);
1:
void PrintDate(Date &d)
{
printf("X = %d\n", d.x);
}
void main()
{
Date d1(1);
PrintDate(d1);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
“friend” specifier
App.cpp b “friend” specifier can be applied to an
class Date entire class
{
b1, int X; > In this case , all methods from the
pu 1c: .
Date int value : X value) {} “friend” class can access the members
}, H from the original class (e.g. all methods
class Printer from class Printer can access the private
iublicz data from class Data).
void PrintDecimal(Date &d);
void PrintHexazecimal(Date &d);
}s
void Printer::PrintDecimal(Date &d)
{
printf("x = %d\n", d.x);
}
void Printer::PrintHexazecimal(Date &d)
{
printf("x = %x\n", d.x);
}
void main()
{
Date d1(123);
Printer p;
p.PrintDecimal(d1);
p.PrintHexazecimal(d1);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:109**************
“friend” specifier
App.cpp b A method from a class can also be
class Data; declared as friend for a class.
class Modifier . '
E, bu > The declaration must include the exact
U 1 Z o
void SetX(Data & a, int value); method Signature and the return type.
}s
$1855 Data b ln this case, method SetX(Date& , mt)
int X; from class Modifier can access private
int& GetXRef() { return x; }
public: data from class Data.
int GetX return x'
}s
void Modifier::SetX(Data & d, int value)
{
d.GetXRef() = value;
}
void main()
{
Data d;
Modifier m;
m.SetX(d, 16);
printf("%d\n", d.GetX());
}

***************Ending Page***************

 