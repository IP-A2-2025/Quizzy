***************Beginning Page***************
***************page number:1**************
Gavrilut Dragos
0 O P Course 5

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
b Inheritance
> Virtual methods
b How virtual methods are modeled by C++ compiler
S u m m a ry b Covariance
> Abstract classes (Interfaces)
\ b Memory alignment in case of inheritance

***************Ending Page***************


***************Beginning Page***************
***************page number:3**************
“> Inheritance

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
In heri tance
b Inheritance is a process that transfer class proprieties (methods and
members) from one class (often called the base class to another that inherits
the base class - called derived class). The derive class may extend the base
class by adding additional methods and/ or members.
> Such an example will be the class Automobile, where we can define the
following properties:
> Number of doors
> Number of wheels
> Size
b From this class we can derive a particularization of the Automobile class (for
example electrical machines) that besides the properties of the base class
(doors, wheels, size, etc) has its own properties (battery lifetime).

***************Ending Page***************


***************Beginning Page***************
***************page number:5**************
b Inheritance in case of C++ classes can be simple or multiple:
> Simple Inheritance
class <c1ass_name>: <access modifier> <base c1ass> { ... }
> Multiple Inheritance
Multiple
class <c1ass_name>: <access modifier> <base class 1> ,
<access modifier> <base class 2> ,
<access modifier> <base class 3> ,
éaccess modifier> <base class n> ,
{ }
b The access modifier is optional and can be one of the following:
(public / private or protected).
b If it is not specified, the default access modifier is private.

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
b Class “Derived” inherits members and methods from class “Base”. That is why
we can call methods SetX and SetY from an instance of “Derived” class.
Apncpp
class Base
{
public:
int x;
void SetX(int value);
};
class Derived : public Base
{
int y;
public:
void SetY(int value);
};
void main()
{
Derived d;
d.SetX(100);
d.x = 10;
d.SetY(200);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
b The following code will not compile. Class “Derived” inherits class “Base”,
but member “x” from class Base is private (this means that it can not be
accessed in class “Derived”).

APP-CPD
class Base
{
private:
int x;
};
class Derived : public Base
{
int y;
public:
void SetY(int value);
void SetX(int value);
};
VOid Derived::SetX(int value) error C2248: 'Base::x': cannot access private member declared
{ in class 'Base'
} ’ note: see declaration of 'Base::x'
void main() note: see declaration of 'Base'
{
Derived d;
d.SetX(199);
d.SetY(299);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
b The solution for this case is to use the “protected” access modifier. A
protected member is a member that can be access by classes that inherits
current class, but it can not be accessed from outside the class.

APP-CPD
class Base
int x;
};
class Derived : public Base
{
int y;
public:
void SetY(int value);
void SetX(int value);
};
void Derived::SetX(int value)
{
x = value;
}
void main()
{
Derived d;
d.SetX(106);
d.SetY(206);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:9**************
b The code below will not compile. “x” is declared as protected - this means
that it can be accessed in method SetX from a derived class, but it can not be
accessed outside it’s scope (class).

APP-CPD
class Base
{
protected:
int x;
};
class Derived : public Base
{
int y;
public:
void SetY(int value);
void SetX(int value);
};
void Derived::SetX(int value)
{
x = value;
}
void main()
{
DeriVEd d5 _ error C2248: 'Base::x': cannot access protected member declared
H'sefxlég? ’ in class 'Base'
} —'X _ note: see declaration of 'Base::x'
note: see declaration of 'Base'

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
In heri tance
b The following table shows if a member with a specific access modifier can be
access and in what conditions:
Access In the In a Outside Friend Friend
modifier same class derived it's function in the function in the
class scope base class derived class
public Yes Yes Yes Yes Yes
protected Yes Yes No Yes Yes
private Yes No No Yes No

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
b The code below will not compile. “x” is a private member of “Base” therefor
a friend function defined in “Derived” class can not access it.
APP-CPD
class Base
int x;
};
class Derived : public Base
{
int y;
public:
void SetY(int value);
void friend SetX(Derived &d);
};
void SetX(Derived &d)
{
}
void main()
{
Derived d;
SetX(d);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
b The solution is to change the access modifier of data member “x” from class
“Base” from private to protected.
APP-CPD
class Base
int x;
};
class Derived : public Base
{
int y;
public:
void SetY(int value);
void friend SetX(Derived &d);
};
void SetX(Derived &d)
{
d.x = 100;
}
void main()
{
Derived d;
SetX(d);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
b Be careful where you define the friend function. In the example below SetX
friend function is declared in the “Derived” class. This means that it can
access methods and data members from instances of “Derived” class and not
other classes (e.g. Base class). The code will not compile.

Apncpp
class Base
{
private:
int x;
};
class Derived : public Base
{
int y;
public:
};
void SetX(Base &d)
{
d.x = 100;
}
void main()
{
Derived d;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
b This code will work properly because the friend function is defined in class
“Base”
APP-CPD
class Base
{
private:
int x;
public:
};
class Derived : public Base
{
int y;
public:
void SetY(int value);
};
void SetX(Base &d)
{
d.x = 100;
}
void main()
{
Derived d;
}

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
b Access modifiers can also be applied to the inheritance relation.
b As a result, the members from the base class change their original access
modifier in the derived class.
‘z. ln this case, because “x” is public in the “Base”
App.cpp class, and the inheritance relation is also public,
class Base “x” will be public as well in the “Derived” class
{ b1. and will be accessible from outside the class
pu 1c:
MW x; scope.
};
class Derived z-Base
{
int y;
public:
void SetY(int value) { ... }
};
void main()
{
Derived d;
d.x = 100;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
b Access modifiers can also be applied to the inheritance relation.
b As a result, the members from the base class change their original access
modifier in the derived class.
‘z. This code will not compile. “x” is indeed public
App.cpp in class “Base”, but since the inherit relation
class Base between class “Base” and class “Derived” is
{ b1. _ private, “x” will change its access modifier from
p“ “int X; public to private in class Derived and will not be
}; accessible from outside its scope.
class Derived z-Base
{ int _ ‘z. However, if we are to create an instance of type
public; y’ “Base” we will be able to access “x” for that
}_ void Semi“ value) { } instance outside its scope.
void main()
{ o
l- -q q’
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:17**************
In heri tance
b The rules that show how an access modifier is change if we change the access
modifier of the inheritance relation are as follows:
Access modifier used for the 9 public private protected
inheritance relation
Access modifier used for a data
member or method
private > protected > public

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
b Let’s consider the following case:
A .c
pp pp Output

class A

gublit ctor: A is called !
A() { print-F("ctor: A is called !\n"); } Ctor: B iS called !
~A() { printf("dtor: A is called !\n"); } . .

}; dtor. BIS called l

glass B= Public A dtor: A is called l

public:
B() { printf("ctor: B is called !\n"); }
~B() { printf("dtor: B is called !\n"); }

};

int main()

{
B b;
return 0;

}—

***************Ending Page***************


***************Beginning Page***************
***************page number:19**************
b Let’s consider the following case:
APP-CPD
class A OUtpLIt
{
public: push ebp
A() { printf("ctor: A is called !}n"2; } mov ebp,esp
}. ~A() { pr1ntf( dtor. A lS called .\n ), } sub esp,44h
Class B: pUblic A mov dword ptr [this],ecx
gublir- mov ecx,dword ptr [this]
B() { printf("ctor: B is called !\n"); } call A==A (9D514B5h)
~B() { print+("dtor: B is called !\n"); }
}; push offset string "ctor: B is called !\n"
int main() call _printf (9DBl4A6h)
{ add esp,4
B b3 mov eax,dword ptr [this]
return 6;
} mov esp,ebp
pop ebp
ret
b The cod in YELLOW reflects the
execution of the base constructor.

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
> Let’s consider the following case:
APP'CPP
A Output
{ z ctor: B is called l
A() { print-F("ctor: A is called !\n"); } ctor: Ais called I
~A() { printf("dtor: A is called !\n"); } _
}; ctor: C is called !
{ B dtor: C is called l
B(;{ _ w" t B _ 11 d |\ ..) } dtor: Ais called !
pr‘1n C or: 15 ca e . n ; .
~B() { print-F("dtor: B is called !\n"); } dtor: B IS called l
};
c: B, A
{ —
C(S { printf("ctor: C is called !\n"); }
~C() { printf("dtor: C is called !\n"); }
};
main() {
C c;
0;
}—
> In case of multiple inheritance, the order of base classes is used when the
constructor is called (in this case - first class B, then class A and finally class C)

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
In heri tance
b Let’s consider the following case:
APP~CPP
A Output
{ z ctor: B is called l
A(2){{print:1(c2c§:r: A is calilladd!\r\1"); }} ctor: A is called !
~A Pin " or: A is ca e ! n" ; _
}; p dtor: A is called l
{ B dtor: B is called l
B(; { printf("ctor: B is called !\n"); }
~B() { printf("dtor: B is called !\n"); }
}’ c: B, A
{ ~
}; .
main() {
C c;
e;
}—
> If no constructor is defined in class C, but there are at least one constructor
defined in one of the class from which C is derived from, the compiler will
create a default constructor that calls the constructor of class B followed by
the constructor of class A.

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
b Let’s consider the following case:
APP-CPD
class A
{
public:
A(int x) { printf("ctor: A is called !\n"); }
~A() { printf("dtor: A is called !\n"); }
};
class B
{
public:
B() { printf("ctor: B is called !\n"); }
~B() { printf("dtor: B is called !\n"); }
};
class C: public B, public A
{
PUbliCI error C2280: 'C::C(void)': attempting to reference a deleted function
15 0 note: compiler has generated 'C::C' here
1% note: 'C::C(void)': function was implicitly deleted because a base class
'A' has either no appropriate default constructor or overload resolution
} ’ was ambiguous
note: see declaration of 'A'
b This code will fail, as there is no explicit call to A::A(int) constructor.

***************Ending Page***************


***************Beginning Page***************
***************page number:23**************
b Let’s consider the following case:
APP-CPD
class A OUtPUt
gublic: ctor: B is called l
A(int x) { print-F("ctor: A is called !\n"); } ctor: A is called I
~A() { printf("dtor: A is called !\n"); } _
}; ctor: C is called !
‘{ilass B dtor: C is called l
publliaz; { _ w" t B _ 11 d |\ ..) } dtor: Ais called l
prin c or: is ca e . n ; .
~B() { print-F("dtor: B is called !\n"); } dtor: B IS called l
};
class C: public B, public A
{ —
public:
C() :!{ print-F("ctor: C is called !\n"); }
~C() pr1n ("dtor: C is called !\n"); }
};
int main() {
C c;
return 0;
}
b The solution is to explicitly call the constructor of A in the member in' 'alizer
list for C::C()

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
b Let’s consider the following case:
Appﬁpp
A Output
{ z ctor: B is called l
A( x) { print-F("ctor: A is called !\n"); } ctor: A is called I
~A() { printf("dtor: A is called !\n"); } _
}; ctor: C is called !
{ B dtor: C is called l
B(;{ . w" t B _ 11 d |\ ..) } dtor: Ais called l
prin c or: is ca e . n ; .
~B() { print-F("dtor: B is called !\n"); } dtor: B IS called l
};
c: B, A
{ —
C(S :—[ print-F("ctor: C is called !\n"); }
~C() { printf("dtor: C is called !\n"); }
};
main() {
C c;
9;
}

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
b Let’s consider the following case:
APP-CPD
class A { OUtPUt
public: 0 .
A(int x) { print-F("ctor: A is called !\n"); } Ctor' B 'IS called l
~A() { print-F("dtor: A is called !\n"); } ctor: A is called I
}; .
class B { ctor: C lS called l
public: , -
B() { print-F("ctor: B is called !\n"); } Ctor‘ D IS called !
~B() { print-F("dtor: B is called !\n"); } dtor: D ‘is called l
}; .
class c { dtor: C lS called l
public: . '
C(bool n) { print-F("ctor: C is called !\n"); } dtor' A {S called l
~C<> { printﬂwtor: c is called on"): } dtor: B lS called l
};
class D: public B, public A
{
C c;
public:
D()—{ print-F("ctor‘: D is called !\n"); }
~D() { printf("dtor: D is called !\n"); }
};
int main() {
D d;
return 0;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
b Let’s consider the followin case: Output
A Q I
pp cpp ctor: B IS called !
struct A { _ .
A(int x) { print-F("ctor: A is called !\n"); } Ctor' A IS called l
~A() { print-F("dtor: A is called !\n"); } ctor: C is called l
}3 .
struct B { ctor: D lS called l
B() { print-F("ctor: B is called !\n"); } . . . . .
~B() { print-F("dtor: B is called !\n"); } __ V1 1.5 lmthlllZQd
If; t c { -- v2 IS mltlallzed
s ruc _
C(bool n) { pr-int-F("ctor: C is called !\n"); } Ctor: E 'IS called !
}. ~C() { pr-int-F("dtor: C is called !\n"); } dtor: E is called l
struc: D{ ) { H 11 d |\ ) } dtor: D is called l
D bool n pr-int "ctor: D is ca e . n" ; . .
~D() { pr-int-F("dtor: D is called !\n"); } dtOl‘. C 15 called l
}3 ' ' l
class E: public B, public A { dtor' A 1_S called °
c c; dtor: B lS called l
D d‘
public:
E(): d(true), A(100), c(true), B(), v2(166), v1(20) { printf("ct0r: E is called !\n"); }
~E() { printf("dtor: E is called !\n"); }
};
void main() {
E e;
}

***************Ending Page***************


***************Beginning Page***************
***************page number:27**************
> When inheriting from multiple classes, the general rule for calling constructors
and destructors is as follows:
1. First all of the constructors from the base classes are called in the order of their
inheriting definition (left-to-right)
2. All of the constructors from data members are called (again in their definition
order — top-to-bottom)
3. Then the constructor initialization value for data members (basic types,
references, constants) are used in the order they are defined in that class.
4. Finally, the code of the constructor of the class is called.
> Destructors are called in a reverse way (starting from point 4 to point 1).
Tested with:
> cl.exe: 19.16.27030.1
> Params: /permissive- /GS- /analyze- /W3 /Zc:wchar_t /Z| /Gm- /Od /sdl
/Fd"Debug\vc141.pdb" /Zc:inline /fp:precise /D "WIN32" /D "_DEBUG" /D "_CONSO ' /D
"_UNICODE" /D "UNICODE" /errorReport:prompt /WX- /Zc:forScope /RTCu /arc . A32 /Gd
/Oy- /MDd /FC /Fa"Debug\" /nologo /Fo"Debug\" /Fp"Debug\Testhp.pch"
/diagnostics:classic

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
‘\ > Virtual methods

***************Ending Page***************


***************Beginning Page***************
***************page number:29**************
App.cpp a‘ This code prints “B” on the screen. From the
class A inheritance point of view, both A and B class
imbue: have the same method called Set
int a1, a2, a3; . . . . -
void Set() { print-F("A"); } ‘z. In this case it is said that class B hides
};
class B: public A method Set from class A
{
public:
int b1, b2;
void Set() { printf("B"); }
};
void main()
{
B b;
b.5et();
}—

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
App.cpp a‘ In this case, the code will print “A” on the
class A screen, because we are using a pointer of type
{ *
public: A

int a1, a2, a3; , . “ ,, . .

void Set() { print-F("A"); } ‘z. However, in reality, a pointer pomts to an
Ziass B: public A object of type B 9 so the expected result
{ . should be that the product will print “B” and
pub11c: “ ,,

int b1, b2; HOt A

void Set() { pr'int-F("B"); } _ .
};_ _ ‘z. So what can we do to change this behaVIor?
v01d ma1n()
{

B b'

A* a = &b;
}

***************Ending Page***************


***************Beginning Page***************
***************page number:31**************
App.cpp .;. The solution is to use “virtual” ke word in
y
class A from of a method - definition
{
pumcint a1 ‘z. If we do this, the program will print “B”
'dSt 't-F"A"; . .. . -
h "1" “a "°1 e O { pm" ( ) } .;. ln this case, it is said that class B overrides
$1855 B= Publlc A method Set from class A
p b1'c: . .
u 1 int b1, b2; .;. Usmg Virtual keyword makes a method to
} ‘mid “to { Printﬂw"); } be part of the instance l
void main()
{
B b;
A* a = &b;
a->Set();
}

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Virtual methods

Virtual methods can be used for:

b Polymorphism

b Memory deallocation (virtual destructor)
b Anti-debugging techniques

***************Ending Page***************


***************Beginning Page***************
***************page number:33**************
Polymorphism = the ability to access instances of different classes through the
same interface. ln particular to C++, this translates into the ability to
automatically convert (cast) a pointer to a certain class to its base class.
App-1.cpp ‘t. After the execution this code will
class Figure { print on the screen “Circle” and
public: virtual void Draw() { print-F("Figure"); } “Square”
}; °
class Circle: public Figure { .
public: void Draw() { print-F(“Circle"); } ‘3 If we haven’t uses Vlrtual
}; . .
class Square: public Figure { specifier, the program would have
public: void Draw() { print-F(“Square"); } printed “FigUI'E” thce l
};
void main()
{
Figure *f[2];
{[0] = new Circle();
{[1] = new Square();
for (int index = 0;index<2;index++)
f[index]->Draw();
}

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
. . . Function 1
In practice, in many cases, polymorphism F mtbnz
. . U 1
is used to create a plugm or an
add-on for an existing software. ,
Function n
Interface
Function 1 F“"°“°"1
, Function 2
_ ‘ Function 2
Application ,
Function 3 Function n
Function n
Function 1
Function 2
Function n

***************Ending Page***************


***************Beginning Page***************
***************page number:35**************
In particular for C++ language, virtual specifier can be used as a specifier for
destructors.
Let’s analyze the following case:
App-1.cpp ‘z. After this code gets executed,
class Figure { the fOllOWing teXtS Will. be
public: virtual void Draw() { printf("Figure"); } ' .
public: ~Figure() { print-F("De1ete Figure\n"); } printed On the SCI-Fen‘
}; Delete Figure
class Circle: public Figure { .
public: void Draw() { print-F(“Circle"); } “Delete Flgure”°
public: ~Circle() { printf("Delete Circle"); } .
}; ‘z. What would happen if both
class Square: public Figure { C. l d S I.
public: void Draw() { print-F(“Square"); } "'C e an quare C asses
}. public: ~Square() { print-F("Delete Square"); } allocate some memory?
void main() {
Figure *f[2];
{[0] = new Circle();
{[1] = new Square();
for (int index = 0;index<2;index++)
delete (f[index]);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
In particular for C++ language, virtual specifier can be used as a specifier for
destructors.
Let’s analyze the following case:
App-1.cpp ‘z. The solution is to declare de
class Figure { destructor as virtual. As a
public: ' - void Draw() { printf("Figure"); }
publicﬂﬁigurﬂ) { printf("De1ete Figure\n"); } reSUlt’ the deS'trUCtOr for
}; actual class Will be called,
class Circle: public Figure {
public: void Draw() { print-F(“Circle"); } fallowed by the deStrUCtor Of
}_ public: ~Circle() { print-F("Delete Circle"); } the base Class
class Square: public Figure { . . .
public: void Draw() { print-F(“Square"); } v The fouow-lng teXt Wlu be
public: ~Square() { print-F("Delete Square"); } printed:
}; .
void main() { Delete Circle
Figure *f[2]; -
-F[0] = new Circle(); Delete Flgure
H11 = "e" Squat“); Delete Square
for (int index = 0;index<2;index++) _
delete (-F[index]); Delete Figure
}

***************Ending Page***************


***************Beginning Page***************
***************page number:37**************
Let’s analyze the following case:

APP'1-CPP

class A

{

public:
virtual bool Odd(int x) { return x % 2 == 0; }

};

class B : public A

{

public:
virtual bool Odd(char x) { return x % 3 == 0; }

};

int main() {

A* a = new B();
printf("%d\n", a->Odd(3));
return 0;

}

b Odd is a virtual function - however, class B override it (as it uses
char as the first parameter instead of int). As a result, class B will have 2
Odd methods and a->Odd will call the one with an int parameter. U a
execution, value false (0) is written to the screen.

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Let's analyze the following case:

APP'1-CPP

class A

{

pub ' '

};

{

pub ' '

};

int main() {

A* a = new B();
printf("%d\n", a->Odd(3));
return 0;

}

b Odd is a virtual function - however, class B does not override it (as it uses
char as the first parameter instead of int). As a result, class B will have 2
Odd methods and a->Odd will call the one with an int parameter. U e
execution, value false (0) is written to the screen.

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
Virtual methods

Let’s analyze the following case:

APP'1-CPP

class A

{

public:
virtual bool Odd(int x) { return x % 2 == 0; }

{

public:
virtual bool Odd(c ar x) override { return x % 3 == 0; }

};

int main() { /
A* a = new B();
printf("%d\n", a->Odd(3));
return 0;

}

b Assuming that , in reality, the intent was to override Odd method, then one
way of making sure that this kind of mistakes will not happen is to use th
override keyword (added with C++11 standard). As a result, this code ill not
compile as it is expected that method Odd to have the same signa re ll!

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Let's analyze the following case:
App-1.cpp
class A
{
public:
virtual bool Odd(int x) { return x % 2 == 0; }
};
class B : public A
{
public:
virtual bool Odd(int x) -{ return x % 3 == 0; }
};
int main() {
A* a = new B();
printf("%d\n", a->Odd(3));
return 0;
}
b Now the code compiles and prints “1” (true) on the screen.

***************Ending Page***************


***************Beginning Page***************
***************page number:41**************
Let’s consider the following code:
APP'1-CPP
struct A {
virtual bool Odd(int x) = 0;
};
struct B : public A {
virtual bool Odd(int x) { return x % 2 == 0; }
};
struct C : public B {
virtual bool Odd(int x) { return x % 3 == 0; }
}s
int main() {
A* a = new C();
printf("%d\n", a->Odd(3));
return 6;
}—
> This program runs and prints value 1 (True) 9 even if 3 is not an odd number.
> The reason why this could happen is that method Odd was overridden in class C
(keep in mind that we have used struct in this example to show that the behavior
is identical to the one from class).
b What can we do if we want to make sure that Odd method from class B not be
overridden ?

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Let’s consider the following code:
APP'1-CPP
struct A {
virtual bool Odd(int x) = 0;
};
struct B : public A {
virtual bool Odd(int x) final { return x % 2 == 9; }
};
struct C : public B {
virtual bool Odd(int x) { return x % 3 == 0; }
}s
int mainO { \I]
A* a = new C();
printf("%d\n", a->Odd(3));
return 6;
}—
b The solution is to use the specifier final after the declaration of a virtual
function. This tells the compiler that other classes that inherit current class
can not override that method.

***************Ending Page***************


***************Beginning Page***************
***************page number:43**************
Let’s consider the following code:
APP'1-CPP
struct A {
virtual bool Odd(int x) = 0;
};
struct B : public A {
virtual bool Odd(int x) override final { return x % 2 == 9; }
};
struct C : public B {
};
int main() {
A* a = new C();
printf("%d\n", a->Odd(3));
return 6;
}—
b It is possible to use both override and final specifiers when declaring a
method.
b In this case their meaning is:
> override -) The purpose of this method is to override the existing method from
the base class (in this case, it overrides A::Odd)
> final -) Other classes that might inherit class B can not override this od.

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Let’s consider the following code:
APP'1-CPP
struct A {
virtual bool Odd(int x) = 0;
};
struct B final : public A
{
virtual bool Odd(int x) override { return x % 2 == 9; }
};
struct C : public B {
}s
int mainO { C]
A* a = new C();
printf("%d\n", a->Odd(3));
return 6;
}—
b final specifier can also be used directly in the class/struct definition. In this
case , it’s meaning is that inheritance from class B is NOT possible.
b This code will not compile !

***************Ending Page***************


***************Beginning Page***************
***************page number:45**************
How virtual methods
are modeled by C++
> compiler

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
How Virtual methods are modeled by
C++ compiler
‘z. Let's analyze the following two programs. Their only difference is the usage
of virtual in case of APP-2.
APP'1-CPP APP'2~CPP
class A class A
{ {
public: public:
int a1, a2, a3; int a1 a2, a3;
void Set() { print-F("A"); } -void Set() { print-F("A"); }
}; };
void main() void main()
{ printf("%d",sizeof(A)); { printf("%d",sizeof(A));
} }
‘z. When executed, APP-1 will print “12” and App-2 will print “16” (for x86
architecture). If we run the same App-2 on x64 it will print “24”
‘a Why ?

***************Ending Page***************


***************Beginning Page***************
***************page number:47**************
How Virtual methods are modeled by
C++ com pi ler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class.
App-1 .cpp
class A
{
public:
int a1, a2, a3;
}. void Set() { printf("A"); }
void main()
{
A a;
}—

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
How Virtual methods are modeled by
C++ compiler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class.
App-1 .cpp
class A
{ b1. .
Pu 1c:int a1, a2, a3; A::Set()
}. void Set() { printf("A"); }
void main()
{
A a;
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:49**************
How Virtual methods are modeled by
C++ compiler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class.
App-1 .cpp
class A
{ b1. .
Pu 1c:int a1, a2, a3; A::Set()
}. void Set() { printf("A"); }
\{Ioid main() main()
A a;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
How Virtual methods are modeled by
C++ com pi ler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class.
App-1 .cpp
class A
{ b1. .
Pu 1c:int a1, a2, a3; A::Set()
}. void Set() { printf("A"); }
\{Ioid main() main()
A a;
<Stack>

***************Ending Page***************


***************Beginning Page***************
***************page number:51**************
How Virtual methods are modeled by
C++ com pi ler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class.
App-mp
class A
{ b1. .
PU 1c:int a1, a2, a3; AIISGU) a.a3
}. void Set() { print-F("A"); } _“____ a.az
void main() ——‘ x
{ main() a.a1
-) ESP/RSP

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
How Virtual methods are modeled by
C++ com pi ler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class.
App-um»
class A
Pu 1c:int a1 a2, a3; AIISetO ...
—void Set() { printf("A"); }
};
void main() m _n a'a3
{ m y a] 0 a.a2
}— am
“pr
-) ESP/RSP
/

***************Ending Page***************


***************Beginning Page***************
***************page number:53**************
How Virtual methods are modeled by
C++ compiler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class. classA virtual
App-2.cpp
class A
{ b1_ ptr to A::Set
p“ “in a , a ’ a; A::Set()
}. vittuil vczaid 3 () { printf("A"); } RTTI .
void () main ) 8.63
{ A a; ( a.aZ
}— / a.a1
<Stack> a.vfptr
-) ESP/RSP
/

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
How Virtual methods are modeled by
C++ compiler
‘z. Using the virtual keyword will force the compiler to modify the structure of
any class by adding another data member (a pointer to a list of pointers to a
function). This pointer is called vfptr and if added is the first pointer in the
class. classA virtual
APP-Z-cpp
class A
{ b1_ M ptr to A::Set
p“ “in a , a ’ a; A::Set()
}. vittuil vczaid 3 () { printf("A"); } RTTI
void () main ) 8.63
{ A a; ( a.aZ
}— / a.a1
<Stack> a.vfptr
-) ESP/RSP
/

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
How Virtual methods are modeled by
C++ com pi ler
‘z. Whenever a virtual method is added, the compiler needs to be certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. If no constructor is present, the
default one will be created autom i
APP-CPD
class A A a;
{ b1, . a.x = 1;
pu “int X, y; mov dword ptr [ebp-12],1
int Calcul() { return x+y; } a.y = 2;
}s _ mov dword ptr [ebp-8],2
void ma1n() —
{
A a;
a.x = 1;
a.y = 2;
}—
4' In this case, there no default constructor defined and no need for the
compiler to provide one automatically (e.g. virtual methods, const or
reference data members, etc).

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
How Virtual methods are modeled by
C++ com pi ler
e‘ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. If no constructor is present, the
default one will be created autom i
APP-CPD
class A A a;
{ . _ lea ecx, [ebp-16]
putil-Mint X, y; '4
int Calcul() { return x+y; a.x = 1;
A0 {X = y = 9; } mov dword ptr [ebp-16],1
iéid main() a'y = 2;
{ mov dwond ptr [ebp-12],2
2.3;: 1;
a.y = 2;
}—
‘z. In this case, there is a constructor that will be called when “a” is created.

***************Ending Page***************


***************Beginning Page***************
***************page number:57**************
How Virtual methods are modeled by
C++ com pi ler
e‘ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. lf no constructor is present, the
default one will be created automatically
App.cpp Disasm (A::A)
class A push ebp
{ublic' mov ebp,esp
p :i.nt X, y; mov dword ptr [ebp-8],ecx // EBP-8=this
'- - r'n x+y; } mov eax,dword ptn [ebp-8]
. mov dword ptr [eax+4],0 // this->y = 9
‘kid main() mov ecx,dwor‘d ptr [ebp-8]
{ mov dword ptr [ecx],0 // this->x = 9
A a; mov eax,dwor‘d ptr [ebp-8]
j‘; Z 1 pop ebp
} ' ’ Pet
‘z. In this case, there is a default constructor and the code from the default
constructor will be called when object “a” is created.

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
How Virtual methods are modeled by
C++ com pi ler
e‘ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. lf no constructor is present, the
default one will be created automatically
class A A a;
{ . _ lea ecx, [ebp-ZG]
lebllcint x ;
dint Calcul() {retu ' +y;} a.x = 1;
}5 _ mov dword ptr [ebp-16],1
void ma1n() a.y = 2;
{ mov dwond ptr [ebp-12],2
}—
‘z. In this case, even if no constructor is defined, the compiler will automatically
create one to initialize the vfptr pointer (this is required because Calcul is a
virtual method).

***************Ending Page***************


***************Beginning Page***************
***************page number:59**************
Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. If no constructor is present, the
defauu Wm be created womb
class
{ _
pmﬂic; lea ecx ebp 29]
int ;
int Calcul return x+ '
},' . _
void main() Dlsasm ebp 161,1
{ A ebp-121,2
.X = I —
-y =3 mov dwond ptP [ebp-8],ecx
}— mov eax,dwor‘d ptr‘ [ebp-8]
mov dwond ptP [eax], A-virtual-fnc-list
mov eax,dwond ptr [ebp-8]

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
How Virtual methods are modeled by
C++ com pi ler
e‘ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. lf no constructor is present, the
default one will be created automatically
class A A a;
{hr . lea ecx eb-20
ﬂint Calcul() {return x+y;} a.x = 1;
A0 {X = y = 9; } mov dword ptr [ebp-16],1
iéid main() a'y = 2;
{ mov dwond ptr [ebp-12],2
2.3;: 1;
a.y = 2;
}—
‘z. If a constructor exists, it will be modified (in a similar manner to the change
that is done for const/ references data members).

***************Ending Page***************


***************Beginning Page***************
***************page number:61**************
Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. If no constructor is present, the
default one will be created autom ' -
—
class
{
public:
int , g
vir 7 '- , ) {return x+y;}
}’_ AO- mov eax,ccwor‘ p r‘ en-p-
void main() mov dword ptr‘ [eax+8],0
{ mov ecx,dwor‘d ptr [ebp-8]
A X = 1.
:y = 2; mov eax,dwor‘d tr‘ eb-8
}
The code colored in is the
code added by the compiler to —
initialize the vfptr pointer.

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
How Virtual methods are modeled by
C++ com pi ler
‘z. The code added by the compiler to initialize the vfptr pointer will be added
for every defined constructor.
APP-CPD
class A
{
public:
int x, y;
virtual int Calcul() {return x+y;}
A0 { x = y = 0; }
}. A(const A& a) { x = a.x; y = a.y; }
void main() /
{
A a“
\ }

***************Ending Page***************


***************Beginning Page***************
***************page number:63**************
How V1 rtual methods are modeled by
C++ com p1 ler
‘z. However, in case of the assignment operator the compiler wi ll not add any
special code to initialize the vfptr pointer.
APP-CPP
class A
{
public:
int x, y;
virtual int Calcul() {return x+y;}
A0 { x = y = 0; }
A& operator = (A &a) { x = a.x; y = a.y; return *this;}
};
void main()
{
A a;
A a2’
\ }

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
How Virtual methods are modeled by
C++ compiler
e‘ A virtual method is called using its reference from the vfptr table only if the
object is a pointer.
class A A a;
{ . _ lea ecx, [a]
pUbhcint X, y; call A: :A
virtual int Calcul() {return x+y;} a.x = 1;
A0 { X = y = 93 } mov dword ptr [ebp-lGh],1
h. . a.y = 2'
v01d ma1n() ,
{ mov dword ptr [ebp-0Ch],2
A a; a.Calcul '
a.xi1€ lea eCX, [a]
7 call A: :Calcul
}
‘z. In this case, even if Calcul method is virtual as it called directly with an
object , the compiler will not generate code that will find out its address
from the vfptr table (it will use the method Calcul exact address).

***************Ending Page***************


***************Beginning Page***************
***************page number:65**************
Avirtual method is called using its reference from the vfptr table only if the
object is a pointer.
class
{
public: lea ecx, [a]
int ’ 3 call A: :A
virtual int Ca1cu1() {return x+y;}
}_ A0 { X = y = 93 } mov dword ptr [ebp-19h],1
vdid main()
{ mov dword ptr [ebp-GCh],2
A
‘X j :3 lea eax, [a]
Alya; =’&a. mov dword ptr [a2],eax
} mov eax,dword ptr [82] EAX = address of a2
mov edsdword ptr [eax] EDX = address of VFPTR
, , mov ecx,dw0rd tr a2 _ -
In thls case vfptr lS used to p [ 1 EAX - address Of f1rst
. mov eax,dword ptr [edx] .
f1nd out Calcul method address. call eax functlon from VFPTR

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
How virtual methods are modeled by
C++ compiler
App.cpp Pseudo C/C++ Code
class A struct A_Virtua1Functions {
[{Jubﬁ-F
int x'
a cul() {return 9;}
‘ X = 0; }
};
void main()
{
A a;
a.X = 1;
a.y = 2;
A* a2 = &a;
a2->Ca1cu1();
\ }
+

***************Ending Page***************


***************Beginning Page***************
***************page number:67**************
How virtual methods are modeled by
C++ compiler
App.cpp Pseudo C/C++ Code
publicz 3
:2:t:;1— eturn 9;}
A0 {X = s
};
void main()
{
A a;
a.X = 1;
a.y = 2;
A* a2 = &a;
a2->Ca1cu1();
\ }
+

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
How V1 rtual methods are modeled by
C++ com pller
App.cpp Pseudo C/C++ Code
class A struct A_Virtua1Functions {
public: '
int x; class A {
v1r ua 1nt Calcul() {retur' ~ public:
A0 {X = 0s }
}; int x;
void main()
{
A a;
a.X = 1;
a.y = 2;
A* a2 = &a;
a2->Calcul();
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:69**************
How Vlrtual methods are modeled by
C++ compller
App.cpp Pseudo C/C++ Code
class A struct A_Virtua1Functions {
{ int (*Calcul) ()3
public: };
in x' class A {
' ' return 9;} ublic:
A<> { X = a; }
}s 1n X;
void main()
{
A a;
a.X = 1;
a.y = 2;
A* a2 = &a;
a2->Ca1cu1();
}

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
How Vlrtual methods are modeled by
C++ compller
App.cpp Pseudo C/C++ Code
class A struct A_VirtualFunctions {
{ int (*Calcul) ()3
public: };
int x; class A {
virtual public:
A() { x = a; §_ViriualFunctions *vatr;
{ A a;
a.X = 1;
a.y = 2;
A* a2 = &a;
a2->Calcul();
i }
+

***************Ending Page***************


***************Beginning Page***************
***************page number:71**************
C++ com p1 ler
App.cpp Pseudo C/C++ Code
class A struct A_VirtualFunctions {
{ int (*Calcul) ()3
public: };
‘l ‘- class A {
'nt Calcul() {return 9;} public:
‘ x = :- } A_VirtualFunctions *vatr;
}; int x;
void main() int A_Ca1cu1() { return 0; }
{
A a;
a.X = 1;
a.y = 2;
A* a2 = &a;
a2->Calcul(); A_VirtualFunctions Globa1_A_vatr;
} Globa1_A_vatr.Ca1cu1 = &A::A_Ca1cu1;

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
C++ com pller
App.cpp Pseudo C/C++ Code
class A struct A_Virtua1Functions {
{ int (*Calcul) ()3
public: };
int x; class A {
' . ‘I . cul() {return 9;} public:
A() { x = 0; } A_Virtua1Functions *vatr;
}; int x;
void main() int A Calcul return 0'
{ A() {
A a;
a.x = 1; x = 0;
a-y = 2s }
A* a2 = &a; ;
a2->Calcul(); A_Virtua1Functions Globa1_A_vatr;
} Globa1_A_vatr.Ca1cu1 = &A::A_Ca1cu1;

***************Ending Page***************


***************Beginning Page***************
***************page number:73**************
C++ com pller
App.cpp Pseudo C/C++ Code
class A struct A_VirtualFunctions {
{ int (*Calcul) ()3
public: };
'- " class A {
'11: Calcul() {return 9;} public:
A x = a, A_VirtualFunctions *vatr;
}; int x;
void main() int A_Ca1cu1() { return 0; }
{ A
a.X = 1; ' = ,
a-y = 2s }
A* a2 = &a; };
a2->Calcul(); A_VirtualFunctions Globa1_A_vatr;
} Globa1_A_vatr.Ca1cu1 = &A::A_Ca1cu1;

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
C++ com pller
App.cpp Pseudo C/C++ Code
class A struct A_VirtualFunctions {
{ int (*Calcul) ()3
public: };
int x; class A {
virtual int Calcul() {return 9;} public:
A() { x = 0; } A_VirtualFunctions *vatr;
' int x;
void main() int A_Calcul() { return 0; }
{ A() {
A a; vatr = &Global_A_vatr;
a.x = 1; x = 0;
a-y = 2s }
A* a2 = &a; };
a2->Calcul 3 A_VirtualFunctions Global_A_vatr;
} Globa1_A_vatr.Calcul = &A::A_Calcul;
void main()
{
A a;
a.x = 1;
a.y = 2;
A* a2 = &a;
}

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
C++ com pller
App.cpp Pseudo C/C++ Code
class A struct A_VirtualFunctions {
{ int (*Calcul) ()3
public: };
int x; class A {
virtual int Calcul() {return 9;} public:
A() { x = 0; } A_VirtualFunctions *vatr;
}; int x;
void main() int A_Calcul() { return 0; }
{ A() {
A a; vatr = &Global_A_vatr;
a.x = 1; x = 0;
a-y = 2s }
* - = 1- };
A_VirtualFunctions Global_A_v-FPtr;
} Globa1_A_vatr.Calcul = &A::A_Calcul;
void main()
{
A a;
a.x = 1;
a.y = 2;

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
How V1 rtual methods are modeled by
C++ com pi ler
‘z. Keep in mind the vfptr is just a pointer. As such, it can be changed during executio

APP-CPP ‘z. This code will print “AA” on the
glass A screen. First time when method
public: Print is called directly

$233211 void Print() { print-F("A"); } (“G'Printo n), second time When
:iass B method Print is called using the
{ vfptr pointer (“aZ->Print()”)
public:

:ZEtzal void Print() { printf(“B"); }
};
void main()
{

A a;

B b;

A* a2 = &a;

a.Print();

a2->Print();

}—

***************Ending Page***************


***************Beginning Page***************
***************page number:77**************
How V1 rtual methods are modeled by
C++ com pi ler
‘z. Keep in mind the vfptr is just a pointer. As such, it can be changed during executio
APP-CPP ‘z. This code will however print “AB”.
glass A Using memcpy function allow us to
public: overwrite the actual vfptr-ul of
$233211 void Print() { print-F("A"); } ObjeCt “a” With the one from
:iass B object “b”. As method Print has
{ . the same signature in both classes
pubhcint X; (A and B) the result will be “AB”
virtual void Print() { printf(“B"); }
};
void main()
{
A a;
a.Pnint(;;’
a2->Print();
}—

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
How V1 rtual methods are modeled by
C++ com pi ler
‘z. Keep in mind the vfptr is just a pointer. As such, it can be changed during executio
APP-CPP ‘z. Every constructor called will set
glass A the vfptr to its correct value. In
public: this case , “A a3=(*aZ)” will call
‘1123321 void Prim) { printﬂuA"); } the copy constructor for class A
:iass B and will set the vfptr for local
{ variable a3 correctly.
public:
‘112L321 void Print() { printﬂuB"); } a‘ As a result, this codewﬂl print A
};. _ on the screen , even if “aZ” has
1/01d ma1n() the vfptr of “b”
A a;
B b;
memcpy(&a, &b, sizeof(void*));
A* a2 = &a;
A a3 = (*a2);
A *a4 = &a3;
a4->Print();
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:79**************
How Virtual methods are modeled by
C++ com pi ler
‘z. A virtual function can be overwritten in the derived class.
App.cpp ‘z. In this case, “x” will be 1 as “a”
Elm A is in fact an object of type “b”
Publicint X _ that has overwrite method
virtualyint Suma() { return x + y; } “Suma”
virtual int Diferenta() { return x - y; }
}_ virtual int ProdusO { return X*ys } ‘z. For the rest of the methods
ciass B = public A (Diferenta and Produs) the
iublic: behavior will be identical to the
}_ int Suma() { return 1; } one from the base class (A).
void main()
{
B b;
b.x = 1;
b.y = 2;
A* a;
a = &b;
int x = a->Suma();
}—

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
How V1 rtual methods are modeled by
C+ + com p1 ler
Instance of type A Instance of type B
Address of VFTable A Address of VFl'able B
VFTable for class A VFTable for class B
Address of A::Suma Address Of B::Suma
Address of A::Diferenta Address Of A::Diferenta
Address of A::Produs Address Of A::Produs
RTTI RTTI

***************Ending Page***************


***************Beginning Page***************
***************page number:81**************
How Virtual methods are modeled by
C++ com pi ler
‘z. A derived class can also add other (new) virtual methods .
App.cpp ‘z. In this case, class B also have a
Elm A new virtual method called
pUblicint X _ “Module”) that is not present on
virtualyint Suma() { return x + y; } ClaSS A.
virtual int Diferenta() { return x - y; }
}_ virtual int ProdusO { return X*ys } ‘z. This means that any class that will
ciass B : public A be deriVed from B Will haVe this
iublic: method as well.
};
void main()
{
}—

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
How vr rtual methods are modeled by
C+ + com p1 ler
Instance of type A Instance of type B
Address of VFTable A Address of VFTable B
VFTable for class A VFTable for class B
Address of A::Suma Address Of B::Suma
Address of A::Diferenta Address Of A::Diferenta
Address of A::Produs Address Of A::Produs
RTTI Address of BzzModul
RTTI
/

***************Ending Page***************


***************Beginning Page***************
***************page number:83**************
When a class is derived from two(or more) classes that have virtual functions,
the compiler creates multiple vfptr pointers (one for each base class).
class {
pUbhcint a1. mov ecx,dword ptr [cptr]
virtual int Suma() { return 1; } add GCX,8
virtual int Diferenta() { return 2; } mov eax,dword ptr [CptP]
1’; mov edx,dword ptr [eax+8]
C1”? _ { mov eax,dword ptr [edx+4]
public.
int b1)b2; call eax
virtual int Inmultire() { return 3; }
virtual int Impartire() { return 4; } mov eax,dword ptr [CptP]
};
class z public ) public { mov edx,dword ptr [eax]
public: mov ecx,dword ptr [cptr]
int x, y; mov eax,dword ptr [edx+4]
};
void main() { calleax—
C;
*cptr = &c;
cptr->Impartire();
cptr->Diferenta();
}

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
How Virtual methods are modeled by
C++ compiler
‘z. When a class is derived from two(or more) classes that have virtual functions,
the compiler creates multiple vfptr pointers (one for each base class).
APP-CPP
31:32:} { VFTable for class A
jgjtjii ént o { return 1; } Address of A::Suma
}; Virtual “t O { “tum 2’ } Offset Field Address of A::Diferenta
$13??? + 0 A==vfptr RTTI
in b ,b 3 ..
virtual int () { return 4; } __
}; + 8 5pr" VFTable for class B
class C : public A, public B { + 12 B“b1 .
pubhc; t y " Address of B::lnmultire
. 1" X’ 3 16 B::b2 .
53m <> { + Address of B::lmpartire
Rm
2;???" = &¢; 0; + 24 C::y
} cptr—> ()3 /

***************Ending Page***************


***************Beginning Page***************
***************page number:85**************
How Virtual methods are modeled by
C++ compiler
‘z. The same memory alignment is used for classes derived out of class C (e.g. in
this example, class D)
APP-CPP
Sﬁzﬁcé { VFTable for class A
jgjtjii ént o { return 1; } Address of A::Suma
}; Virtual mt O { “tum 2’ } Offset Field Address of A::Diferenta
$131? + 0 A==vfptr RTTI
virtual int () { return 4; } __
}; + 8 5pr" VFTable for class B
class C : public A, public B { + 12 B“b1 .
Publlci t " Address of B::lnmultire
. 1" X’ y’ 16 B::b2 ,
ii D _ . + Address of B::lmpartire
‘ }; + 24 C::y
+28 D::d1 /

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
M’ covariance

***************Ending Page***************


***************Beginning Page***************
***************page number:87**************
‘z. Let's analyze the following code:
App.cpp ‘z. This code will not compile.
21a“ A However, in reality “b->clone()”
public: returns an object of type B so it
int a1, a2;
virtual A* clone() { return new A(),' } ShOUld work‘
};
class B : public A
{
public:
int b1, b2;
virtual A* clone() { return new B(); }
};
void main()
{
B *b = new B();
B *ptrB; error C2446: '=': cannot convert from ‘A *' to ‘B *’
PtrB = b-><I10ne(); note: Cast from base to derived requires dynamic_cast
} or static_cas

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
‘z. Let’s analyze the following code:
APP-CPP ‘z. We have two solutions for this
glass A problem:
public:
int a1, a2;
virtual A* clone() { return new A(); }
};
class B : public A
{
public:
int b1, b2;
virtual A* clone() { return new B(); }
};
void main()
{
B *b = new B();
B *ptrB;
ptrB = b->clone();
}

***************Ending Page***************


***************Beginning Page***************
***************page number:89**************
‘z. Let’s analyze the following code:
App.cpp ‘z. We have two solutions for this
glass A problem:
bl' : . .
p“ “int 81, 32; 1. Use an eXpllClt cast and convert
} virtual A* clone() { return new A(); } the pointer frOm Ai: to 8*
class B : public A
{
public:
int b1, b2;
virtual A* clone() { ret new B(); }
};
void main()
{
B *b = new = 3
B *ptri'
ptrB -b->clone();
}

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
‘z. Let’s analyze the following code:
APP-CPP ‘z. We have two solutions for this
zlass A problem;
b1’ : . .
p" “int a1, a2; 1. Use an explimt cast and convert
} virtual A* clone() { return new A(); } the pointer frOm Ai: t0 8*
ll. B : b1’ A . .
E ass p“ 1c 2. Use covariance. This means that
Publicint b1 _ _ we can modify the return type of
virtua- r i the method clone in class B to
if,“ maino return a B* pointer instead of an
{ * '
B *b = new BO; A pomter.
B *ptrB;
ptrB = b->clone();
}

***************Ending Page***************


***************Beginning Page***************
***************page number:91**************
‘z. Let’s analyze the following code:
App.cpp ‘z. We have two solutions for this
Elass A problem:
b1’ : . .
p“ “int a1, a2; 1. Use an explicit cast and convert
} virtual A* clone() { return new A(); } the pointer frOm Ai: to 8*
ll. B : b1’ A . .
E ass p“ 1c 2. Use covariance. This means that
public: '
int b1, b2; we can modify thereturn type of
virtual B* clone() { return new Bo; } the method clone in class B to
igid maino return a B* pointer instead of an '
{ * '
B *b = new BO; A pomter.
B * t B; . . .
.tPE Z b->c10ne - Covariance lS related to the pointer
A *a = (A*)b; - .
pm = (B*)a->clone(); type. _|n this case, even 1: the
} ~ compiler calls B::clone , the
expected value is A* (spec' 'c to a A*
pointer that is “a” 9 “ A ::clone”)

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
‘z. Let’s analyze the following code:
App.cpp ‘z. We have two solutions for this
21a“ A problem:
b1’ : . .
p“ “int a1, a2; 1. Use an explicit cast and convert
}. virtual A* clone() { return new A(); } the pointer frOm Ai: to 8*
1 B : bl' A . .
E ass p“ 1c 2. Use covariance. This means that
Publicint b1 b2_ we can modify the return type of
virtual B* clone() { return new Bo; } the method clone in class B to
}; . .
\{IOid maino re*turn a B* pointer instead of an '
B *b = new BO; A pomter.
B * t B; . . .
.tPE Z b->c10ne . That lS why this code Will NOT
2;; j if‘2§’éne<)_ compile, as the result for a->clone '
} ~ A* and not B*. During executio
“B::clone” will be call, ne r

***************Ending Page***************


***************Beginning Page***************
***************page number:93**************
Covanance
‘z. Let's analyze the following code:

‘z. This code will not compile. The
glass A return type for virtual functions
public: can be changed, but only to a type

ﬂﬁtjii Zi‘c10ne() { return new A0; 1, that is derived from the return
Sass B : public A type of the virtual method
{ described in the base class. In this
publicint b1’ _ _ case, int* is not derived from A*

virtual-cloneO { return new int(); }
soid main()
{ error C2555: 'B::clone': overriding
1’ virtual function return type differs

and is not covariant from
'A::clone'

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
Abstract classes
> (Interfaces)

***************Ending Page***************


***************Beginning Page***************
***************page number:95**************
Abstract classes (Interfaces)

b In C++ we can define a virtual method without a body (it is called a pure
virtual method and it is defined by adding “=0” at the end of its definition).

b If a class contains a pure virtual method, that class is an abstract class (a
class that can not be instantiated). In other languages this concept is similar
to the concept of an interface.

b Having a pure virtual method forces the one that implements a derived class
to implement that method as well if he/ she would like to create an instance
from the newly created class.

APP-CPD ‘z. The code will not compile as “A” is an
glass A abstract class.
public: '
int a1 a2 a3'
h
V°ﬂimaﬁﬂ) error C2259: 'A': cannot instantiate abstract class
{ Aa_ note: due to following members:
} j note: ‘void A::Set(void)': is abstract
note: see declaration of ‘A::Set'

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
Abstract classes (Interfaces)
b In C++ we can define a virtual method without a body (it is called a pure
virtual method and it is defined by adding “=0” at the end of its definition).
App.cpp ‘z. This code will compile because class B has
class A an implementation for method Set
[{aublici ‘z. ln order to be able to create an instance of
$23321 igfggto = a; a class, all of its pure virtual methods
Ziass B_ A (defined in that class or obtained via
{ _ ' inheritance) MUST be implemented !
pUbllc:i.nt a1, a2, a3;
void Set(){m };
}
void main()
{
B b;
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:97**************
Abstract classes (Interfaces)
b In C++ we can define a virtual method without a body (it is called a pure
virtual method and it is defined by adding “=0” at the end of its definition).
App.cpp ':~ This code will however compile. It is
class A possible (and recommended whenever
{ublic_ working with polymorphism) to create a
p int a1, a2, a3; pointer towards an abstract class (in this
}. virtual void Set() = 0; case an A* pointer).

ciass BI A

{

public:

int a1, a2, a3;

void Set(){m };

}

void main()

{ , ¢

\ }

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
Abstract classes (Interfaces)

b Other languages (such as Java or C#) have a similar concept called interface
(primarily used in these languages to avoid multiple inheritance).

> interfaces are however different from an abstract class. An interface CAN
NOT have data members, or methods that are not pure virtual. An abstract
class is a class that has at least one pure virtual method. An abstract class can
have methods, constructors, destructor or data members.

b ln C++ it is often easier to use struct instead of class to describe in interface
due to the fact that the default access modifier is public

b Cl.exe (Microsoft) has a keyword (_interface) that works like an interface
(allows you to create on). However, this is not part of the standard.

***************Ending Page***************


***************Beginning Page***************
***************page number:99**************
Memory alignment
in case of
> inheritance

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
Memory alignment in case of inheritance

class A
{
public:

int a1 ,a2,a3;
}; +0 A::a1

+8 A::a3 B

class B: public A +12 B::b1
iublic: +16 B::b2

int b1,b2
};

***************Ending Page***************


***************Beginning Page***************
***************page number:101**************
Memory allgnment 1n case of mhentance
class A
{
public:
}; +0 A::a1
-
. _ I. +8 A::a3 B
+12 M1
public: +16 B::b2
int b1,b2
};

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
Memory alignment in case of inheritance
class A
{
public:
int a1,a2,a3; -Field c1 c2
}; +0 A::a1
+8 A::a3
class B: public A +12
};

***************Ending Page***************


***************Beginning Page***************
***************page number:103**************
Memory alignment in case of inheritance
class A class B:
{ {
public: public:
}_i"ta1’a2’a3; }_""t ‘01332; Offset Field c1 |c2 |c3
’ ’ +0 A::a1
5mm) =12 W A
+8 A::a3 B
class Czpublic A,B r V +12 B::b1 C
{ +16 B::b2
P"b11c= +20 C::c1 '
int c1,c2;
1,; +24 C::c2
sizeoﬂC) = 28

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
Memory alignment in case of inheritance
‘

class C:publiw
{

class A class B: public:

{ { int c1,c2;

public: public: };

int a1 ,a2,a3; int b1,b2;

}3 }; sizeoﬂC) = 28

sizeoﬂA) = 12 Offset Field c1 c2 c3
+0 B::b1
+4 B::b2 B
+8 A::a1 A /
+12 A::a2 C
+16 A::a3
+20 C::c1
+24 C::cZ

***************Ending Page***************


***************Beginning Page***************
***************page number:105**************
Memory alignment in case of inheritance
warning C4584: 'C' : base-class 'A' is already a base-
class of ‘B’.
‘z. Multiple inheritance can create ambiguous situations. For example, in this

case the fields from class A are

copied twice in class C.

App.cpp +0 l A::a1

class 4 I:

{ A +lA a2 Al

public: +8 A::a3

int a1, a2, a3;

glass B: public A +12 B::A::a1

fwblic: +16 l B::A::aZ B::A C
}; mt b1’ b2; +20 B::A::a3 B

class C : public A, public B

{ +24 B::b1

public:

}_ int c1, c2,- +28 B::bZ

‘{’°id O +32 C::c1
}— +36 C::c2

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
Multiple inheritance can create ambiguous situations. For example, in this
case the fields from class A are copied twice in class C.
class {
public:
int a1, a2, a3; l\
};
class : public { E5 l\
public:
int b1, b2;
h This code Will NOT compile ll!
class : public , public {
public:
int c1, c2;
ioid main() warning C4584: 'C': base-class 'A' is already a base-class of 'B'
{ note: see declaration of 'A'
. note: see declaration of ‘B’
} error C2385: ambiguous access of 'a1'
note: could be the ‘a1’ in base 'A'
note: or could be the 'a1' in base ‘A

***************Ending Page***************


***************Beginning Page***************
***************page number:107**************
Memory alignment in case of inheritance
‘z. Multiple inheritance can create ambiguous situations. For example, in this
case the fields from class A are copied twice in class C.
App.cpp ‘z. The solution is to describe any field/ data
class A { member using its full scope. For example:
b1‘ :
pu 1cm a1, a2, a3; > “c.A::a1” means data member “a1” from
}5 _ the direct inheritance of “A” in class “C”
class B: pub11c A {
pubhcint b1 b2_ > “c.B::A::a1” means data member “a1”
}; ’ ’ from the inheritance of “A” in class “B”
333$ch = Public A’ Public B { that is directly inherit by class “C”
int c1, c2;
};
‘{’°1d mam‘) ‘z. What can we do if we want to have only one
c c' copy of the fields from class “A” in our
c.B::A::a1 = 20;
}— ‘z. This problem is also known as the “Di 0nd
Problem”

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
Memory alignment in case of inheritance
‘z. Multiple inheritance can create ambiguous situations. For example, in this
case the fields from class A are copied twice in class C.
APP-CPP .;. One solution to this problem is to use the
¢1a5§ A { virtual specifier when deriving from a
pub11c: . . . .
int a1, a2, a3; class. ln this case, class “A” is inherited
Ziass B: public-A { virtually (meaning that its fields must be
publicg added once).
1nt b1, b2;
Ziass c z public-A’ public B { ‘z. For this code to work, both “C” and “B”
publicg class need to inherit class “A” using
1nt c1, c2; .
}; Virtual keyword.
void main()
{
C c;
c.a1 = 16;
c.a2 = 20;
}—

***************Ending Page***************


***************Beginning Page***************
***************page number:109**************
Just like in the case of virtual methods, if no constructor is present, one will
be created by the compiler. However, this constructor is a little bit different
than the others (as it has one parameter of type bool).
class {
public:
int a1, a2, a3; pUSh 1
}; lea ecx, [c]
class : public virtual { call. C2 2C
public:
}, Int b1’ b2; mov eax,dwor‘d ptr [c]
class : public virtual public { mOV eCX:dWOPd ptr [eax+4]
public: mov dwond ptr' [c+ecx],19
int c1, c2;
55nd main() mov dwor'd ptr\ [c+2@],29
{
c.a = 10;
c.b1 = 20,-
}—

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
‘z. The first parameter, tells the constructor if a special table with indexes needs
to be created 0r not l
Disasm C::C
APP-CPD
class A { pUSh ebp
public: mOV 9bp:95p
int a1, a2, a3; mov dword ptr [this],ecx
3’; B_ b1_ _t 1 A cmp dword ptr [ebp+8],9
fulﬁl; p“ 1° "1" “a { je DONT_SET_VAR_PTR
int b1, b2; mov eax,dwor*d ptr [this]
}; mov dWOPd ptr [eax],addr_index
class C : public virtual A, public B_ DONT SET VAR PTR'
public: - - — '
int c1, c2; pUSh 9
}; mov ecx,dwor‘d ptr‘ [this]
void main() call 51:5
{ mov eax,dwor‘d ptr‘ [this]
c.a, = 19; mov esp,ebp
c.b1 = 29; pop ebp
}— Pet 4

***************Ending Page***************


***************Beginning Page***************
***************page number:111**************
Memory alignment in case of inheritance
‘z. Once the constructor is called, an object that has virtual inheritance will look
as follows:
+ o
+ 8 B;;b2 C Offset relative to C
+ 12 C::c1 ' + 0 0
+16 C::c2 + 4 Virtual A 20
A==a1
- 24 A::a2 A
+ 2 A ::a3

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
Memory align ment in case of inheritance
‘z. Accessing a data member / field that benefits from the virtual inheritance, is
done in 3 steps (not in one) in the following way:
APP'CPP m
class A { m }
class B: public virtual A { } c.a1 = 19,‘
class C_: public virtual A, public B { } mOV eax,dword ptr‘ [C]
‘{mld ma1n() ‘ mov ecx,dword ptr‘ [eax+4]
- mov dword ptr [c+ecx],10
I —
}

***************Ending Page***************


***************Beginning Page***************
***************page number:113**************
Memory alignment in case of inheritance
‘z. In the first step, EAX register gets the pointer to the table where offsets of
data member/ fields from A class are stored
APP'CPP m
class A { m }
class B: public virtual A { } C.al = 19;
class C : nublic virtual A. nublic B f 1 mOV eax,dwor'd ptl" [C]
Offset —--‘/w/ecx,dwor'd ptr‘ [eax+4]
+ Q Ptr Class C Variable Offsets Table w
+ 4 B::b1 B
+ 8 B::b2 C
+ 12 C::c1
+ 16 C::c2
+ 20 A::a1
+ 24 A::a2 A
+ 28 A::a3

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
Second step - ECX gets the value from the second index in that table (+4),
more exactly value 20 (that reflects the offset of "A" from the beginning of "C")
class : public virtual { m }
class : Dublic virtual . Dublic f i mov eaxmwopd ptr~ c
mov ecx,dwor‘d ptr'
+0 mov dword ptr‘ [c+ecx] 19
+ 4 B::b1
+ 8 B::b2 B
+ 12 C::c1 C
+ 16 C::c2 Offset relative to (I
+ 20 A::a1
+ 24 A::a2 A + O 0
+ 28 A::a3 + 4 Virtual A

***************Ending Page***************


***************Beginning Page***************
***************page number:115**************
Last step, we use “ECX” register as an offset to access A::a1 from the
beginning of local variable “c”.
class = public virtual { m }
class : Dublic virtual . Dublic r i mov eaxmwopd ptr' [c]
mov ecx,dword otr eax+4]
+ O Ptr ClassCVariable Offssts Table mov dword ptr\_,19
+ 4 B::b1
+ 8 B::b2 B
+ 12 C::c1 C
+16 “C2
+ 24 A::a2 A + 0 O
+ 28 A2263 + 4 Virtual A 20

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
Fields/Data members that are obtained via virtual inheritance are usually
added at the end of the class alignment.
—
$1“;— + O ptr class C virtual members offsets
Elf-is; : public virtual + 4 C::Btib1
class : 53:32 virtual , + 8 (2:5be
{._.}— + 12 C::c1
+ 16 C::c2
+ 20 A::a1 (virtualAfrom C)
+ O 0/ + 24 A::a2 (virtual Afrom C)
+ 4 VirtualA 20 + 28 A::a3 (virtualAfrom C)

***************Ending Page***************


***************Beginning Page***************
***************page number:117**************
If we use virtual inheritance when deriving “C” from “B” (in addition to the usage
of virtual inheritance for class “A”) we will obtain the following alignment:
—
$135;— + O ptr class C virtual members offsets
Elf-is; : public virtual + 4 CZIC1
{..}— +12 A::a1 (virtualAfrom C)
/ + 16 A::a2 (virtual Afrom C)
+ 20 A::a3 (virtual Afrom C)
+ O 0 + 24 ptr class B virtual members offsets
+ 4 VirtualA 12/ + 28 B::b1 (virtual B from C)
+ 8 Virtual B 24 + 32 B::b2 (virtual B from C)

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
In case of the index table for class "B", the offset "-12" refers to the position of "A" class (also obtain
via virtual inheritance) relative to B with respect to C class (24 (offset of B) - 12 = 12 (offset of A))
—
$135;— + O ptr class C virtual members offsets
Elf-is; : public virtual + 4 CZIC1
{..}— +12 A::a1 (virtualAfrom C)
+ 16 A::a2 (virtual Afrom C)
+ 20 A::a3 (virtual Afrom C)
+ O 0 / + 24 ptr class B virtual members offsets
+ 4 VirtualA _12 + 28 B::b1 (virtual B from C)
+ 32 B::b2 (virtual B from C)

***************Ending Page***************


***************Beginning Page***************
***************page number:119**************
If we make only the inheritance of B from C to be virtual, the memory
alignment is as follows:
—
c1aSS— +0 A::a1
21;; : public + 4 A1361
has: : public +8A::a3—
{ } pumc- + 12 ptr class C virtual members offsets
— + 16 C::c1
/ + 20 C::c2
+ 24 B==A==a1
+0 _12 +28 B::A::a2
+ 4 Virtual B 12 + 32 B::A::a3
+ 36 B::b1

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
If we make only the inheritance of B from C to be virtual, the memory
alignment is as follows:
— Offset Field
— + 0 A::a1
class
ilasi : public + 4 A::a1
has: : public +8A::a$—
{ } pUblic- + 12 ptr class C virtual members offsets
/ + 16 C22c1
Offset Offset relative la C
+ 0 -12
. + 32 B::A::a3
+ 4 Virtual B 12
+ 36 B::b1
+ 40 B::bZ

***************Ending Page***************


***************Beginning Page***************
***************page number:121**************
If we make only the inheritance of B from C to be virtual, the memory
alignment is as follows:
—
m— +0 A::a1
21;; : public + 4 A::a1
{ } pUblic- + 12 ptr class C virtual members offsets
+ 16 C::c1
/ + 20 C::c2
+ 0 -12
+ 4 Virtual B 12
‘l' JO DZZDI

***************Ending Page***************



 

