***************Beginning Page***************
***************page number:1**************
‘\ Gavnlut Dragos
00p Mes

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
b Inheritance
> Virtual methods
> How virtual methods are modeled by C++ compiler
summary > Covariance
> Abstract classes (Interfaces)
k b Memory alignment in case 0i inheritance

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
l Inheritance

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Inheritance
> Inheritance is a process that transfer class proprieties (methods and
members) from one class (often called the base class to another that inherits ‘3
the base class e called derived class)‘ The derive class may extend the base
class by adding additional methods and/or members. 1‘
> Such an example will be the class Automobile, where we can define the
following properties:
> Number of doors ‘1
> Number of wheels ‘
b Sile
> From this class we can derive a particulan'zation of the Automobile class (for
example electrical machines] that besides the properties of the base class
(doors, wheels, size, etc) has its own properties (battery lifetime)‘ ,7

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
In herita nce
> Inheritance in case 010+ classes can be simple or multiple:
> Simple Inheritance
(his “mu-m on.“ mm.» m;- (mp ( )
> Multiple Inheritance
Multiple
Guess Indlﬂer) <base class 1) , l‘
(access “mm up" um a> . l‘
like“ mdlﬂew mu <1.“ I» ,
> The access modifier is optional and can be one of the following: H
(public l private or protected].
> If it is not specified, the default access modifier is private.

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
In heritance
> Class “Derived” inherits members and methods (rom class “Base'C That is why
we can call methods SeLX and SetY from an instance of “Derived” class.
APP~CPP
class lass
(
Public:
1m n
in‘, sllxrin! v.;ul>;
11m um. 1 PM .m
( in! y;
puhiizz
r vuid Sewiin! vahmi;
vain mun!)
r
Derived a;
V
mx-lm
ajuwzuh
i________________________________________________

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
> The following Code Will not Compile, Class "Derived" inherits Class “Base”,
but member “x” from class Base is private [this means that it can not be
accessed in class “Derivedﬂl
APMPP
(1.;S Bis!
i
pr,vate
Int X.
n
(1.;S unrivad Dub11( Bis!
i
,"t y,
VuhlzK
V016 S:(Y(1n( Vi1u=>,
void 51(X(1n( va1u1)>
L
"m “em” 55ml" “1m Um!‘ Qua. m; A = (armct mm Private MM mum
y ' ' "m. m ditlar'ﬂwn at ‘Ease'w'
VD,, ma,"4) Huts- Sag dezlaratlun 0F ‘Bass
l
D:r1v:d 4.
4 S:(\(1BB7,
n SQKV(ZBB)»
i

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
In heritance
> The solution for this case is to use the “protected” access modifier. A
protected member is a member that can be access by classes that inherits
current class, but it can not be accessed from outside the class‘
ADPIPP
(1-,, |.,t
mx
)
(1.55 Derived 1 Publiz |.§t
l t
int y:
Public:
void Setvlint valulli
vain Selein! vllulli
3214 DerivedzzsetXlint vsiuey
t x - m“; ,
)
vain ma1n(}
(
Derived 4;
dsuulun
¢.§t!v<2!!>;
y

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
In herltance
> The code below wilt not compile. "x" is declared as protected e this means
that it can be accessed in meihdd SetX from a derived class, but it can not be
accessed outside ‘Vs scope chass).
APMPP
(lass Base
i
prutezted
1"! X.
n
(lass Derived Dub11( Base
i
,"t y,
VuhlzK
V016 52(Y(1n( vs1u=>,
void 51(X(1n( va1u1)>
L
<
x Z vilul,
v
vain maAHA)
<
“mm d- errar @445; mg :v 1 mm 31:25:- Pratetled member ‘19mm
w» 1H L1..\ ‘am:
"m 5E! detlamn'w M m»
* "are 5;“ ¢~i1gys<1vn u; ‘iii!

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
In heritance
> The following table shows if a member with a specific access modifier can be
access and in what conditions:
Access In the In a Outside Friend Friend
modifier same Class derived it's function in the function in the
class scope base class derived class
public Yes Yes Yes Yes Yes \\
protected Yes Yes Nu Yes Yes \
private Yes No No Yes No \
\

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
In heritance
> The code below will not compile. “x” is a private member of “Base” therefor
a friend function defined in “Derived” class can not access it.
ADPIPP
(1-,, |.,!
mx
)
(1.55 Derived 1 Publiz |.§!
(
1m w
Public:
void Setvlint Vilul>=
in‘, (rill, Seleﬂerived an);
3214 SetXlDerived law
l
) illin! ,
void mainl}
(
Dirivld a;
snudh
)

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
In herltance ‘
> The solution is to change the access modifier of data member “x” from class ‘
“Base” 1mm private to protected.
APPIPP
(1-,, |.,!
mx
)
(1.55 alr1v11 1 Public |.§!
(
1m w
vus11=1
void Setvlint vilull?
vain friend Sa!X(Darivad an);
3214 sexX(uer1ved law
t 4.x - 1n;
)
vain ma1ﬂ(}
(
Dirivld 4;
suudh
)

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
In herltance
> Be carelul Where you define the friend function, In the example below SetX
friend function is declared in the “Derived” class. This means that rt can
access methods and data members from instances of “Derived” class and not
other classes leg. Base class). The code will not compile.
APMPP
(1.55 5.5:
<
pr1VI<t
,nt X,
n
(1HSS ntr1vtn Dublit 53$!
<
,nt y,
publl‘
Ella ‘LJSQZH; an),
l
4.x Z 1am,
>
vain mijnrx
l
Deraved at
>

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
| n herltance
> This code will work properly because the friend function is deﬁned in class
"Base"
ADPIPP
(1-,, |.,!
r
Private:
1m n
Pun}: -
21m um. z mm .m
t 1m y
Publizz
vain Se!v(1n! va!u:}}
)
void 5.1leis! Id)
r
,‘X . auu;
)
vuid miiﬂll
r
alr1VEQ a;
)

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Inheritance
b Access modifiers can also be applied t0 the inheritance relatiuri.
> As a result, the members from the base class change their original access I
modifier in the derived class. ‘1
e In this case, because “x” is public iri the “Base” ‘1
App.cpp class, and the inheritance relation is aLsu public, I
‘1m I,“ "x" will be public as well l|’i the "Derived" class i
t . and will be accessible from OuBide the Class
“mini r; scope-
lim Derived 1-.“
t uri y:
Publiz:
mu SeIVUn! “my l l
l2“ mainl) ,
Derived a;
u.‘ - m;

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Inheritance
b Access modifiers can also be applied t0 the inheritance relatiurl. l2
> As a result, the members from the base class change their original access I
modifier in the derived class. ‘1
s This code Will not compile. “x” is indeed public ‘1
App.cpp in class "Base", but since the inherit relation I
‘1m I,“ between class “Base” and class “Derived” is l
t _ private, "X" will change its access modiﬁer main
“min, ,i public ta private in class Derived and will nat be
); accessible imni outside its scape.
am auuu s-usa
t m v e Huwever, ii we are to create an instance oi type
Pub)!“ y’ "Base" We Will be able t0 access “X” for that
y ma servlan! i-uu t ) instance outside its scope.
v2“ mainl) '

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
In herrtance
> The rules that Show how an access modiﬁer is change if we change thel access
modifier oi the inheritance relation are as follows:
Access modifier used for the _) public private protected
inheritance relation
Access modiﬁer used for a data
member or method
protected protected private protected
private > protected > public

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
In herltance
> Let's consider the following case:
A .c
pp pp Output
‘1m A
tum‘: ctor: A is called l
m ( mmvmm A 1, (-1116 nu“); ) ctor: Bis called l
-m ( mmpmn A 15 nnm mm; ) _ ,
n ‘ dtor. Bls called !
Z1“: '1 Pm“ A dtor: Als called l
Publizz
|<> ( Prin!f(“(!nr: l 15 (.11la |\n“>; )
~|<> l Prin!7(“d!urz I 1; called l\n“71 1
1;: miiﬂl)
(
l h;
return I;
i________________________________________________

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
> Let's consider the IolLowv'ng case:
A .c
pp Pp Output
(1,55 a
<
pm“ ‘ ‘
m < wmmm I 1; an“ \\n“)> > \
44> < Wham“ A As “um ‘\n“), > ‘ ‘
n
Eh“ K Pm“ “ W dwurd Vtr mush“
pub“, mv “mum w Inns]
w i lawman’ a As an“ um, v ~11 ﬂ A (WWW)
-B() ¢ pr1»¢¢( ntur a ,5 (.115, ‘\n ,, >
>, W,“ Jig“ mm; "m k ,5 MM -
m mm “<11 ,mw MPH-mam
< m DE-Lu-i
return a,
> \ \
\
> The cod in YELLOW reﬂects the
execution of the base constructor.

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
In herltance
> Let's consider (he following case:
APPIPP
class l omlmt
in,“ ctur: B is called !
“Manx; >§ >) cmr: Ais called !
>, ' ctor: C is called !
:1.“ B dtor: C is called l
Mllli ( 1 m 7 ) dtor: Ais called !
.al, (“WM 5, > dtor: Bis called z
2M
(() l printfl u, >
} -(l) l prinnfl u, l
aél maz"(7 l
cr
raKMrn a,
'—
> In case Of multiple inhenlance, the order Ol base classes i5 used when thé"
constructor l5 called (m ms case a nrsl class B, then class A and finally class c)

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
In heritance
> Let's Consider the (Ollowing Case:
APPIPP
(lass I 0min“
in,“ ctur: B is called !
fibﬂﬁgxg >§ >) ctor: Ais called !
>, ' dtor: A is called !
:1.“ B dtor: B is called i
Pubhz
5(7 < printfl r, >
, -B() < prin(f( u, >
A.” < Mm a, Mm 11
—
in,‘
>,
An! mainl) l
< <,
return a.
i
> f no constructor IS deﬁned in c ass C, But tFere are at east one constructor
defined in one oi the class from which C is derived from, the compiler Will
create a deiault constructor that calls the constructor of class B follmﬂed by
the constructor oi class A.

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
> Let's consider the (allowing case:
APPIPP
d.“ .
i
M,“
“(m Y, < Wm A H my“ ,, >
my < WM M A ,5 mum 7, )
L
d.“ B
4
Mm
B(7(pr1n(f(<uv" u ,5 mum 7, )
-B() ( DHMﬂWIm‘ E 15 mum HM)’ )
b
d.” I pm“ E, pm“ a
(
mm WV. c2156 1 (Lump “Wynn; m "(mm A 4mm mum
)» rmt! (smaller has generated ‘C .c‘ hm
w m mm m WNW“ ‘1mm wmwmw ur war'y-lugd n-‘Lulufjwn
> This code will fail, as there is no explicit can m A::A(int) constructor.”

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
In heritance
> Let's Consider the iolluwing Case:
APPIPP
l1.“ l Output
1W“ ctur: Bis called !
“QTYAHEZM 7 )>. > cmr: Ais called !
>, p ' ctor: C is called !
:1.“ B dtor: C is called l
Ml: 1 d dtor: A is called !
.élflpirinél 753) dtor: Bis called z
2m,‘
(li lljaa> l Drlnlfl u, >
-:l> i pr,nl¢l u, l
l,
int ma1"(7 l
t K,
rl<lrn a,
l—
> The solution is to explicitly call the constructor of A in the member initializer
list for c; :cli

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
In henta nce
> Let‘s consider the following case:
A .c
pp A pp Output
( , ctor: B is called !
A X rimf “nur: A is “11:4 w.“ ; - -
.lu ( Mimén A 15 an“ W); f ’ ‘w’- Al‘ called l
); ctor: C ls called l
( E dtor: C is called l
‘A; ( m” 1 I t n 4 ‘\ “)7 ) dtorzAis called]
40 (“Dumpling I ,5 nnm Mi; ) dtor: B is called !
L (z s, A
t —
a; - WWW t ,5 (m w; ) , /
-(<: ( prin!f(“d!urz I 1; (a)!!! l\n“); )
)z
mi1n4> 1
l c;
I;
)

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
In hentance
> Let‘s consider the following case:

APPIPP
(lass l ( DMD“
uh)“: .
p “(mt l1 l Prinrf(“cmrz A 1: called mm; 1 ctor: B ‘5 called !
y w) l “1mm”; A is “11:4 1w); 1 ctor: Ais called l
(in; a ( ctor: C is called l
uh)“: , 1
p m l urxntf(“emrz l u called 1w; 1 ctor. D ‘5 called l
_ ~IL) l “1mm”; I is ‘111:4 1w); 1 dtor: D is called l
Ii.“ I ( dtor: c is called !
uh)“: . -
p mm! "1 l urxntf(“emrz c u called 1w; 1 dtor. “,5 called l
y <4) 1 prinlfLWKHr: z is “11:4 1w‘); ) dtor: B IS called l
(in; n: Mm a. Dubln l
l

< a
plh11<1

w—( mﬂwm D 1S an“ w; 1

_u() ( pr!n!f(“d!nr: u ,5 (-11‘, l\n“); 1
1;
,n= miln<1 (

u 4;

rlllr" a,
1

***************Ending Page***************


***************Beginning Page***************
***************page number:26**************
In henta nce
> Let‘s consider the followin- case: Output
A .r. l
pp ‘pp ctor: B IS called l
M Xy ( mmvmn A 1: called \\n“7z 1 ctor: Ais called !
T ~Al) l vrinlfl“dturz A 15 “11:4 M‘); ) cm" C is called l
Y u ( ctor: D is called !
|<> ( Prin!f(“c!nr: | A; (=11la l\n“:; )
~Il7 l PI‘1nIf(“dmrz l 1: called ‘\II“71 l
n
l ( .
q n) ( pr!||!f(“(!ur: c ‘5 nnm nu“); ) ctor: E \s called !
) (u l “1mm”; e As Gum ml“): ) dtor: E is called l
Ill U t n) ( unnlfﬂnur D is an“ l\||“)' ) dtOf: D i5 called !
-u() ( pr!n!f(“d!ur: u ‘5 nnm nu“); ) ' dtor: C is called l '
l‘ Z, 5' H dtor: Ais called l
j, 2; dtor: B is called !
Eli: ¢< 7, A(1II7, =< 7, »<yv v2(1nn77 v1(2n7 ( prinlf(“¢lnrz z is ==11¢¢ l\ﬂ“71 l
~El) l Frin!fl“dturz z 15 (‘11:4 l\n“); )
)7
le{n() (
) V l

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
Inheritance x
> When inheriting from multiple classes, the general rule for calling constmctors l
and destructors is as follows: g
1 First all of the constructors from the base classes are called in the order oi their
inheriting deﬁnition (left-to-right) 3
2. All of the constructors from data members are called iagain in their definition
order r top>to>bottoml l
x. Then the constructor initialization value for data members (basic types,
references, constants) are used in the order they are defined in that class.
4 Finally, the code oi the constructor of the class is called.
> Destructors are called in a reverse way (starting from point 4 to point 1)‘
Tested with:
> Cljxei w 15170204
> Params: lpermissvve- IGS- misma- /w3 newmsm m le» /Od /sdl f
/Fd"Dehug\yc141.pdb‘ /ZCIlrilirie /fp:preclse /D ‘WINZT' /D ‘ DEBUG ID " CONSOLE" /D
“,umconi" m “UNICODE” /errorReport:prompl /w><' /Zc:for5ccpe mrm /argn:r/lzz ma
/Oy' /MDd /Fc /Fa“Dehug\‘ /n0log0 /Fo“Debug\“ /Fp“Debug\Testhp.pch"
/diagnosucs:class|c

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
> Virtual methods

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
Virtual methods
App.cpp ~:¢ This code prints "B" on the screen. From the ‘E
class A inheritance point of view, both A and B class ‘I
("um have the same method called Set ;

.‘LL’;;J§1‘ZiM<-.-n ) a‘ In this case it is said that class B hides ‘a
IL“ B: "1k A method Set from class A ‘1
Li.“ ‘

m ha, hi;
)_ win Sm) ( wmwvn >
“in Ian
t

a h;

we“);

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Vlrtual methods
App.cpp ~1¢ lrl this case, the Code will print "A" 0n the ‘z
class A screen, because we are using a pointer of type ‘I
£11m‘: A’ =

m :1, :1, :3; , , . . ‘
m4 SetO l puma-r); r a‘ However, m reality, “a” pointer points tn an a
2L“ B: "1k A object of type B —) so the expected result ‘1
l should be that the product will print "B" and l
mm: i“ n
m hi, m not A
m4 mo ( wwwv"): > . .
1i“ mm ~:~ So what can we do to change this behavwr ?
‘ = h‘
A‘ s Z lb;
,,

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
Virtual methods
App.cpp ~Z‘ The solution is t0 use “virtual” keyword in I
um A from of a method - definition ‘

c I
""‘im ,1 ~Z~ If We d0 this, the program will print “B” j
n M‘ 5”‘) ‘ Wm'r“ ’ ~:~ In this case, it is said that class B overrides I
fh“ B‘ "Mk “ method Set from class A 1
"min m, m ~:~ Using virtual keyword makes a method to
). "M 5”‘) ‘ """"“‘“‘)‘ > be part of the instance l
A“ "no
(

a h;

A‘ s Z lb;

who; ,y

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Vlrtual methods
Virtual methods can be used for:
> Polymorphism
> Memory deallocation (virtual destructor)
> Anti-debugging techniques

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
Virtual methods
Polymorphism = the ability t0 access instances 0f different Classes through the I
same interface. In particular to Cw, this translates into the ability to ‘
automatically convert (cast) a pointer to a certain class to its base class‘ i
App-l ,cpp ~:- After the execution this code will l
class mm ( print on the screen “Circle” and ‘
)_ ﬁnk: mm; mu mm t mmvmm"); ) “Square'ﬂ ‘
""333‘inlﬁiiuﬁii';impunity; ) 4» If we haven't uses virtual
5.“ 5mm um‘ ﬁlm € speciﬁer, the program would have
y mm: v.“ mm ( pr!"(tl"5quirl"}; ) pn'nted "Figure" twice !
vivid mm
( ﬁgure mu:

m1 - m math; "

m] - m Squarllli

m- (m m“ . lzsndex<zzsndex~7
) mmthm;

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Virtual methods
,-
. . . Fumbni
In practice, ll'l many cases, polymorphism , r mm:
is used to create a plugin or an l " '
add-0n for an existing software. ,
/ Function n
Function 1 mam‘ \\
_ > Function 2 mm“ \
Application , \
Function 3 Funaion n \
Function n
rumum
1 Function z
\ Function n

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
Virtual methods
In particular for c++ language, virtual specifier can be used as a specifier for I
destructors‘ ‘
Let's analyze the (ollowing case:
App-l ,cpp ~z~ After this code gets executed, ‘i
class mare ( the following texts will be I
ilk: virtue] win em r'vv r "n we" r - ,
flak: mm, r pupil~§Juﬁrirwiii~ii , ’ Pﬂmed 1"‘ {he screen»
)§ 1 m t “Delete Flgure"
r ass (Arc e: z n ure r. a r,
public "'4': mausi pmwmrrriem ) Delete Fugure -
Iulli(: -(ir(lll) i prrrrri~peiere (xrc\e"); y _
); ~z~ What would happen If both
(lull Square: nﬂhli( Figure { .
whlkz Md Drawn t prmemsqaarsi-i; i Circle and Square classes
y public iquirll) i w'mNWDelet: Swirl"); ) allocate some mammy g ,7
v'.“ mxnl) t
Figure Wm;
m1 - m (Arden:
m] a ire. Squarel):
r» lint 1mm a Inndlxdnndlxw)
4-m- (mi-mu;

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Vlrtual methods
In particular for 0+ language, virtual speciﬁer can be used as a speciﬁer for I
destructorsl ‘
Let's analyze the following case:
App-l ,cpp ~z~ The solutl'orl l's m declare de I
a“; mm l destructor as virtual‘ As a “
i=3}? 33:3 w“ all illililfﬁqlliiiilin?“, ) mun’ ‘he “WWW f0’

>; > actual class w|ll be called,
““:l§;£2‘;.,';:"“‘ Z;‘:':Am<w.l >1 > fallowed by the destrucwr of
) pm“; (7 l wwwwln "New ) the base class
‘miuiilifiu'iihm SgTISr-fnul“iqmle“); l - The followlng text will be
)v Wm‘; l) 4 ppm“ We» mm >1 > printed: ,7
“Ln U (

Figuré -¢|11;

m] Z m urclel);

m1 Z m 5mm);

m (1m man Z B,£ndzx<2,£ndzxuy

1.1.1. (imam),

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Vlrtual methods ‘
Let's analyze the following case:
APP-1 we
‘lass A
l
Puhllz
virtual hum; UddlAn! X) t return X 1 1 .- a; v
2;,” . z mm l
l
Puhllz
virtual hum; uddlchar X) t return X 1 1 .- a; v
n
tn! miln<> l
vizmwn»
prlnlf(“Xd\n“, .->u¢a<z>>,
return a;
> N
b Odd is a vvrtual Mnctiun V huwever, class B override it {as it uses
char as the ﬁrst parameter instead of int). As a result, class B will have Z
Odd methods and a->Odd will call the one with an int parameter. Upcm
execution, value false (0| IS written to the screen‘

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Virtual methods
Let's analyze the following case:
APP-LEW
class A
t
m -
“mun-"H
t z
m - z
minim-.5” ‘
i: i‘
m mini) ( ‘a
A‘ i Z m ll);
printfﬂﬂm", rmaun;
rum-n I; l
> Odd is a virtual function » however, class B does not override it (as it uses
char as the ﬁrst parameter instead of int), As a result, class B will have Z
Odd methods and a->0dd will call the one with an int parameten Upnn
execution, value false 10] is written to the screen.

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
V1 rtual methods
Let's analyze the following case:
APP-1 WP
‘lass r
t
Public
virtual ere; dddAAn! X) r return X e z .- e; v
t
Public
virtual ere; dddtc ar X) errrrrer r return X 1 z .- e; >
n
xnt mixﬂ() 4
PaZMwHL
pr1n1f(“xd\n“, .->eee<1>>,
return e;
> ,
> Assummg that , in reality, the intent was to override Odd method, then one
way of making sure that this kind of mistakes will not happen is t0 use the
override keyword (added with C++11 standard). As a result, this codq,,witl not
Compile as it ls expected that method Odd t0 have the same signatur'e 1!!

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
V1 rtual methods

Let's analyze the following case:

APVLCPP

m“ A

t

publxz:
\Arlua! m1 Oddhn! n { ruurn K x 1 -. a; )

25m . 1 mm: A l

( l

Dublin: x
\Arlua! m1 emu": n -{ ruurn K x a -. a; ) x‘

1;‘ mm) l x
A‘ I - m nu; g
mnmmw, I-Mdlln;
ruul'n a; t

)— ,7
> Now the code compiles and prints “1 " (true) on the screen.

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
Virtual methods

Let's consider the following code:

APP-1 ‘CPP

mm A 1
mum m1 mum x) Z o;

3;,“ . = mm l (

mm.‘ bun! mm“ n r mm. x x 1 .. B; )

llrucl < 1 vuhlic I c
mun m1 0mm x) ( mu". X x 1 -- »; )

1;‘ mm i a
A‘ a - m cu: ‘a
vnnmmw", arm-113)); x
mu". a; i

> This program runs and prints value 1 (True) -> even if 3 is not an odd number.

> The reason why this could happen is that method Odd was overridden in class C
(keep in mind that we have used struck in (his example t0 show that the behavior
is identical to the one from class].

> What can we do if we want to make sure that Odd method from class B can not be
overridden 7

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Virtual methods
Let's consider the iollowmg code:
APP'1-CPP
mm A(
Virtual haul n¢¢<lnt x) e n;
3;,“ E mm l t
virtual s“; oddlin! X) ms) t return 1 x 1 .- a; >
lam c mm l i
vim“) m1 mu" n t Nmnv X 1 z -- a, >
i;
A’ a Z m <0;
pr1n1f(“ld\n“, ir>ﬂdd(3))r
return a,
’—
> The solution is l0 USE the Specifier final after the declaration of a virtual '
function‘ Tl'ilS tells the compiler that other classes that inherit current class
can not override that method. ,

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
Virtual methods

Let's consider the following code:

APP-‘IPP

struer A i
mom bun] mu.“ x) e o;

3;,“ . = mm l l
mm; hon! 0mm i; mime Fina) i return X s 1 .. a; i

iam K = Fm“ - i

);

m mm i i
u a - m cu; ‘i
minimum a'modlim z
mu". »; x

) ‘x

v It is possible to use both override and final specifiers when declaring a
method, r‘

b In this case their meaning is:

> override -) The purpose of this method is to override the existing method from
the base class liri this case, it overrides AIIOdd)
b final -) Other classes that might inherit class B can not override this method,

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Virtual methods
Let's consider the ioliowmg code:
APP'1-CPP
mm A(
Virtual haul n¢¢<int x) e n;
3;,“ E Mm mm .
{ mm! m1 MA,“ x: Mm, 1 "m X x 1 a; >
lam c mm A t
A‘ a Z m <0;
prlnlf(“ld\"“, ar)ﬂdﬂ(3));
return a,
)—
> final speciﬁer can also be used directly in the class/struct definition‘ In this
case , it's meaning is that inheritance from class B is NOT possible. ,
> This code will not compile !

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
How virtual methods
are modeled by C++
> compiler

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
How v1 rtual methods are modeled by
C++ com p1 ler

~:~ Let's analyze the (allowing two programs. Their only difference is the usage

of virtual in case 0i APP-Z‘

APP'1-CPP APP-Z-WP

class A m“ 4

c l

Illk: Iullk:

_ “u m0 ( wen-r): i _ “win Sm) ( WHICH-l‘); i l
3;“ "no 3;“ mm l
‘ wM—“—,..M.»; ‘ pnndl'xa',nmfu)); l
> i l
~:~ When executed, APP-1 will print “12” and App-Z will print “16" (for x86 a

architecture). If we run the same App-Z on x64 it will print "24”
~:~ Why ?

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
How v1 rtual methods are modeled by
C++ compiler
~:~ Using the virtual keyword will force the compiler to modily the structure oi
any class by adding another data member (a pointer to a list oi pointers to a I‘
function). This pointer is called vfplr and if added is the first pointer in the 1
App-11w 3
<1.“ A I
¢ i
uublxt:
in! a), s1, is;
‘ v.“ mu r wmwm; )
k 33m maAnll
t
A i,
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
How v1 rtual methods are modeled by
C++ compiler
~:~ Using the virtual keyword will force the compiler to modily the structure oi
any class by adding another data member (a pointer to a list oi pointers to a I‘
function). This pointer is called vfplr and if added is the first pointer in the 1
App-11w z
<1.“ A I
( m ~ ‘
’“ ‘i... .., .1, ..; AIISetl)
‘ v.“ mu r wmwm; )
33m manll
t
A i,
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
How v1 rtual methods are modeled by
C++ compiler
~:~ Using the virtual keyword will force the compiler to modily the structure oi
any class by adding another data member (a pointer to a list oi pointers to a I‘
function). This pointer is called vfplr and if added is the first pointer in the 1
App-11w z
<1.“ A I
( m ~ ‘
’“ ‘i... .., .1, ..; AIISetl)
v.“ mu r wmwm; )
‘m maAnll main()
A i,
)

***************Ending Page***************


***************Beginning Page***************
***************page number:50**************
How v1 rtual methods are modeled by
C++ compiler
~:~ Using the virtual keyword will force the compiler to modily the structure oi
any class by adding another data member (a pointer to a list oi pointers to a I‘
function). This pointer is called vfplr and if added is the first pointer in the 1
App-11w 3
<1.“ A I
( m ~ ‘
’“ ‘i... .., .1, ..; AIISetl)
v.“ mu r wmwm; )
‘m manll main()
A i,
<Stack>

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
How v1rtual methods are modeled by ‘
C++ com p1ler t
~:~ Using the virtual keyword witl force the compiter to modify the structure of ‘
any Class by adding another data member (a pointer l0 a list 0i pointers l0 a ‘
function). This pointer is calted v/ptr and if added is the ﬁrst pointer in the ‘
App-M»
ch55 A t
4
“mint .1, .1, .3, A359“) “*3
m. o < 91mm“), > a a2
3;“ o I
< mainU ata1
A i,
<Stack>
-) ESP/RSP ,7

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
How v1rtual methods are modeled by ‘
C++ com p1ler t
~:~ Using the virtual keyword witl force the compiter to modify the structure of ‘
any Class by adding another data member (a pointer t0 a list 0i pointers t0 a ‘
function). This pointer is calted v/ptr and if added is the ﬁrst pointer in the ‘
App-z-cpp 1
<1.” A t
virlull lei <> t D‘lntf(“§“), >
5;“ U . M3
< A i’ ma|n() a.a2
<Stack> aprU '
-) ESP/RSP

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
How Virtual methods are modeled by ‘
C++ compiler 1
~:~ Using the virtual keyword wiil force the compiier to modify the structure of ‘
any Class by adding another data member (a pointer UJ a list 0i pOiriterS l0 a I
function). This pointer is calied v/ptr and if added is the first pointer in the ‘
' classA virtual
App-2.cpp
(1.55
" ‘ .. i i i c: et )
< A i’ "13an a.a2
)— / atai
<Stack> aprU "
-) ESP/RSP

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
How Virtual methods are modeled by ‘
C++ compiler 1
~:~ Using the virtual keyword wiil force the compiier to modify the structure of ‘
any Class by adding another data member (a pointer l0 a list 0i pOiriteVS l0 a I
function). This pointer is calied v/ptr and if added is the first pointer in the ‘
' classA virtual
App-mp
(‘.55
gm A A 5 ( M ptr to AzzSet
" ‘ .. i i i c: et )
5;“ U . M3
< A i’ "13an a.a2
)— / ata1
<Stack> aprU "
-) ESP/RSP

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
How Virtual methods are modeled by
C++ com pi ler
~:~ Whenever a virtual method is added, the compiler needs to be certain that
vfptr pointer is Set COI'l'eCth AS Such, any Constructor i5 modified t0 include
the code that sets up the vfptr pointer. If ho constructor is present, the
--. u-t -» ».--. -
a.” A
l
“mam X, y’ inov dword pt!‘ [elm-121,1
‘it K) ( return Xiy, >
t,’ mov dblord pcr [ebp'B],Z
mud o —
l
A a,
a X - 1,
..y - z, ,
t—
~:~ In thi's case, there no delault constructor deﬁned and no need for the
compiler to prov|de one automatically (evgs Virtual methods, const orﬂ
reference data members, etc).

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
How v1 rtual methods are modeled by
C++ com p1 ler
‘:~ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfplr pointen If no constructor is present, the
.-. -|-"--».-..-..
App.cpp Disasm
l1“! A a;
v lea ECX;[Ebp-15]
m mum) ( Mm w; .M Z 1,
m t x - r - v: l rm duord w [:bo’16],1
ll“ mm E'y Z 2;
( "av dlmrd ptr' [ehp»12],2
m —
‘X . 1;
.y - z:
)—
41~ In this case, there is a constructor that will be called when "a" is created,

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
How v1 rtual methods are modeled by
C++ com p1 ler
‘:~ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly As such, any constructor is modified to include
the code that sets up the v/ptr pointer. If no constructor is present, the
default one will be created automatically
App.cpp Disasm (A::Al
a.” J <1 : ‘l
r i H l l
Bunk: l ‘ l
m , ; mov dword rm [ebp-B],e<x // ramming
- - "- my; ) mov eaX,duord Dtr [ware]
m rm m [Wm H MW Z B y
If,“ mm mov ECX,I1WDPI1 ptr' [ebp-B]
¢ mov dword ptr‘ [9mm // tmwx : e
a mov eixmword ptr [ebp-a]
) a
41~ In this case, there is a default constructor and the code from the default
constructor will be called when object “a” is created‘

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
How v1 rtual methods are modeled by
C++ com p1 ler
‘:~ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly As such, any constructor is modified to include
the code that sets up the v/ptr pointer. If no constructor is present, the
default one will be created automatically
$1“; A a;
, lea ecx, [ebp-ZB]
—m mam; (m m M Z 1,
)2 rm duord av [mnsm ,
vnm mainﬁ my Z 2;
l "av mam ptr' [ehp»12],2
1; I ii
l—
41~ In this case, even ii no constructor is deﬁned, the compiler will automatically
create one to initialize the vfptr pointer {this is required because Cnlcul is a
virtual method).

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
Whenever a virtual method is added, Lne compiler needs to rnake certain that
vfptr pointer is set correctly, As such, any constructor IS modiﬁed to inctuoe
tne code that sets up tne v/ptr pointer‘ If no constructor is present, the
ngg Sgng WI pg Qrggsgg g ngiiiii i
(siss
< lea ecx amaze]
“Wm .
31m newt) Disasm “MEL;
{ a ooszz
y: Inov mom ptr [ebp'B],eo<
>— rnov eaxniwurd ptn [ebp'E]
mov dwurﬂ Dtr [eax], A-virtuai-fnc-list
Inov eax,ﬂword at» [ehD'E]

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
How v1 rtual methods are modeled by
C++ com p1 ler
~:~ Whenever a virtual method is added, the compiler needs to make certain that
vfptr pointer is set correctly As such, any constructor is modified to include
the code that sets up the v/ptr pointer. If no constructor is present, the
default one will be created automatically
a“; a a;
, [m
m Y
“in mum) (mm pm .M e 1,
A x - v - u; } uov duord av [:DWIGJJ
ll“ mm E'y Z 2;
( "av amm ptr' [H.142];
‘at - 1;
.y - z:
)—
‘:~ If a constructor exists, it will be modified (in a similar manner to the change
that is done for const/references data members)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
How v1 rtual methods are modeled by
C++ com p1 ler
~:~ Whenever a virtual rnetnod is added, tne compiler needs to make certain that
vfptr pointer is set correctly. As such, any constructor is modified to include
the code that sets up the vfptr pointer. If no constructor is preseht, the
default one will be created autom -
Disasm AIIA
APP-CPP
a.” a
l
Publi;
m h, y, m eax,duard ptr [ehp-S]
urn-=1 w o imm- wn my duur'd ptr [EZX],der' vir-t rh<
h o i x - y . a, t\ ViIUV EiX,ﬂWDTﬂ pth [elm-8]
vna <> HIOV dword DU‘ [esxssm
r muv ecx,d\-mrd DU‘ [ehp'8]
i I» VilDV dword hth [emam
:j: Q 1; mDV EZX,HHOV‘I1 pt!‘ [ebp-B]
>
~Z~ The Code Colored in blue is the
code added by the compiler to —
initialize the pointer.

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
How v1rtual methods are modeled by
C++ com p1ler
~:~ The code added by the compiler to initialize the vfptr pointer will be added
for every deﬁned constructor.
(1.‘; A
(
Public:
im-,m
virtual int <11<u1l> (Flturn X'y;) l
“>(x-y--=) l
~ damn-uhunykqn l
3;“ mm l
l a
) ‘~.1Illllllllllllllllllllllllllllllll 7N”

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
How v1 rtual methods are modeled by
C++ com p1 ler
~:~ However, in case of the assignment operator the compiler will not add any
special code to initialize the vfptr pointer.
APMPP
(1.;e a
(
Public:
im-,u
virtual int <I1<u1l> (llturn xly;) x
“>(x-y--=) l
t u "mm . u m ( x . 6.x; y . by; mu". - n l
3;“ 1mm l
l a
‘;‘ ,l
) ' ”

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
How v1 rtual methods are modeled by
C++ com p1 ler
‘:~ A virtual method is called using its reference from the vfptr table only if the
object is a pointer.
21-“ A a;
vmm m ammo (return w» 5.x , 1;
Au t x e y e a; ) nov award ptl‘ [:bp-10h1,1
n , .
um mm M ' 2-
‘ Iluv dwnrd w [:bD'BCtﬂJ ,
A a.(akul -
-X Z '1 lea ecx, [z]
call A::Ca1cul
i
-:- In this case, even if Culcul method is virtual as it called directly with an
object , the compiler will not generate code that will find out its address
from the vfptr table (it will use the method Cnlcul exact address).

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
Avirlual method ls called usmg vts reference horn the vfptr table only \f the
object IS a pomler.
<1IS§
l lea ecX,[a]
°""“‘m . . (all A: :A
V,rlu,1 1n‘ cav<uv<1 <r=lurn X.y,>
) m l X 1 y 1 e» mov dwurd pv [ebp'lehL]
7°“ "mo mov dworn pl?“ [ebyyﬂChLZ
A
X1; lea EEX,[E]
$51!“ mv mm w mm“
> mV EHXVWQM Pt” [32] EAX : address Di HZ
mov Han-mm w [w] I 50x : address of VFPTR
. .a a t z _ -
In m5 mm .5 used lo :3: 33,633; :t: {361] I EAX -vaddress of ﬁrst
ma out Calcul method address. <a11 eax "IMHO" ‘mm VFPTR

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
How virtual methods are modeled by 3
C++ compiler 1
r
1 cull) ("turn m I
v - a; ) l
); l
vain mainﬂ
( A a.

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
How virtual methods are modeled by 3
C++ compiler 1
r
2%‘?1-mm
); l
vain mainﬂ
( Aa.

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
How virtual methods are modeled by 3
C++ compiler 1
r
<1.“ A nun ummmmm l ‘
Ant :2 m (null) (mu MM‘ I
vain mainﬂ
( Aa.
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
How virtual methods are modeled by 3
C++ compiler 1
Applcpp Pseudo C/C++ Code I
<1.“ A nmx ummmmm l ‘
( 1M ('cncul) ()i ‘
mum m) . . : _ l
*l ( X - W \
); I . l
vain man-(I
( A a.
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
How virtual methods are modeled by 3
C++ compiler 1
r
<1.“ A nun ummmmm l ‘
( 1M ('cncul) ()i ‘
‘rm-H1 mm l
‘ Al) ( x - ; A_hr1_unrun<nms ‘mm l
( A a.
)—

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
How v1rtual methods are modeled by ‘
C++ comp1ler I
Appxpp Pseudo C/C++ Code I
<1.“ A nmx Lhnualﬁmnwni ( ‘
( 1m (-mum 0; ‘
mam ("turn m mm ‘
vain mail-(I Am A_Dkul() ( Mum ﬂ; )
( A a.

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
How v1rtual methods are modeled by ‘
C++ comp1ler 1
Appxpp Pseudo C/C++ Code ‘
<1.“ A nmx Lhnualﬁmnwni ( ‘
( 1M ('cncul) O; ‘
m x: class A ( ‘
- .. ‘I cull) (I'llllrn m) MM: ‘
AU ( x - H; ) Lhrtuilﬁmnlms wmr; \
); 1m x; ‘
( l0 (
) (ulubaLAijr-Lalcul - M::\_ul<ul;

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
How v1rtual methods are modeled by
C++ comp1ler
App.cpp Pseudo C/C++ Code
(1155 :- nml \JnnualFunnwni (
( 1M ('cncul) ()i
‘. ~ class ‘ (
u (null) (mm m mm
); 1m x;
vain mainQ Am A_Dkul() ( Mum ﬂ; ) ‘
< ‘a
‘.y - z; ) ‘a
,,->mmn: l_VmullFuﬂ<UMS mmuyw; 1‘
) “I . A hum: - “mama; "

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
How v1rtual methods are modeled by
C++ comp1ler
App.cpp Pseudo C/C++ Code
(In: r- nmcl \Jnnuammnwni (
( 1M ('Cllcul) ()i
virtual int {ilclllU (mum M) Mk:
AU ( X Z H; ) \Jnnuammnwns 'thr;
void mm 3 :ltakulO ( Mum a; > ‘
A0 ( ‘
.X Z 1; . Z o; I
ﬂy - Z; ) X
) "v , A Mum: Z w Hum“; "
(
. ‘
)

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
How v1rtual methods are modeled by
C++ comp1ler
App.cpp Pseudo C/C++ Code
(1155 :- nml \Jnnuammnwni (
( 1M ('cncul) ()i
‘m .; class ‘ (
virtual int {110114) (return In) MM:
AU ( X - H; ) \Jnnuammnwns 'vmr;
); 1m x;
void mainQ Am A_Dkul() ( Mum ﬂ; ) ‘
( l0 ( 2
.X - 1; > Z .; \
‘:Y ' Z; . ). ’ ‘a
.lvmwmams mmLum»;
) “I . A hum: - “mama; "
ml "MO ‘
(
. .

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
How v1rtual methods are modeled by
C++ compiler
~:~ Keep in mind the vfpt! is just a pointer. As such, it can be changed during execution
APP-(PP ~:- This code will print “AA” on the I
21"‘ “ screen. First time when method 1‘
Iullkim ‘ Print is called directly ‘
ml; m Mam; ¢ ,m.¢<“.“,; , (“mPrv'ntO”), second time when I
5,5; I method Print is called using the l
( vfptr pointer (“aZ'>Print()")
,un11<in‘ !;
mm; Mn mnm ( url""("l“7; )
3;“ mun
t
A a;
A‘ :2 Z h;
I.Ir1n!();
“Mm-m;

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
How Virtual methods are modeled by
C++ compiler 1
~:~ Keep in mind the vfpt! is just a pointer. As such, it can be changed during execution
APP-(PP ~:- This code will however print “AB'C ‘r
2"“ “ Using memcpy function allow us to ‘
lullkim ‘ overwrite the actual vfptr-ul of ‘
“nib void mum ¢ pmmwy; ) Object “a” with the one from “
h object “b”. As method Print has
<1“; I . .
t the same signature in both classes
“"“kim 1; (A and B) the result will be “AB”
vmm Mn mnm ( pmvmu: )
3;“ mun
t
A a; ,
.Jmlni
sauna“);

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
How v1rtual methods are modeled by
C++ comp1ler 1
~:~ Keep in mind the vfpt! is just a pointer. As such, it can be changed during execution
APP-(PP ~:- Every constructor called will set I
21m t the vfptr to its correct value‘ In ‘
um“ this case , “A n3=(“aZ)” will call ‘
331:1: void mm; ¢ pump“; , the copy constructor for class A ‘
h and will set the vfptr for local ‘
(1:5; I .
t variable a3 correctly,
nun11<¢
m3; m mm ( “MW ) ¢:~ As a result, this code _w|ll print “A”
); on the screen , even If “:12” has
‘(m mill!) the vfptr of “b”
a =;
memtpylh, u, “mama->1;
a- .1 . h;
A .3 - (my;
n w - m;
) “warmly:

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
How Virtual methods are modeled by
C++ compiler I
~:~ A virtual function can be overwritten in the derived class, “
~79‘ch 4» In this case, "x" will be 1 as "n" ‘l
21'“ ‘ is in (act an object oi type "b" ‘
mm; that has overwrite method i
m x, y; ll ,, l
"mm m Sumil) l ml". l . y; ) 5"""1
vim-1 m inf-until) t mi." X - y; ) ‘
y vmm m mam; ( rnm w; ) ~z~ For the rest of the methods
Am a z pm“ 11 lDiferentu and Produs) the
tum“ behavior will be identical to the
y m Swill!) t mm a; ) one from the base class (A)
will mainl)
s h;
M - a;
my - 2;
m l - -->sum:();

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
How v1rtual methods are modeled by
C++ com p1 ler
\nstarvce of type A \rvstance 01 type B
Address of VFl'ableA Address of VFI'able B
VFTable for class A VFTable for class B ‘
Address of A::5uma Address of B::Suma ‘
Address of A: :Diferenta AddI'ESS 9f A1 IDl'fefenti
Address of A: :Produs Address of A: :Produs
RTI'I RTI'I

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
How Virtual methods are modeled by
C++ compiler
~:~ A derived class can also add other inew) virtual methods . 3
AWL” 4» In this case, class B also have a ‘i
gl'“ * new virtual method called ‘1
nunnct “Madule") that is not present 0n i
m x, y;
virtual m Sumil) l mum. x . y; l class A, ‘
vim-1 m Diflnllﬁl) t I'l!||r|| x - y; ) l
y virtul! m Irﬂﬂllil) t rnm w; ) ~z~ This means that any class that will ‘
tie“ a z mm: t be deﬂved from B will have this
1mm method as well.
,
m- mainl)
’— ,

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
How v1rtual methods are modeled by
C++ com p1 ler
Instance 01 type A Instance 01 type a
Address of VFl'ableA Address of VFTable B
VFTahle for class A VFTable for class B
Address of A::Suma AddI'ESS Of BIZSHMa
Address of A: :Diferenta Address 0f AI :Diferenta
Address of A: :Produs Address 0f AI IPmdus
R'l'l'l Address o‘ B::Mudul
RTTI

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
How v1rtual methods are modeled by
C++ comp] ler
‘:~ When a class is den'ved from twolor more) classes that have virtual functions,
the compiler creates multiple vfptr pointers lone (or each base class),

<1.“ ( (ptr->Impartire();

"mi" =1‘ muv ecxmunrd ptr [cptr]
mmi m mm ( mm. 11 1 ‘dd "X" mm f” ‘W’ B
virtuil m Difcrcnlio l mum 2; ) mv uxmword pxr [cntr]

n mnv EdX,dH0rd ptl' [sax-v5]

33:0 ( "m aax,dwnr-d ptr‘ [EdXM]
im mm “11 "X '
virtuil 1m mummu l mun- s; ) cpwwmremau;

‘ mun m wmmn ( mu". l, ) my :ax,dword ptr [cptr]

15m Wm“ , mm { mv edmwom ptl' [eax]

public: Imv ECX,I1HDH1 ptr‘ [cptr']

) 1m x, y; mv eax,dunrd ptr [EGXM]

“a. M, ( "11"‘—

é,“ Z w

cptrr>lmvirtir=l);
(P!r'>D1faranti()v

)

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
How v1rtual methods are modeled by
C++ com pl ler
~:~ When a class is derived from twoior more] classes that have vlrmal (unctions,
the compller creates multlple vfptr pointers (one fur each base class).
APPIPP
33:3 ( VFTable for class A
332$ an‘ l) l rm". 1, r Address or A::Suma
b "run 1m 0 < "m". 2' > Offset FlEld AddI'ESS O‘ A::Diferenta
53:31:“ ‘ Rl-rl
>, x ' I x ' ‘H ) VFTable for class B
d.” e Mm ., Mm I l 4
wwg “ Address of Bzzlnmultlre
)3‘ (H Address of B::lmpartlre
) rpm» (7,

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
How v1rtual methods are modeled by
C++ com p1 ler
~:~ The same memory ahgnment is used for ctasses derived out of class C reg. in
this example, Class D)
APPIPP
an; A r VFTable for class A
pub)‘:
h. ., ..
14;“:1 gm 4) 4 mm ,, r Address or A..Surr\a
b ""“1 ‘"‘ 0 ‘ """" 1' > Offset nerd Address of AzzDiferenta
53:31:“ ‘ m-n
virtuil in! rcturn 4, “
>, ‘7 < ) VFTable for class B
chi: c mam A, mam I ( .. 4
w-h g Address of B..|nmult\re
1i.” D mm I ( Address of B::lmpart|re
Mm ml

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
l covariance

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
~:~ Let's analyze the following code: ‘

APP-(PP ~:- This code will not commie. l

:1“ “ However, in reality “b->cl0n£’()"

mm returns an object of type B so it ‘
m .1, .z, l
“mm A“ ‘mew l rlmrn m Au, l Shomd work. ‘

l,

‘1=§§ a Buhlis A

l

Duh!1(

An! b1, b2;
virtual w “mo 4 mum m n» >

l,

vlid maln<v

l
B'b:l|!kll), V .l V l H l l
K ‘Wk EMT)!‘ LZ-ME, = 1 (amwt (MN/EN: mm A m a '
ptl‘! Z ammo, mg; East Hum m? m demved requires nynanligast

) 0r stat1(_ci5

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
Cova r1 ance
~:~ Let's analyze the following code: I‘
APP-(PP - We have two solutions for this ‘1
21m l‘ problem: ‘3
mm: =
m .1; l
virtual A‘ dun“) ( mum n51 AQ; ) I
2;.“ . 1 mm . ‘
Em“;
m M, uz;
‘Anna! A“ :lnMU ( rnurn new BU; )
a“ mlillU
(
l ‘h . II!" ll); ,
l “Phi;
ptrl : bdclunll);
) ,,

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
Cova r1 ance
~:~ Let's analyze the following code: ‘

APP-(PP ~:- We have two solutions for this I
21m “ problem: ‘
"min ,,_ n; 1. Use an explicit cast and convert 1
)~ virtual A‘ mum z mun- m Au; i the pointer from A‘ m B’ l
5m I 1 mm A
Em,“

a»! bl, DZ;

mm: n awn ( r nor m: )
3;“ mun
(

a -,, . m > ;

mf'mmm-m
)

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
Cova r1 ance
~:~ Let's analyze the following code: “
APP-(PP ~:- We have two solutions for this I
2"" “ problem: ‘
"min u. ,2; 1. Use an explicit cast and convert 1
)~ van-m A‘ (mm i mun- m An; i the pointer from A‘ to B’ i
Eh“ I 1 Wm‘ A z. Use covariance‘ This means that
“"“mim u ' ~ we can modify the return type of
virtue“ the method clone in class B to
a“ mm return a B’ pointer instead of an
" ' ter
( B'h-nrdlll; A pain ' ,
t m";
ptrl e Nan-l); '
)— ,

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
Cova r1 ance
~:~ Let's analyze the following code: “
AF'P-CPP ~:- We have two solutions for this I
{he l problem: ‘
"mt"! a1, =1, 1. Use an explicit cast and convert 1
>1 \Armal A“ A) r mm. m. no; r the pointer from A’ to B‘ r
:1“; I um‘ A 1. Use covariance. This means that
“"“km h,’ bl; we can modily the return type oi
van-m v 0 l mum "a not l the method clam? in class B to
5;“ (7 return a B’ pointer instead of an
l a “l: e m m; A'pomter. ,
Zeiiﬁe n_ Covariance is related tn the pointer
A ‘a e (mu, type. In this case, even if the
ptre - (u')a-> 0, ‘\ . H ,,
l compiler calls Blrclone , their"
expected value lS A‘ (specﬂif'it' to a A"
pointer that is “a” 9 “Af}clone"| A

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Cova rl ance
~:~ Let's analyze the following code: “
APP-(PP ~:- We have two solutions for this I
2"" “ problem: ‘
"min u. ,2; l. Use an explicit cast and convert 1
)~ “mm il- mum ( rm"- w All: i the pointer from A‘ to B’ i
Eh“ I 1 um‘ A 1. Use covariance-l This means that
“"“mim M hr we can modify the return type of
via-iii Emmi ( mm nor ill: ) the method clone in class B to
3,1,. mm return a B’ pointer instead of an '
( B _h _ m m; A painter, ,7
1”“2': H v That is why this cude will NOT
compile, as the result ior a->cl0ne is
i P ' A" and not B‘. During executign;"'
“B::clone" will be call, nevertheless

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
Cova r1 ance r
~:~ Let's analyze the following code: ‘
~:- This code will not complle. The I
ghee ‘1 return type for virtual functions ‘
mm‘ I i Z can be changed, but only to a type ‘
r:":.r am, r m w, r rher re derived rrem we rewrn r
5m B mm A type uf the virtual method ‘
r described in the base class, ln this
“min b,’ . case, int’ is not derived from A’
mm“ m0 l "rm m in“); >
5;;4 ma1"(7
‘ error c2555: 'B::cl0ne‘: overriding
l vrrtual function return type drffers
and ls not covariant from
‘A: :clone'

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
Abstract classes
> (Interfaces)

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
lh c“ we can deﬁne a VVtual method without a body ht is catted a pure
virtual method and It vs deﬁned by addlng “:0” at the ehd of vtS deflmtlon),
If a (Lass Contams a purc virtual method, that class \s ah abstract class 1a
(Lass that can hot be instahtvated). \n other Languages thvs concept IS slmitar
to the concept 01 ah mterface.

Havvng a pure vvrtuat method forces the one that \mplements a derived ctass
to vmplemeht that method as Wett If he/she would hke to create an vhstance
from thc hcwty crcatcd (Lass.

The code witl not compile as "A" vs an

in“; abstract ctass.

m1“

h

win mm erl'trr‘ [1259: at‘: tirth instantlate amtmt class

< 3- Mn‘; duh tn Hﬂlm-nng “Mme

, ' vmle: 'mm A Salmon!‘ )5 .mstratt

hate: see detlaratimv cf "-\::S!:t‘

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
Abstract classes (Interfaces)
> ln c“ we can define a virtual method withﬂut a body (it is called a pure ‘1
virtual method and it is defined by adding “:0” at the end of its definition). ‘I
App.cpp a‘ This code will compile because class B has ‘1
class a an implementation for method Set I
‘mar e In order to be able w create an instance of
313;; 33:1“) _ a; a class, all of its pure virtual methods 1
2L“ B_ A {defined in that class or obtained via I
r ' inheritance) MUST be implemented I ‘
Mu‘:
In! :1, :2, :3;
) vain Setol- n
vuld mno
t
a a;

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
Abstract classes (Interfaces)
> In C++ we can define a virtual method without a body (it is called a pure ‘I
virtual method and it is defined by adding “:0” at the end of its definition). ‘I
App.cpp a‘ This code will however compile‘ It is ‘1
m“ l possible (and recommended whenever I
("up working with polymorphism) to create a l‘
in n, .1, .1; pointer towards an abstract class lin this 1
M “m” "“M m‘) ' “i case an A‘ pointer). 1
class a: A I
‘mu:
m ,1, ,1, ,1;
) win snor- n
m4 "v.0

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
Abstract classes (Interfaces)

> Other languages (such as Java or c») have a similar concept called interface
(primarily used in these languages to avoid multiple inheritance), ‘I

> interfaces are however different from an abstract class‘ An interface CAN ‘K
NOT have data members, or methods that are not pure virtual, An abstract ‘a
class is a class that has at least one pure virtual method, An abstract class can l‘
have methods, constructors, destructor or data members. E

> In C++ it is often easier to use struct instead of class to describe in interface ‘1
due to the fact that the default access modifier is public ‘

> CLexe (Microsoft) has a keyword Linterface) that works like an interface
(allows you to create on). However, this is not part of the standards

***************Ending Page***************


***************Beginning Page***************
***************page number:99**************
\
Memory alignment
in case of
> inheritance

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
Memory alignment in case of inheritance
{ i
public: ‘I
int a1,a2,a3; ‘1
)1 +O‘A::a1 ‘I
+8 A::a3 B
class B: public A + ‘z Bzzbi
inn‘: +16 B::b2
int b1,b2

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
Memory alignment in case of inheritance
class A ‘K
i z
public: 1‘
int a1,a2,a3; Field c1 c2 g
)i +0 A::a1 3
I +8 A::a3 B
class B: public“ +12 Bzzbi
sublk: +16 B::b2
intb1,b2

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
Memory alignment in case of inheritance

class A “1

i ‘

public: I
int 31,3233; Field c1 c2 g

)i +0\A=;a1 1

+8 Azza3
zlass B: public A +12 W
public: +16 B::b2

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
Memory alignment in case of inheritance g
class A class B:
( ( 1
public: public: ‘
}_in:a1,az,a3; PM b1'b2; Offset Field c1 \cz ‘c3 ‘
I i +0‘A::a1 1
+8 Azza3 B C
class Czpublic A,B ‘12 511M
( +16 B::b2
public: +20 C::c1
int c1,cZ;
}; +24 c::¢z ,
sizecﬂC) = 28

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
Memory alignment in case of inheritance
class C:publi-w
(

class A class B: public:

( ( int c1,cZ;

public: Public: h

Int a1,aZ,a3; Int b1 ,bZ;

}; }; Slzwm‘(C) = 28
+0 B::b1 ‘E
+4 B::bZ B
+s A::a1 A
+12 A::a2 C ‘
+16 Ana}
+20 C::c1
+24 C::c2

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
Memory alignment 1n case of inheritance
warning C4584: ‘C’ : base>c|ass 'A‘ is already a base-
class of 'B'.
~:~ Multiple inheritance can create ambiguous situations‘ For example, in this

CaSE the fields from Class A are

copied twice in class C. Offset

App.cpp +0 A::a1

:1,“ t +4 i A::a2 A \

pilhlh: +8 A353

m n, n, 1;;

2L5; a mm t *11 5mm

i

pm“: +16 \ BzzAzzaZ B::A

y; m m’ b2; +20 B::A::a3 B c
a“; c mm a, mm a

i +24 B::b1

mm:

)l m <1, <1; +28 B::bZ

1°“ U +32 C;:c1
)— +36 C::cZ

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
Muluple inheritance can create ambiguous situations. For example, in tins
Case the ﬁelds from class A are Copied lwvce In Class C.
m“ ¢
Duhh:
1m 31,32,3X, A
Eim Mn: ‘ B A
Duhh:
m m, "I,
This code will NOT compile H!
<1.§§ Publl< , pu>|.< ‘
Mm
m [1. [1.
gm H ",1 mm; [4m “Mugs w H mm, w mm“: uF w
‘ ~ * mm;- m @1th m1 w
MP W ‘1F. 1.4mm u; ‘w
, gm» cuss WWW; “<55: u: ‘a1‘
nnte. Wm be me '11‘ in Dire w
noté' N mm b! cm J1‘ 1n In! 1

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
Memory alignment in case of inheritance
~:~ Multiple inheritance can create ambiguous situations. For example, in this
case the ﬁelds from class A are copied twice in class C,
APPJPP ~2~ The solution is t0 describe any field/data
am r ( member using its iull Scope. For example:
“will! =1, =1, is; r “c,A:fai" rneans data member “a1” from
g.” 3: ‘ ( the direct inheritance of A in class C x
"1"“; N w , “c.B::A::a1” means data member “a1 " ‘3
); ' ' from the inheritance of “A” in class “B” E
dm l = ill-11‘ ill-11‘ r t that is directly inherit by class "C" ‘i
Imam: r‘
y 4m <1, <1;
f“ ""0 ~:~ What can we do if we want to have only one ‘
I <- copy of the fields from class "A" m our
(“mm Z 1»-
)— ~2~ This problem is also known as the “Diﬂmnnd
Problem”

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
Memory alignment in case of inheritance
~:~ Multiple inheritance can create ambiguous situations. For example, in this “

case the ﬁelds from class A are copied twice in class C, I
APPIPP ~:~ One solution to this problem is to use the ‘1
‘17$; ( virtual specifier when deriving irom a i
W in =1, =1, is; class‘ In this case, class “A” is inherited “
gm a: ‘mm-A ( virtually (meaning that its fields must be r
mam: added once).

m m. b2;
1;,“ t = "HEP- m,‘ B ( ~:~ For this code to work, both "C" and “B”
mun: class need to inherit class “A” using

m <1, <1; i
,5 vrrtuui keyword.
m4 mm

t <;

m; - w:

(.32 e u;

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
Memory alignment 1n case of inheritance
az~ Just like in the case of virtual methods, if no constructor is present, one will
be created by the compiler. Huwever, this constructor is a little bit diiferent
than the others (as it has one parameter of type bool),
<1.“ r >
“mill n‘ =1‘ is; “"5" 1 TRUE
,5 lea ecX,[c]
a.“ = rum: vlrtull r call c; =c
mm: <.a = ;
,7 "" h" “i m eaxmora w [:1
Am = mm mun mm ‘ mv sum-ma w [eaxM]
mm: my dwor'd pt!‘ [(+ecx],18
> m d, c1; [.m = 20;
3;,“ mm m dword pt!‘ [meme
c
I!
. - m;
c.h‘l . 1n;
’—

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
Memory alignment in case of inheritance
‘:~ The first parameter, tells the constructor if a special table with indexes needs
to be created or not !
<1.“ ( push ehp
mm m ehmsn
) m a1‘ =1‘ i3; mav dwnrd ptr [this],ecx
i _ cmp dword pt!‘ [ebp¢8],6
5,;- "1" """1 i je mummy»

m bl, >1; mnv eax,dwurd ptl' [this] ,
>1 muv dwnr-d ptr‘ [eax],addriindex
33:“ = mm mm: . mm Dom 5U VAR m:

m d, a; vush B
i; mov ecxmworn utr [this]

M4 mm (all a: =5
‘ muv eax,dwnr-d ptr- [this]
. - m; mv esp,ehp
(.M - 1n; pap ehp
>— ret 4

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
Memory alignment in case of inheritance
~:~ Once the constructor is called, an object that has virtual inheritance will look
as (allows:
+ o
+4 B::bl B
+ 8 B==b2
+ 12 C::c1 C + 0 0
+16 szcZ +4 VirtualA 20
Azzai
4 A::a2 A '
+ 2- ::a3

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
Memory alignment 1n case of inheritance

~:~ Accessing a data member l field that beneﬁts from the virtual inheritance, is

done in 3 steps (not in one) in the following way:

(1-,, ( )

a.“ v; mm virluﬂ (H) m1 : 10;

a»; l ‘z mm mm: , lam“ > i v) my eax,dwrd vtr [c]

Fad/L """ ECXHMM m [um]

i l Imv dwor-d pt!‘ [necxma l

\ ) I

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
Memory ahgnment 1n case of Inhentance
~:~ In the ﬁrst step, EAX register gets the pointer to the table where oﬂsets of
data member/ﬁelds irom A class are stored
AW"
(liss I ( )
t o mmvm.mumk w
t4 5::b1 B
+8 B::b2
t 12 C::c1 C
.16 C::cZ '
‘20 A::a1
.24 A::a2 A
‘2e A::a3

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
Memory alignment 1n case of 1nher1tance
‘:~ Second step - ECX gets the value from the second index in that table (+4),
more exactly value 20 (that reﬂects the offset of "A" ‘rem the beginning of "C")
dun ( )
a.” tum“ viral-1 ( } u: e 10;
a.” z uuhn: vmm t uuhn: 1 \ my eax,dwcrd w
¢o M“ P" “*“Xl ‘a
‘4 am
+5 am B C
.12 cm
‘l: i1": Oﬂset relative to ll
. ::a
.24 Anal A *0 0
as A::a3 ‘ 4 VirtualA

***************Ending Page***************

***************Beginning Page***************
***************page number:115**************
Memory alignment 1n case of 1nher1tance
‘:~ Last step, we use "ECX" register as an offset to access A::a1 from the
beginning of local variable "c".
din ( )
a“, mm mm ( } (.51 Z 10;
a“, mmmm ‘Mm 1 \ m eax,dwcrd m [C]
GEM- wmm tr M41
‘o mumcvmmmmnm "°' “mm P" -'-1a
‘4 B::b1 ,
+5 511m B C
.12 cm
‘l: i“: Offset relative to c
'24 Anal A + 0 0
‘28 Am +4 VirtualA 20

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
Fields/Data members that are obtained via Vlftlial inhentance are usually
added at the end 0f the Class allgnmervL
Offset Field
£115?— s 0 ptr class C virtual members offsets
t1“? mm mm, ¢ 4 C: :B::b1
(lass 5:3}: mm; . ‘ 8 C::B::b2
H4 + 1Z C::c1
+ 16 C::c2
Offset relative to c + 20 A::a1 (virtual Afrum cl
§ 0 0 s Z4 AIIaZ (virtual Afmrn CI
+4 Virtual,‘ 20 s 28 Azzal (VirtualAfrom cl

***************Ending Page***************

***************Beginning Page***************
***************page number:117**************
If we use virtual inheritance when deriving “C” from “B” lin addition to the usage
0f Virtual Inheritance ‘Dr ClaSS “A") we will obtain the following alignment:
Offset Field
lbs? $ 0 ptr class C virtual members offsets
tr“? mm “mu! l 4 C: x1
::::::-_::::::: ' r s c=:=2
H4 +12 A::a1 (virtualAfrom Cl
+ 1e A::a2 (virtual Afrom cl
Offset relative m c + 20 A::a3 (virtual Afrum cl
§ 0 0 ( Z4 pt! class B virtual members nifsels
+4 VirtualA 12 v 28 B::b1 (Virtual Bfrom c)
+ 8 Virtual B 24 , 32 B::b2 (virtual B from C)

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
In case of the Index tame for class "5“, (he Offset "712“ refers to (he posmon of “A“ class (am Obtain
m verum mhervlancei reLaUve m B wvfh respect m c class124iuﬂsel 015] V 12 : 1210mm Dun
Offset Field
tbs? + 0 ptr class C virtual members offsets
t1“? mm mm, ¢ 4 C: x1
H4 +12 A::a1 (virtuaLAfrorn Cl
+ 1e A::a2 (virtual Afrom CI
Offset Offset relative la B i+ 20 A“: (“mm Afmm C,
§ 0 0 / * Z4 ptr class B virtual members offsets
+ 4 Virtual A 712 s 28 B::b1 (vvrtuaL B from c)
, 32 B::b2 (virtual B from C)

***************Ending Page***************

***************Beginning Page***************
***************page number:119**************
If we make only the inheritance of B from C to be wrtual, the memory
alignment VS as follows:
i
—(h55 +0 A12a1
£1.52 mm ‘ 4 All“
it“; pm“ Mi
‘ > v~h1k_ ¢ 12 ptr class c wwal members offsets
4 . m C::c1
¢ 20 ClicZ
Offset Offset relative la C ‘ 24 BIIAII'“
*0 42 t 28 B::A::aZ
_ t 31 an“;
+ 4 Virtual B 12
. 26 B::b1
'40 BIIbZ

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
If we make only the inheritance of B from C to be wrtual, the memory
alignment v5 as follows:
i
(1,55— +0 A11a1
‘ > v~h1k_ ¢ 12 ptr class c wwal members offsets
4 . m C::c1
Offset Offset relative la C
+ O -1Z
_ t 31 B::A::a3
+ 4 Virtual B 12
t 26 B::b1
040 BIIbZ

***************Ending Page***************

***************Beginning Page***************
***************page number:121**************
If we make only the inheritance of B from C to be wrtual, the memory
alignment v5 as follows:
i
(1,55— +0 A11a1
‘ > v~h1k_ ¢ 12 ptr class c wwal members offsets
. m C::c1
‘ 20 Ctth
Offset relative la C
+ O -1Z
+ 4 Virtual B 12
‘ 1n D..Dl
040 BIIbZ

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
y my

***************Ending Page***************

