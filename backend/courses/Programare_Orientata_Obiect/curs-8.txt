***************Beginning Page***************
***************page number:1**************
‘\ Gavnlut Dragos
O O P Course a

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
b Constant expressiuns
> For each (Range-based for loop)
> Type inference
SU m mary > Structured binding (destructuring)
> Static Polymorphism (CRTP)
k b Plain Old Data 1POD)

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
Constant
> expressions

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Constant expressmns
> Constant expressions are pieces 0f Code that the compiler can Optimize by
replacing them with their value that is computed before compilation phase
> Constant expression can be easily deducted for variables {especially “const”
variables)‘ However, in case of functions this is more difficult‘
> Let‘s analyze the (ollowing code:
APP-CPD
um mm) a‘
l i
m X Z n; ‘a
mt y - x;

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Constant expressmns
> Constant expressions are pieces 0f Code that the Compiler can Optimize by
replacing them with their value that is computed before compilation phase
> Constant expression can be easily deducted for variables {especially “const”
variables)‘ However, in case of functions this is more difficult‘
> Let‘s analyze the (ollowing code:
APP-CPD
void mm) ‘x
> When creating “y” the compiler copies
the value from “x”

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Constant expressmns
> Constant expressions are pieces 0f code that the compiler can Optimize by
replacing them with their value that is computed before compilation phase
> Constant expression can be easily deducted for variables {especially “const”
variables)‘ However, in case of functions this is more difficult‘
> Let‘s analyze the (ollowing code:
APP-CPD
vain mm) ‘x
‘ "m X Z n; ‘a
> However, adding a “const” declaration in front of “x” makes the compiler
change the Way if creates "y" (new the Compiler will directly assign the value
10 (the constant value oi “x” to "y")

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Constant expressmns
> Constant expressions are pieces 0f Code that the Compiler can Optimize by
replacing them with their value that is computed before compilation phase
> Constant expression can be easily deducted for variables {especially “const”
variables)‘ However, in case of functions this is more difficult‘
> Let‘s analyze the (ollowing code:
APP-CPD
vain mun ‘x
i ‘x
1:: j j- lnlx=1¢2¢3; ‘L
> The same thing applies for expressions where the result is always a constant
value‘ In this case, the Compiler Computes the value 0f the expression
“1+Z+3” and assigns that value to “x” directly,

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Constant expressluns are 1n pamtutat Important when dedarmg arrays:

In! G:!Luun!()

(

)

van! mnM)

< ttw W» W M wt “amt, m a tut-“mt

m “Gammon n-t? “mfg w mm n) ~11 tn undenned nntmn w- w W ‘Mam 'mns'expr‘

> mt m “5m tn ﬁnimmt
Thvs code wvlL not compile‘ |n reality GetCounU] returns a “tonst” values,
but the compvler does not know vi vt can replace vt wvth n5 vatue (for example
GctCountU rmght do somcthwg clsc a like modifying some global variables).
The compvlel wm yveld an error: “expecung constant expression" when
deﬁning “x”

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Constant expressions are m particular Important when declanng arrays:
Fm ammo

)

van! mnM)

) mm 5L9 uﬁlgt M ﬁitimmt
Even if we add a “consl” keyword at the beginning 0v the functvon, the @5qu
vs $th the same‘
The compvlcr only knows that thc rcsull can not bc modvﬁcd (thvs docs not
vmply that me result ‘s a constant value. and that me wmpner can remace
me enure [an for that function wvth Its value).

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Constant expresswns I‘
> CX++11 adds a new keyword: “constexpr” that tells the compiler that a I
specific expression should be considered constant‘ “
APP-CPD ‘3
m amuntl) ‘
mum s; I
l l
vnid mm
‘ m mmamm;
>—
> Now the code will compile.

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Constant expressmns
> CX++11 adds a new keyword: “constexpr” that tells the compiler that a
specific expression should be considered constant‘
APP-cw
m amuntl)
} mm. 5; push ebp
w.“ mnnl) mov ebp.esp l
l sub esp, 20 ‘i
‘
> As GetCountO will be replaced with 5, the space needed for “x” will be 5 ‘l
integers (sizeoﬂinl) = 4, 4 x 5 = ZIJ l

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
constant expresswns I‘

> Using “ccnstexpr” comes with wine limitations: E
4 Acnnstexpr function should not be void ‘I
APP-CPD l
wristuir win imumﬂ 1
( [/rlturn 5; I
i
vain mm)
‘ m Mammal“;
)

> In (his case the compiler will state that it can not create an array from a void

value

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Uswg “constexpr” comes with some limitations:
A constexpr (unctlon should not have any local varvables umrutralrzed
tnn§¢5xpr ,HQ Eg¢enun¢l>
r errcv‘ we‘ mew“, ﬂmnum umwm tanwat result m a {Unstant Lures-5mm
mm s,
r
vala malnr>
r
m X[Ee!(mm!()]r
*—
AS a general rule, the compller mes L0 evaluate (W the compvlmg phase; the
result of a canstexpr functvon. If a local varvable vs unlnltralrzed, then there
rs a possrbrlity than several executron flows may lead to a drfferent results -)
thus the entire functvorr can not be replaced wvth another value.

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Constant expresswns
> Using “constexpr” comes with some limitations:
J A constexpr function should not have any lncal variables uninitialized. Ynu can
have, however multiple constant variable defined z
APP-WP Apptcpp
muster» m BentmmlO wusteYVr m amour'ﬂl
(
( wrist m x Z 100; m x - m; errui- Mi M {mu-pr mmm
mm M; ) mm W ‘minim 1n! mama-i- nu! a
3m “no vulﬂ mm '“‘“"""“‘“"“"‘ "
(
( m xlr-ettwntm: m XUEHCMMUI;
) )
Lucal variables are allowed in a constexpre function
starting with ("14. This code will NOT compile if a
Cﬁll Standard is used !

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Constant expressrons
> Using “constexpr” Comes with some limitations:
4 If constexpr function has parameters, it should be called with a constant value (or
those parameters. Further more, the result nf the evaluation should be a constant
value.
APP-(PP
“Mum m amounts": n l‘
‘ return mx; ‘l
l ‘l
vnid mun l
l l
> In this case the code will compile correctly 1“X" will have 20 elements)
> Some compiler have some workarounds for this rulel lrl terms of optimization,
il the exact value of a function can not be computed, inline replacement will
not be possible.

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Constant expressmns
> Using “Constexpr” Comes with some limitations:
4 If constexpr function in ["11 must have only one return statement.
C¢v14 and abnve do not have this limitation anymore.
APP~CPP
constelwr- m netcmntun x)
‘ l
in“ um) ‘x
‘ m WWW“; l
> This Code Will not Compile with Cx++11 standards, but will work for C++14 ‘
standards (amt The compiler evaluates that GetCountHO) can actually be
replaced with 6 without changing the logic behind the construction,

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
v mov award ptr [>1],eaX
Constant expressmns
muv eax,tl\v0r‘v1 pt! [x]
bush sax
push Mm: Sfrmg "1"‘1
£31] {"1an
m =5p,E
> Let's anal e the lolluwl'n Code:
APP-cw
(unimr- m Min-0 l Mum s; l
m "mo
l m X - memo:
"mm-w. x);

’— l
> Code was compiled with V5 2017, with C++17 Standards enabled‘
> While “X” is clearly 5, the compiler still generated a function (SomeValue) l

and calls it to get the value of “X” x

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Constant expressmns W mm w [x],
push
Push OffSel String "w
cal] prliltf
add esp,5
> Let's anal e the lollowin Code:
APP-cw
(mimr- m Min-0 l rm”. s; l
In! "mo
‘
prln' '- , X;

)— f
> Code was compiled with V5 2017, with C++17 Standards enabled‘
> However, declaring x as a constexpr will produce a different code (SomeValue

is replaced automatically by its value 1!!) X‘
> This is not completely identical as declaring “x” as a const l (if we would

have used a const specifier SameValue function would still be called l)

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Constant expressmns
> Let's anal e the lollowin Code:
Normal variable With constexpr With const
(mitﬂvr m mum) l cunsnwr m vam-u t (ml-m m Min-o l
mtum 5; mu". 5; mtum s;
> } >
m Ialn() m mun m um)
< l c
m X - maul); “mun m X - mun-“u: “In m X - MIMIC;
mum-M‘, x); printf(“ld“, x); Dr-lntF('Xd', x); ‘x
> ) I 3
till Milne mwv mm an ms nu aim“ 3
I" nwm w [XLe-ix M mom W mm.“ ‘x
m ‘ ulmmrd w [x] push ‘5 ‘ ‘ push ‘ 5
push w push um“ :zrin' “w push offs“ 5m“. ‘aw-
Wsll Wm 5m“; ‘w m1 printf nu mm \
call mm m 69,! m “M
ma 959'!
> Code was compiled with VS 2017, with C++17 Standards enabled (debug
mode)

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Constant expresswns ‘
> Let's anal ze the inllowin- code: I
APP-CPD I
(unsteKDr 1"! Sum:Va)ﬂ=(7 < return s, >
m min-n i
< i
canstexur m X Z snmevalueu; i
X Z IHH; i
)—
> Code will NOT compile (wiih VS 2017, with C+¢17 Standards Enabled).
> “x” being declared as a constexpr it's similar to “x” is a const -) you can not
modify “X” value‘
> However, keep in mind that constexpr and const are not identical i

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
Constant expresswns
> Let's analyie the following code:
APP-CPF' (1) APP-CPD (2) App.cpp l3)
ch55 A this A clan e
t t r
mm; while: want:
runsuxpr m x; nuns! m x; sud: ownswvr m t . w:
m z ‘(m 0 m = Km) n IO 0
); i; i ‘
mt "no 2
) return u; i
> For these pieces of code, vs 2017 was used with c++17 Standards enabled.
> The ﬁrst code 1m) that uses constexpr will not compile ! {AHX' cannot be ‘
declared with ‘constexpr' specifier)
> The second one [#2) that uses const will compile I
> The third one W3) will compile and will print 10 and i to the screen. In the third
code if we replace canstexpr with const, the result is identical.

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Constant expresswns
> As a general consent, consider constexptr as difierent from const ‘l.
> constexpr means that the exact value of an expression can be computed at
the compile time given a set of parameters required by the expression
(constant values). ‘a
> const means that the value returned by an expression can not be modified
after its value is attributed. That is why, const can be apply to a class
member, while a constexpr can not.
> constexpr can however be applied to class methods (including constructor,
operators, etc). This technique is useful when creating another constexpr
instance of that class.

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
Constant expresswns
> Let's anal e the Iollowin. code:
APP-CPP
m“ A
(
“"“iii X; push 5
mm may: ‘(vandal-1:7 n 1e: mule]
n call A: :A
in! mlillU
‘ Imv ezx,dvmrd w [m1
priMf(“M“, am]; push eax
I push affset string "x4"
call mm
> Code will compile and will a“ ESP’!
generate the following assembly code‘ '
> Code was compiled with VS 2017, with C++17 Standards enabled‘

***************Ending Page***************


***************Beginning Page***************
***************page number:24**************
constant expresswns ‘
> Let's anal ze the iollowin- code: I
APP-CPD i
K1=§§ A
( i
Publitz i
m X; i
i, “(m m“): ‘(Wm m“) U error C2127: ‘a’: illegal initialization ‘
2"‘ "W7 of 'constexpl" entity with a non-
constant expression
1 p . . ,
> Code Will NOT Compile‘ Cari not Create a value ll" this Case an instance] 170m
a function 4in this case the constructor function) that is not constexpr

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
Constant expressmns
> Let's anal e the Iollowin Code:
APP-Cpl:
m“ A
(uh)1(‘
" l»; l; A am;
cannexur mm mm; x(vi1l|!"vi1ll!) 0 zs
); Printf("%d“, a.><); l
m mun!) l
primf(“%d“, m); l
l l
> Code will compile and will
generate the following assembly code. "
> The constructor is no longer called, but x is set to its proper value,
> Code was compiled with VS 2017, with C+*17 Standards enabled‘

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Constant expresswns ‘
> Let's anal ze tne (ullowin- code: I
APP-CPD a
(lass A
( t
Publitz t
m X; t
a<,n= valué): x(value’valu&) < pr1n=t<“‘=ar~>‘ >
3;! mi1"(7
<
n am,
amen sa . :00;
A______________________________________________
> Code will NOT compile‘ Using constexpr implies that you do not need to call
the constructor (this can be done if there vs no code that needs to be called
—> pretty much just assign the values to data membel:
> |n this case, creating an instance of type A means running a printf(”ctqp")
command that can not be done if A1) ‘s constexpr.

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
Let's analyze the muuwwg (ode:
—<m A
(
WM!“ error (3515: :urISIEXDr funznnn 'A::A‘ :znnn! result m 2 constant
m X’ exvrzssion
> (“"S'upr My" WW?) U nuke: ‘allure was reused by consteXPV' (unstruztar nut minahnnz
(
mm» n 54s),
pm" M , a x).
>—
Code Wm NOT complie‘
The same Logic applies here as well. We can not construct an wstance of type
A w we do not have a value my all data members m class A,

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Let's analyze the muuwwg (ode:
—<m A
(
(“.5 Q! L m vs UP X “WEN
>. ‘ " M ‘ ' ’ m” U "m: Failure m caused by 'msmw- nonstruclor m “minim;
m Mm mm 'A; y
(
(“WW a 54s),
Wm M , a x).
>—
Code Wm NOT complie‘
The same Logic applies here as well. We can not construct an wstance of type
A w we do not have a value for all data members m class A,
In thvs case, A::>< IS mslantmed, but not A::y

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
constant expresswns I‘
> Let's anal e the Iollowin- code: I
APP-CPD I
<1“; A z
( l
puhllzz l
m x; l
mm mm 1 mammal ( ) l
“mun m snvnull) ( mu". s; ) ‘
:5.‘ mm
(
A ins»;
cunsnxpr m X - “mm-“l1;
mum-w, x);
}—
> Code will compile‘
> “x” will have the value 5,

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Th: compvlcr can not always compute (during the Comm timc) the value of
an expressvon‘ Let’s consvder the foLlong code:
—me A
(
Mk
Mme value) vaaluPWahAP) ( ) error £2131: expressmn rim not evaluate to a (alumni
"""EXPr wt nexvalnﬂ) ( rewr" x, ) nan: (allure was {iuSEd by a read of a unable autsme n; hfnume
L nuke. see usage of 'a'
m ml“)
(
A w.
WWW. x)‘
)—
Thvs code Wm NOT compile. However, X15 a constant vaiue, and 11.x win
always be 251duetothelmuahzauonfmm the constructor}. Thu means that
for this pamcular case, me compvler should have been ame m assign value 25
w Local vanable “x” from mam function.

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
Constant expreSSlons
> The compiler can not always compute (during the compile time] the value oi an
expression‘ Let's consider the following code:
APP-cw
alum!‘ w mum x, m y)
( mi. (my)
i
l‘ (m) my; em y-nx; l
l i
In! IIII\() i
‘ M X . mm");
hit ilz-dcﬂm. 5)]i i
prllitﬂ'x-M, hn(i)-Xd\|i',x, mum»;
)
> Code will compile and run correctly.
> In this case, the simple algorithm from Cmmdt function can be computed at the
compile time by the compiler.

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Note that clmlldc Functimi is nut replazed by its
value (In this case value 57 z
_ — However the size
> The compiler can not al 0F vector a is
expression. Let's consid- clearly known (and
it 1; "ﬁt comnut-zd
App.cpp dynamizallv]
wimp» mt c-dcﬂm x, l .
(
In]: (my)
l
) IF (my) my; m V ‘
Mum X;
)
1m "mo l
(
im x - c-dcﬂlﬂl);
mt au-iqm. 5)];
puma-Fm. luvi(i)dﬂ\ﬂ',x, mum»;
)
> Code will compile and run correctly.
> In this case, the simple algorithm from cmmdz function can be computed at the
compile time by the compiler.

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
Constant expressmns
> The compiler can not always compute (during the compile time] the value oi an
expression‘ Let's consider the following code:
APP-cw
consuwr w c-dcﬂm x, m y)
( nin- (my)
r
l‘ my) M; a” W; l
2w (m v e n; v < w; <~> l
m IalﬂO
( m X - (1414,11); ‘
In! -I[c-d<(m, 5)];
) Drlmﬂ'x-M, m<1).mm-,X, imam»;
> Code Will Still compiles and run Correctly (even ii We made cmmdc function more
complex)‘ We have also used a temporary variable ltr) but wilh constant values,

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Constant expressmns
> The compiler can not always compute (during the compile time] the value oi an
expression‘ Let's consider the following code:
APP-cw
consular w c-dcﬂm x, m y)
( nin- (my)
r
l‘ my) M; a” W; l
Mm X; i
m IalﬂO
( m X - (1414,11); ‘
In! m-mm, 5)];
) Drlmﬂ'x-M, 1M(l)-de',x, “1405(0);
> Code Will Still compiles and run Correctly (even ii We made cmmdc function more
complex)‘ We have also used a temporary variable ltr) but wilh constant values,

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
Constant expressmns
> The compiler can not always compute (during the compile time] the value oi an
expression‘ Let's consider the following code:
APP-cw
mew» w c-dcﬂnt x, m y)
( mn- (my)
i
u (m) my; em y-nx; l
iw (m v e n; v (I; v“) l
mm‘: ,, l
l l
w IalﬂO
( m X - (quJl); i
m :[c-ncuan, 5)];
nmm-w, 1M(I)IMU\',X, imam»;
)
> Code Will Still compiles and run Correctly. This time we have changed a constant
value with another constant value (y) ll!

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Constant expressmns
> The compiler can not always compute (during the compile time] the value ol eh
expression‘ Let's consider the following code:
APP-cw
Mew-o» w c-dcﬂm x, m y)
( mn- (my)
l
) 1‘ my) M; em W; l
For(l((r:li(r im ‘i
1 K ,; (El ‘ ) l
Mum x; l
m IalﬂO
( m X - (1414,11); ‘
m :[e-ncuan, 5)];
) PMMﬂ-IJIA, m(1)-Mm',x, “1406(0);
> Code Will NOT compile. In this case, theI compiler sees that "X" i5 also modified in
the loop‘ At some point an integer overflow will be produce and the loop will stop,
but this can not be in advance pre-computed.

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Constant expressrons
> For some cases, the Compiler can [Ire-Compute the result even for Complex
functions ex: recursive functions
APP-(PP
“mum m Flbwacclﬂnt n)
l v (n - a)
Mum a;
Mann x
Mum 1; z
return waiiulhi V n . waiiuKn V z); 3
) z
w-Anﬂ'xa', x); ‘
'— '
> Code was compiled with VS 2017, with C~+17 Standards enabled‘ The code
compiles Correctly and prints number 55 0n the Screen.

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Constant expreSSlons ‘
> For some cases, the compiler can pre-cumpute me result even for complex I
functions ex: recursive functions ‘
APMPP
wunupr m Flbwiainivit m I
‘ ‘F (n a) ‘
return a; ‘
if (n e: 1)
rewrri 1;
return ﬁboriacclin e n . ﬁboriacclin e 2);
>
m mild)
(
“mew m X e memlml
anF("%a", x);
> Code was compiled with VS 2017, with C+~17 Standards enabled. This code
will not compile -> me compiler can precompule some things but to sqme
degree (in this case, 100 step recursion is too muchll

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
Constant expressmns
> Constexpr can be used with literals t0 precompute values.
APP-cup
mmr mm 1w 1w w-rmr" Junmiww 1w 1w mm
‘ Mum "he - mu - mu;
2m “m0
‘ mm M X . 11...; x
) MW "i zoooooh \
> Code was compiled with VS 2017, with Cw17 Standards enabled‘ I

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
For each
> (Range-based for loop)

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
For each (Range- based for loop)
b C¢+11 standards add a new syntax ‘0|’ "for" statement that allOWS iteration
within a range (similar to what a “for each" statement could do)
> The format is as follows:
> A rangeiexpression in this context means:
J Ari array of a fixed size ‘
J Ari object that has "beginl)" arid "emm" iunctions (pretty much most of the r
containers from STL library)
4 An initialization list
> For statement is usually used with "auto" keyword (see the next section for I
details].

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
For each (Range- based for loop)
> Examples:
APP-CPP
wold nan
‘ m xl3I:(1.1- a);
hr (Int l : x)
Drum-w, n;
> This code will print all three elements of vector x. The following code does
the exact same thing but it works with a std::vector object‘
APP-WP
vnld nan
K
venmvlm) X -¢1,1,;>;
For (m l = x)
) wimﬂmd'. i);

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
For each (Range-based for loop)

> For can also use initialization Lists (but the code needs to include the l
initializer list temlatet ‘I
APP-{PP 1
“mm (immizstnsv I‘
mid .snn i
t Fur 11M i = u, 2. 1,1, 5)) timi i i Hue-Winn 1

wwm'wn n; rm | pi Fry’ m,
) 1'-h'r"||:'v' Virieiihlw
. v, t1 [Ir i-ip skim

> To do this, the compiler V 7“th ist Modems
creates a std::|n|ualized_list :sz j] ' ‘L “ '
object and iterates in it. ‘r1 'i-s, 11,.“ '

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
For each (Range- based for loop)
> lrl case 0f a normal array (where Size is know) the Compiler simulates a for
lam:
APP-CPD
m4 "mo
a» (m l = x)
IrlntF('Xd', n); x
l a
> The same will not work if the com-iler can not deduce the size of an array:
APP-cw
vnld um) 4 ‘
m ‘x - n91 mm 11.1.2»
m (m 1 = x)
mm'w, a);
)
> This Code Will not Compile 9 the Compiler can not know, in advanced how
many elements are stored in "x" array.

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
For each (Range- based for loop)
> The following Code will Hui Compile as X i5 a matrix and "Di a vector. The
com-iler can still iterate but each element will be a “Int 3 "
APP-CPD
m4 "mo
(
“Mum-((1.1.:).(-.s.s))z
a» (1m l = x)
wrlmﬂ'm', n); x
> To make it work, “i“ must be chane to a ointer:
{aw mm l
intx[][3]-((1, z, >1. u. 5, s11;
m (m- l = n
m (in! index - u; index < mum“)
mml'w, ﬁnial);
l

***************Ending Page***************


***************Beginning Page***************
***************page number:46**************
For each (Range-based for loop)
b References Can also be used‘ In this Case, the Content 01 that loop Can be I
modified accordin-l . “
APP-CPD
m4 um) I
( “Mu-(1.1.3): I
l -- z;
For (m | = x)
Mum-m‘. m
’—
> The nutput will be 2,4,6 {as the elements from x have been modified in the
first for loop, '

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
For each (Range- based for loop)
> References can also be used‘ In this case, the Content 01 that loop can be
modified accordin-l .
APP-CPD
vnln "mo
l
“Mu-(1.1.3):
a» (m n = x) x
l -- z; a‘
For (m | = X) l‘
Mum-m‘. m 3
—’ l
> This code will not work because x is a const vector. The compiler can't assign
a “const int Q" to a “int (1”

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
For each (Range- based for loop)
> References can also be used‘ In this case, the Content 01 that loop can be
modified accordin-l .
APP-CPD
vnld "mo
( constlmxl!'(‘h1.3)i
a» "It = x) x
For (M l = X) l
Mum-m‘. m 3
—’ l
> This code will still not work because even if now the compiler can pass the
constant reference, it can not modify “i“ as it is a constant,

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
For each (Range- based for loop)
> For each can also be applied 0n an object. However, that object must have a
bein and an end functions defined‘
APP-CPD
ch55 mkw
( w 11m;
Min:
HIV-(who i Fur (m w- - .; w- < n; m.) xm] - w; ) x
i; i‘
void "m0 l
( M-qw v;
m (um l = v) ‘
“ma-mu); a‘
> This code will not compile as no “begin()” and “endo” functions are available
fur class MyVector.

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
For each (Range- based for loop)
> For each can also be applied 0n an object. However, that object must have a
beln and an end functions deﬁned‘
APP-cw
d.“ We”
( IM XII/5!:
Mm:
"Iv-(‘MO { Fur (Int tr- - I; tr- < n; rm) X[tr-] - tr; ) R
he we < em em; ) x
)_ IM' “10(M1-m kl"); ) ‘x
W "m0
WWW; \
For (m x = v)
anﬂ'ﬂm'n);
’—
> Now the code works correctly.

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
For each (Range- based for loop)
> Be careful when using references. MyVeClUI'ZZX l5 a private field. However, it
can be access b usin references,
APP-CPD
nu! Mam»
( w XII/U:
Mm:
WW0 r a» um v- - a; v- < n; m.) xm] - w; > x
“.1- heglno ( mtum um; 2 l
)_ IM- mo ( Wm him]; > l‘
Wm mm)
( ,l
l -: 1;
)
> The code works and vzzx will be modiﬁed‘

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
For each (Range- based for loop)
> The Solution for this problem is t0 use (Oust for “beginO” and “end()"
functions‘
APP-CPD
nu! MK!»
( w XII/U:
Mm:
mum r hr (Am v- - a; v- < n; m.) xm] - w; ) x
.un' heglno ( mtum um; 2 l
)_ IM- mo ( Mm him]; > l‘
Wm -mo
l ,l
WIN‘ v; a
w (mu = v) ‘
l -: 1;
)
> Now the code will not compile as "v" can iterate through constant values and
“i” is not a constant (a value returned by “v” can not be assigned to “i”)

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
For each (Range- based for loop)
> There is also the possibility 01 creating yuur own iterator that can be returned
from the bin and end functions:
APP-CPD
mu Inwuw- t
phlk:
w‘ p:
ll.“ mtwi l‘
mum“ who ( Iynermr w; "H, . um; Wm up; > l
,- Mteritor e010 (winermr no: uw - Mm; Mum w: ) l‘
villi "mo r
mm» v; ,l
m (m l = v) a
) mun-mam ‘
> This code will not compile‘ For this to work the iterator must have:
“0perat0r++", “0perat0rl=“ and “Operator” implementations

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
For each (Range- based for loop)
> There i5 also the possibility 01 Creating your own iterator that Carl be returned
from the bin and end functions:
APP-CPD
m“ Immuw- (
phlk:
w‘ p:
Kylteratwl WrathO‘ P"; Mum 'thli; )
bwl mrltnr l- (MR-mum ll) i mum I l- I.p; ) X
_ m nper-nnr' 0 ( mtum ‘n; 2
2i,“ WW ( 3
"mu-w mum) r mknumr- m; nu - um; mum m; ) ‘E
_ mum» wo (mmmr u»; w.» - um]; mum w; 2 A
33m new) ( ‘
Manor v;
Fur (m l = v)
w-MF('X4,',I);
>
> NOW the Code works‘

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
l Type inference

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
u n l
auto keyword
> C++11 introduces a new keyword : "auto" that can be use when declaring a ‘a
variable or a function ‘I
> The format is as follows: ‘1
APP-WP I
m (virhthu-l) e (vihn); ‘
m (menu-m ([vlm-nu-rl) -> rctumjwl l-l ‘
> The compiler tries to deduce the type of the variable from its value‘ A similar
approach exists for function and will be discuss lateL

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
"auto" keyword
> Examples:
CH-H Translation ‘
vm “no vm mm) ‘
( (
am n : WLL; 1m: n : wLL;
2* 2*

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
auto keyword
> Examples:
C++l1 Translation
vein ninK) vnld IamO
( {
.‘r 2

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
auto keyword
> "auto" can be forced if a casting occurs during initialization‘
C++l1 Translation
vein “no vnld “no
r r
um X - 0m- 'ust" char‘ x- (luv-‘)"uu"
>
> However, the code will still crashes as “x” point to a const char’ value. l
> Using “new” operator also forces a cast‘
0+1 1 Translation
ma mm VON “no ‘
( inn X - n04 mime] ( m»- x- m (mu-1;
m1 - a; xm - a;
y >
> In this case the code works properly (x will be a char“)

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
auto keyword
> "auw" can be used with user defined Classes as well:
C++l1 Translation
=1“; mt (his v.“
( x
mm: rmm:
m x. y; m X‘ y;
h n
w.“ "my vuln mm
4 ( a
aura x . n54 mm; mu X - M “no; \
> > x
> "auto" can be used with “const” keyword ‘a
C++11 Translation
ma "no "m "no
4 x
cans! auto x - s; C005! m X - 5;
} >

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
auto keyword
> "auto" can be used with another variable / expression.
CH'I1 Translation
ma "no ma "no
l (
Ma x - s; m X - 5;
amyex; "Mex;
inn lx - x; m n - x;
mm ‘m - u; “it um- . Ix; ‘
r > x‘
v In this case because “x” is evaluated by the compiler as an “int” variable, the
rest of the "auto" assignments will be considered of type “int” as well‘ ‘i
> In case of expressions, the resulted type of an expression is used: ‘
C++l1 Translation
ma “no vnld "no
l r
"tax-5; Mix-5;
‘my-w»; “why-1w”
am:-x>1w; booll-X>W;
r r

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
n n 1
auto keyword
> "auto" can also be used w create pointer w a function: E
c»+11 Translation ‘p
m mm a, m y, m n m suﬂnt x, m y. m 1) 2
( returnxoyox; ( Mumxeyel: 2
3m "no 3am "no I
( am s - m; ( m ('¢)(|m,|m,lm) . 51-; ‘
arm result - m. z. a); m Nsuk - m. 1. a);
l )
> In this case because "f" becomes a pointer to function “sum”, and “result”
will be of type “int” because “sum” returns an “int”
> In the end, “result” will have the value él

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
auto keywo rd
> "auto" is also useful when dealing with templates:
CH-I1 Translation
um. runlsplu m; m" mum! nu;
‘Ar-mm warm» ‘um-me mam
Wu “no Wm “no
< &
vmﬂmm v' "(mum v' ‘
\
2 a
> In this case, it is much easier to declare something as "auto" than to wn'te the
entire declaration as a template‘ ‘

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
"auto" keyword
b "auto" is also useful when dealing with templates:
Cpp code
vmd malﬂl)
(
Gradesm-serrlpnnznnst mar‘. 1nt>l‘1nn:snl‘. 7));
range e Grades.equaliranKBlGI-adcsllndl ‘Kw-em: ‘)'>ﬂl‘5f);
l—_
> Irv this example we two variables deﬁned wit" and “Fange”|_

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
P "auto" i5 alSO useful when dealing with templates:
Cpp code
um. MW! m;
air-mm m.»
Wid niVIU
<
mkinlwmnst mr', m) anus;
Grmansgrllpalruanst m», lnol'mnum', 1.)); \
Gradesdnserﬂbaiuwnst Shir‘, 1M>(’Ian=s:u’, U); X
Grid=s.ins=r:(aiir<wnsc m», im:>(‘km=ssu“, m; x
-r.m . Mu.“numlmnu.“HQK-Iﬂnm-lwrm; \
M n“; - rangmimt; x: ‘- rin|:.52wrlﬂ; x2“ )
pr (-15 V> u w, 1mm“, imam-n); a
y
P Much easier !

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Type alias
b The same can Option can be achieved using typedef 0r type alias‘
> A type alias is functionally similar to a type def, and implies the following
syntax:
using <ahasitype> = <the actual type),
Cpp code {using alias) Cpp code (using typedef)
mum m» mum <1»)
mm ( um) ( ,
M . mm“ -, >; 514:: an ‘, > Ml;
) M m Z 4 4“puma-“AMA"mm-nu s) )1 ) '41 - - ( ("Pavesw".W).("Iww-". B) )i
Cpp code {using aliasj Cpp code (using typedef)
‘undud: (milb ‘WM! (IID)
‘ - 5mm“ -, v; "4:: M -, > n;
mm ( “no (
) w m : l (“PuksnﬂJ")v(“1§n:sil|“v s) n 1 w - : l ('kaicv‘,l.)|('l°nescu‘, s) ):

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
> "auto" is usually used with (or statement:
Cpp code
,1n<1“¢¢ <ve<tur>
vain mii~<>
<
std::v:<tur<int> a Z < 1, 2, s, 4, s 1
fur (autu 511m 1 a)
Prlnlf(“Xﬂ,“1 ,1!m>
l_________________________________________________________
> Or as a reference:
Cppcode
lincluna <v§<Kur> ,
:nla mil"(7
SKd;:v!<KD»<Sl¢¢¢p.1»<1nl, <har>> a - ( ( 1, ‘-‘ ), ( z, ‘a‘ ), ( 1, ‘n‘ ) )
fur (aulnﬁ glam 1 a)
Print¢< >iir= xnr>x< \n“. eiem‘first.:1:m‘sezunﬂ)
1

***************Ending Page***************


***************Beginning Page***************
***************page number:68**************
decltype keyword
> Besides “auto” 0m also prevides a new keyword “decltype” that returns
the type of an object‘ It is mainly used to declare a variable as of the same
type of another one,
Cpp code
m". nmeihlu m;
“norm (venom
Include (may) x
v.1. “no ‘r
‘ “me-mvmmm. Madmen“ mp,» -; ‘r
m x; x
mat y;
“(m/rum u; 1
dedYYPlKY) yy; '
de:1!yP=(i) aa;
>—
> |n this example “xx” has the same type as 'x", "yy" has the same type as “y”
and “aa” has the same type as “a'ﬂ

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
dec ltype keyword
P decltype can be used with constants as well:
Cpp code
ma "no
l
deem/um) x;
mama-(lam y;
dlzltyvllnullvtr) 1;
alumna“) a; i‘
—> l
> In this example: ‘l
3 "x" will be of type iril (because lo is an int) l
4 "y" will be of type float (because 10.21 is a ﬂoat] '
4 "z" will be oi type Void‘ (because nullptr is a void‘)
J "b" Will be a boul (beCHUSQ “true” 1'5 a bDOl)

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
II II 3
decltype keyword
> decltype can be used with arrays: I
Cpp code i
wild min!) ‘I
(
int vhl]; ‘
1m: HUGHZQI; ‘
MW“, l; i
decllyPllu) y;
*—
> In this example:
3 "x" will be of type int[10] —> just like “v” is
3 "y" will be of type int[10][ZO] -> just like "w" is

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
u u
decltype keyword
> decltype can be used with elements from an array e but the result will he a
reference of that tye.
Cpp code
vuld melnr>
r
m vrm;
> This code will compile because "x" is of type “int Er" and it is nut
initialized. For this a reference must be added to the initialization of x.
Cpp code
vuid miner»
( ,
m vpe];
1 aeeltywrvwh >< e v[Fl:
> Now the code compiles and "X" is a reference to the first element (Harri “v”

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
decltype keyword
> Using references t0 Constant Strings l vectors has some limitations. The
I ..'|- -t.||- - ti ll .- '
Cpp code
ma mm l
nnltwnlrn‘) x3
1
> “x” will be of type “const char 1*)[3]" because sizeof(“Te") is 3 (Z characters ‘
.,nc ‘\I' -, h ‘nu Bin-1 Ifrn ‘i n“. n I‘ ini i-‘iiz
Cpp code
ma Iiiiﬂl) ( l
n=ncyp=(rr=') x e r'cw";
> This code will also fail because &"C+#' means “const char (‘)[4]" that is not ‘
compatible with "const char (')[3]”l To make it work, one must use the exact
same number of characters as in the declaration‘
Cpp Code (correct (Ode)
vain mliﬂll r
) dedrypqrrvy X . we;

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
“ II l
dec ltype keyword
> The same logic applies when using a string directly as a constant in a decltype ‘a
statement, 3‘
Cpp code l‘
{an “no z
> dlzltypAK'fl') X - ‘(l-0:’); ‘1
k > In this case, "x" will be of type “const char[3] f1"

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
Structured binding
> (destructuring)

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
Slartmg wvth C++17, a new concept has been added to c“ language: structured
binding
Thvs concept lmphes that a structure and/or array can be gout down vmo vts basvc
eternertis, and each of tts elements can be assvgn to a variable.
The concept vs related Lo what other Languages illke Python] have —> the
possiblhty of returning a tupto vntn values (Instead or one valuc}.
der aetteniveemesO
In 047. structured binding vs done using auto keyword m the fouowmg way:
auto [v,, v2, v,,] e expression
autda [v], up vn] = expression
where vhv, v arc variablcs that arc going to bc bindcd.

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
Structured b1 ndmg
)nt a[2]:(1,2);
am lX, vl 1 a;
b Let's analyze the following Code:
APP-Cw
minl)
l
all] - ( 1,2 h
ll, n Z i;
X Z 1a;
a;
)
> In reality, what the compiler does is to
copy the value of a[0] to “x” and the X z m,
value 0i a[1] t0 “y” similar t0 the code I ,
b ll I
e 0w APP-CPD
IaiIlO (
an] Z l 1,1 )i
X - I[B];
y - w];
X - w;
Ii
’—

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
Structured binding
> Let's analyze the (allowing code: ‘a
1
m mun!) ‘I
i i
m all] - ( 1,: h ‘
almwlx, y] 1 a; l
X - u; i
pr1m(“--[xa,u| m nu“, .m, .m, X); ‘
rlmrn a;
l—
> This code will compile and will pn'nt upon execution the following:
a=[1,2] and x=1a

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
Structured b1 nd1 ng
> Let's analyze the following Code:
APP-cw
mlinll
r
ill] - i 1,: y;
x - 1a;
,r;ml;§-m,m m x44“, mi, mi, x); x
> Structure binding can also be used with references “auto&". In this case a ,7
reference to an object is created, ‘
> This code will compile and will print upon execution the following:
a=[1a,2] and x=10

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
Structured b1 nd1 ng
> One 0f the most Common usage of this technique is to bind the result~ of a
function! method that returns a structure to its basic components:
APP-cw
student
t
- mt;
nr.¢l;
n ‘x
student mum» a
’ mm ‘k
t H)
Mam, [rid-I - inn-m); r
primrmuaun: u, cumin nml, um);
a;
r
> This code will compile and will print upon execution the tollowing:
Student: Popescu, Gradezlo

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
Structured binding ‘
> Structured bindings takes into account the access speciﬁer. I
APPIPP i
{1m A
( i
Puhllt:
m x. y. 2; ‘
_ mm yam) = ‘who, mm: ~ 2), mm: ~ 4) n ‘
i?“ "no
l
l a0);
‘mix, y, x] Z i;
pnncfl'x-M, y-M, z-am', x, y, x);
mm a;
*—
> In this case, “x”, “y” and "z" are public and the binding is possible‘
> This code will compile and will print upon execution the following:
X=1, y=2, 1:4

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
> Structured bindings takes mm account the access specvﬁer.
APPIPP
(1m A
(
m x, y, 1; mm Um w- “Mm deiampose (via hm wan'uubhi mavwbérs
PM“ M :h-uAsy-Anmv "i 1.‘
Mm u'hr) = X(»"Wi- yww ' 1». um’ ' 4» u; errw‘ [124a w». Y WM 36:95; private member 1mm 1n
1: {1..5 ‘r
2"‘“‘"" ME m derhr-atmn M w -‘
am“. y. 1| Z a; 2;‘; M; , n \ p M P M H . ‘ a q w
, ' ME m derhr-atmn M ‘r
mm ul-m -A--1-, [MM mm mun: MM,- daalared m
> In this case, “x”, “y” and “1"are pnvate "m 5-?! 3“;th f A '1
. v v M! smnun M ‘:u
and the bmdmg IS NOT posslbte.
> This code Wm notcompile!

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
Structured binding r
> You ca nut bind only some data members r you have tn bind all of them.
APPIPP
em; A
t
went:
_ Aunt u=ilr) = “em, yrem . 1,, z(u=ilr . 4, U;
l?“ miiﬂll
( A ‘m; error C3448: the number of identifiers must match
Wh- y! r =5 X me number of array elements or members m a
521322?“ Md Y ’ w’ structured binding declaration
*—
> In this case, “x”, “y” and “z” are public and the binding is possible, but as
“auto[X,y]" only tries to bind two parameters (and class A has 3|, the code
will not compile.

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
Structured binding
> Structured bindings Copies vectors/arrays as well.
APMPP
l
‘ .
' Xm- y;
2- u WM) = ‘l mummm L yum: ~ s) n;
' "no
l a
A alt); a
ml : is i
“m - m; a
printﬂxddﬂd, y-m, “(X-[1.1M], "my, x[a],x[!], y,-.X[a1,-.X[11,-.y); \
> In this case local variable “x” is an array with two elements that copied the
content from A::x‘
> This code will compile and will print upon execution the lollowing:
x=1,2, y=3, a=(x=[1e,z], y=3)

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
Structured binding
> Structured bindings are Often used with fur-each loops and STL, especially for
maps where access to both components (key and value) can be obtains
simultaneously,
APP-WP
mom w»
m;
( mun l
< pm, "m1 zﬁrades) x
primﬂwmezk, armmw, "m, mam l
a; l
> This code will compile and will print upon execution the following:
Name: Popescu, Grade: 16
Namezlonescu, Grade:9

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
Structured binding
b STL also has two functions: Std::muk£_tupl£ and Stdliﬁl thai can be used t0
create a similar functionality (for CH compilers prior to C++17 standard)‘
APP-cw
m1."
c
i "In;
cm.-
ammuo l
: r
n ‘
um) I
l SM.” s Z ( ‘lawman h CZl
p” ‘me: , Fae: n , male, ‘Fae;
v;
’—
> This code will compile and will print upon execution the iollowing:
Name: Popescu, Grade : 10

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
Static Polymorphism
> (CRTP)

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
Static Polymorphism
> Static polymorphism (alw called Euriously Eecurring Iemplate Batter" 0r CRTP)
is a technique that takes advantage that a template is not instantiated
(constructed) when it is written r but when it's instance is actually created‘ This
allows one to use some functions in a template that are not available at the time
the template was written‘
mm- (W- v>
a.“ Base r l; l
a.“ Derived: Mm “5&th { .__>; l
> In this case r we can create a class {Derived} that has as a base class a template
that can further be used with the exact class that we are creating (the Derived
class)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
> Let's see an example: I
App.cpp This code compiles and upon I
\lwlﬂe (mm-e 1) execution will print on the
“malfgénmm, ( screen: Toyota and then Dacia ‘

“ma-mm, (statl:_(ast<¥'>(thl§))->l3euule())i ‘
> i
n
5171K! Wynn = whlk (ardﬂyota) i
m“ m» - will“) ( mum Wm‘; >
h
5mm mm = mm (armacla) (
cans! cm - Mlil-O { MW 'n-nl'; )
2;
m who <
mm u
Dana .1;
tyrmmneo;
mum-mo;
Mum 1;

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
Static Polymorphism
> Let's see an example:
APP-cw
(w K
Vr-lntlllIQO (
)
)i
rayon : (anmyon) (
' sum-e0 ( WWW‘; )
h Dana = (ar(')ana>( \
- emu-0 ( 1mm; ) L
“no (
WW”;
WWW
)

***************Ending Page***************


***************Beginning Page***************
***************page number:90**************
Static Polymorphism
> Let's see an example:
APP-WP
(m K
PPMUHIQO (
perF('%s\n', ( (Y')( ))->auule());
)
)i
le 'wym i
h Dana = (mnmm
' MRI-O { ‘Diﬂl'; )
)i
IMHO (
..M.-(>;
“WM;
)

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
Static Polymorphism
> The same logic can be used fur data members.
APP-cw
< v>
(w l
Mme-w (
) punﬂ'xnn', < <v->< ))->m~);
)s x
Yoyota = mum!» ( - "I! - mum‘; i; l
is“. = “you.” - um . 'nxh'; ); r
“mo ( l
voyota t;
Dana a;
LVMAUIIIQO; 2
emu-mo;
1;
)
> In this case, it is expected that class associated with type T have a data member
of type cans! char " named Name.
> The code compiles correctly and upon execution will print Toyota and then D

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Static Polymorphism
> It works in a similar way for Static data members (however in this case casting
this pointer is not required [we can use T:: to refer to static members of type T)
APP-CPD
< v>
m (
Ninth-:0 (
> prlmﬂ'ltsvr, rum“): i
i; l
Yuyun = tavﬂuyun) r ~ n-e; i; l
Dim = [Miami - n“; i; 3 ,
- Wmnnn - 'wavti';
- Damn“... - ‘ii-<11‘; i
la|n() (
YnyntaHPrinﬂliIEOi
DunnPMmﬂilO;
l;
)—
> The code compiles correctly and upon execution will print Toyota and then D

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
Static Polymorphism
Polymorphic chai n1 ng
> Another interesting thing that can be achieved in this Way is called polymurphiz
chaining‘
> It implies that the base class returns a value that is a self reference to the
template type l
(mun; ‘1mm! r> l
<1.” Base l
r a
rs. summit-mil: { l
i'nurn mm cast<T3>l‘th15); l
class wmm mm Basemerlved) t ...);
> In this case, we make sure that the method SomeMethad returns a reference to
the type T (template type)

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
Static Polymorphism
Polymorphic chai n1 ng
> Let's analyze this example:
APP-CPD
mum: mm“,
< r)
mm (
u m) r <v->( pm“ K l; <u>(- ); i
u “<0 r <v~>( hm“. ~- l; um- ); ) i
u vmm) r stancmn << um )va‘ << - -; (wr- ); ) 3
)' mlw 1 ~mm1mw> ( valve: i; l
Final = Number<Finat>( Value; }; l
um) (
1mg!’ l; Lulu: . w;
l.In=()-Pr|m()-he=()-In=()-IMO-WIN“): l
my e; mm Z 115;
) f.ln<().PrerO-DIK()-ln<()-ln<()-VMVRO;
> The code will print “11 12 LS 35". What happens is the i.lnc() will not return a
reference to type Numbero, but to type Integer, thus allowing the chaining to
continue.

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
Static Polymorphism
BartonaNackman trick
b Barton-Nackman trick implies using CRTP and an inner friend function definition
to move the friend function irom the base class to de derived one.
> This is in particular useful to automatically overload relationship operators.
(“New r
4 i. um, ll uhjl) ( uhnvtumuzrmthluhjl) a; )
l l iL Db», iL chm r ubjixumlurwthlubjll < a; )
)’ ‘ville 1 inwveve,iu<vvl~te > 4
vi1u=;
mum w: mum 0
Compirmithl m‘ g‘ 1 m) r
(mu < Dams)“; .1;
a;
}
h mm) 4
h WW 11m); mi v: (“if mteger mi 1?; ruin-i V
H my mm: m mun-1":
m < n) printﬂ"il is Smaller ma“ u"); rum View n» l i m 1w it
)

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
Static Polymorphism
> Static polymorphism has the (allowing advantages: l
2 We no longer need virtual table, dynamic types, etc tp perform polymorphism. l
, Since the llnkage ls statlc and not real-time, the performance ls much better than with l
the usage of virtual iunction (no vpttr call) ‘3
> Static polymorphism has the following pitfalls:
~ lrl reality, there is not a common root like in case of inheritance l ii classAis derived
1mm Base<A> and class B is derived irem Base<B> we CAN NOT say that they are both
derived out of Base lll
c This means that casting to the base class is not possible -) so we can create a pointer
of type Base that has multiple elements (one that palms to an object A, another one"
that points to an object B)

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
Static Polymorphism i
> Differences between static polymurphism and dynamic polymorphism. I
Staxic polymorphism Dynamic polymorphism i
(ermine (“puma n strum Ease i >; 5mm Base i i; i
class A v wbhc new» ( i; (1:55 e: pub)“ em < i; 1
ms; B = wbhc Based» i n (his a. punk Base < i, ‘
hi! “no i m new, i
A a‘ A i;
a b; a h;
Base ' basell]; Base ~ haseu],
baseﬂ] e h; biieﬁ] e a,
baseﬂ] - m; mew e lb:
mm a‘ return a;
)— *—
Code will compile and run
as expected‘

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
Plain Old Data
> (POD)

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
POD
> Plain old data (POD) means a type that has a C-like memory layout.
> In many cases a class / struct in C/C++ has other fields such as virtual
functions or indexes for members from a virtually derived class ‘1
> This means that a compiler has some problems when copying such objects‘
> To ease this process, a type of data can be:
2 Trivial
J Standard layout
> POD data is important for initialization lists,

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
POD
> Trivial types means that:
C Has a deiault constructor {that is not provided by the programmer) ‘t
, Has a deiault destructur (that is not provided by the programmer]
~ Has a deiault copy - constructor [that is not provided by the programmer) ‘3
C Has a assignment operator l=l (that is not provided by the programmer)
-, |t has no virtual lunctions
. It has no base class that has a user provided (speciﬁc) constructor / destrucmr /
copy-constructor or assignment operator
C It has no members that have a user provided (specific) constructor / destructor /
copyrcanstructor or assignment operator
~ Ii. has not data member that is a reference value
Trivial types can be copied using memcpy from an object to a memury bufferor'”
an array The compiler can change the order of data members
Trivial types can have different access modifier for their membersm/"W

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
b STL provides a function t0 Check if a type is trivial 0r not Z std::is_trivial I
APMPP i
"mm <1ype_u~zl(s> i
mum Gonna» ‘
<1.“ mu r ‘

1m x, y; ‘
);
(his mar
m x, 1;
nh-Lk:
) w<mﬂmnnywlmn
“m "m0
“dugout << mummy“. << sm::|s_(r|vhklypem::vzlue << swueoﬂ; ~
5mm“ << mempm << s!d::£s_<r£vhl<¥ype6>::vah|e << mum“
)

> This Code Will print "true" fur TypeA and “false” for TypeB (becange'it has a

user defined constructor)

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
b STL provides a function t0 Check if a type is trivial 0r not Z std::is_trivial l‘
APMPP l
"mm <1ype_u~zl(s> i
mum dosrmlv ‘
<1.“ vya-c ‘
( i

m X, y;
Mm:
m 1;
(unit (m- m;
r mm(m,x,m,, m,1>(X-,X;y-J;1-J;)
m1 mm
l cunt << nnumunm: << smnlsitr-lvhlﬂypxnwllus << “a;
> This code will pn'nt “true” for TypeC

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
b STL provides a function t0 Check if a type is trivial 0r not Z std::is_trivial l‘
APMPP l
"mm <1ype_u~zl(s> i
mum dostmlv ‘
<1.“ M ‘
( i

w x. y;

mm -

m

m; ( r w;
r mum(m,x,m,, m,1>(X-,X;y-J;1-J;)
m1 “no
{ cunt << nnuhm-hlm: << m==uy|vm<w>=mm << “a;
) H

> This code will print “false” for TypeD (because it is using a initialization”,
function —) it will be discuss in the Initialization list chapter)

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
> Standard layout types means that: ‘i
2 Atype that has no virtual functions or virtual inheritance ‘i
, |t has not data member that is a reference value ‘i
~ All data memhers lexcept static ones) have the same access control I‘
c All data memhers have a standard layout ‘i
c The diamond problems is not applied (or the type [it has nu two sub-classes that
are derived lrom the same class).
, The first member monastatic) of the class, is not of the same type as one of the
base classes (this is a condition related to ernpty base optimization problem)
> STL also provides a iunction that can be used to see if a type has a standard layout
cir not: std::is_standard_layout
> A class or a struct that is trivial and has a standard layout is a POD (plairi'old
data)‘ Scalar types iirit,char, etc) are also considered to be POD,

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
Empty base opt] mlzatlon
> Let's Consider the following Code:
APP-cw
(1m we n;
(his meme = mu
m x;
2;
W Iaan l
l wr-lmfl'su-orllan) - mm‘, “mam-n; l
prlntﬂ'sumﬂnvlvm) - 1mm‘, gumﬂnv-lv-d»; ‘x
> a
> The code compiles and the result is 1 byte (or Base class and 4 bytes for l
Derived class. "
> Base class has 1 byte because it is empty lit has no ﬁelds»

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
Empty base opt] mlzatlon
> Let's Consider the following Code:
APP-cup
(1m we n;
(his wee = mu
); ' l‘
\(mid “no l
wow-5mm!» . 1mm‘, them-u»; l
prlntﬂ'ilzmﬂherlved) . Mm‘, sumﬂherlved»; a
) l
> The code compiles but now the size ol Derived class is 8. Normally as Base l
class is empty, the result should have been 4, but because the first member of "
the class is of type Base it forces an alignment.
> This form of layout iS Considered to be non-Standard‘

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
> Examples: I
APMPP ‘
“5w Mlesplce 5m; ‘
mum <(ype_(riks)
nah-1e may“) 1
<1“! W ‘
( m X. y;

Mm:

m 1;

(m5! m» w;
)_ vol-15a(|m_x,lnt_y,|m_1)(x-_x;y-_y;1-_1;)
“m "m0

> This Code will print "true,false" for MyType. It 1's not a Standard lqyulii

because if has both public and private members‘

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
> Examples: ‘
APNPP ‘
as... MW,“ “A; ‘
mm <(ype_(riks) ‘
MM mm“, ‘
m X. y;
m 1;
m. m.» w;
) wmwumg,m;,|m_x)(x-_x;y-_Y;1-_1;)
vnm 1|an
cw! << bani/1M: << ls_(r|vhkly|ype)::vxl»e << ',' << |s_su\daN_hyM<Inype>::»/ﬂw; "
)
> This code will prim "true,true“ for MyType.

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
> Examples: I
APMPP ‘
“5w lulesplce 5m; i
mum <(ype_(riks)
limdude (“5mm 1
(L!!! W i
MC:

m x -

Mimi ¢ r‘ w;
)_ val-swung, m1, hu_1)(x-_x;y-_y;1-_1; )
vnln "m0

> This Code will print "false,false" for MyType, It i5 not trivial nor Stgrrdiird

layout because it has a ﬁeld that is of a reference value,

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
> Examples:
APP-CPP
“in; lump.“ 51.1;
nlMMe <(yve_vaks>
Uindude may“)
mu m!
( r
>- w xx: x‘
A.“ W: El ‘3
L...“ g
w x. y:
)_ WM) = ‘(0. m) 0
“QM um) r ‘
Mt << mum“ << ls_(rlvhl<ly|ype>::vzlue << << ls_swam_lzym|l<ly|ype>::ulue;
)
> This code will print “false,false" for MyType, It is not a standard layout
because MyType has a private member “Base::xx" . It is not trivial because
the constructor from class MyType is defined‘

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
y my

***************Ending Page***************

