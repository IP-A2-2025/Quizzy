***************Beginning Page***************
***************page number:1**************
(1. Groitor rr . Graph >\lgorithms (1. (1roirorrr . Graph >\lgorirhms (1. (1roirorrr . Graph .'\lgorirhms
(.1. (.‘roitorrr - Graph Algorirhrrrs il‘ (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - Graph
Algorithms (1. (1r'oiior'rr - Graph Algorithms ’ (1. (Yroitorrr . Graph Algorithms (1. (".r'oirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgorirhrrrs' (.1. (.1roirorrr — Graph Algorithrrrs :1‘ (.1. (froitorrr
Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms ‘ (1. Groiror rr . Graph >\lgorirhms (1. (1roirorrr
- Graph Algorithms (.1. (.1roitorrr - Graph Algorithrrrs sl‘ (.1. (.1roirorrr - Graph Algorithms (.1.
('Iroiroru - Graph Algorithms (1'. (1roirorrr . Graph .-\lgrn'ithm.s (1. (1roitoru - Graph Algorithms‘ Z‘:
(.1. (.froitortr - Graph Algorithrris “ (.1. (.1roitorrr - Graph \lgorirhrrrs (.1. (.froirorrr — Graph Algorithrrrs
(1. (1roitorrr - Graph Algorithms Z" (I. (1roirorrr - Graph Algorithms (1. (1roitorrr - Graph
Algorithms “ (1. (“roirorrr . Graph \th " | r ' '1. (‘ oi r "iraph \lgorithms (1. (“roirorrr .
Graph Algorithms (1. (.roirorrr - (irgrﬁﬁlllgfylml-ZJ (ggggihrorrr - Graph Algorithms (1. (.roirorrr
. Graph \lgor'ithms (1. ('Ir'oitorrr . Graph Algor irhms l (1. (1|oiror tr . Graph ‘\lgor ithms (1.
(froiroru ~ Graph Algorithms (.Q. (Qr'oiror'rr ~ Graph Algorithms (.1. (.froitoru ~ Graph Algorithms 2*
(1. ('Iroitor rr . Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms (1. Groitor rr . Graph >\lgorithms
(.1. (froitor'rr - Graph Algoritlrrrrs *1 (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - (.lraplr
>\lgorithms (1. (1roirorrr - Graph .'\lgorirhms ’ (1. Groirorrr . Graph >\lgorithm.s (1. ("Iroirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgrirrirhrrrs' (.1. (.Irririrorrr — Graph Algorithrrrs “ (.1. (froitorrr
. Graph Algorithms (1. (1roitorrr - Graph Algorithms Z" (I. (1roitorrr . Graph Algorithms
—

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
a Tree decompositions
o Tree Width
o Small tree decompositions
o Tree decomposition properties
o Rooted tree decomposition
o Applications
—

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
A tree decomposition of a graph G : (V, E) is a pair 7' I (T,{Vt :
t 6 T}), Where T is a tree and {Vt : t € V(T)} is a family of subsets
of vertices of G, Vt Q V for every node t E T such that:
- (Node coverage) V : Ute V(T) Vt;
- (Edge coverage) For every e E E, both endpoints of e are contained
in Vt for some t 6 V(T).
- (Coherence) Let t1, t2, t3 be three nodes in T such that t2 11'es on
the path between t1 and t3 in T. Then, if 'u E V belongs to both
th and Via, v must also belong to Vtz. .
—

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Tree-Width - Deﬁnition
Remarks ‘
The coherence can be rephrased like follows
- (Coherence’) Let t1, t2, t3 G V(T) s. t. t2 belongs to the path from
t1 t0 t3 lIl T. Then V751 O Via g V752.
- (Coherence") For every :1: E V, the subgraph of T induced by {t €
V(T) : :r: G Vt} is (a subtree of T) connected. ‘
The sets Vt are called the of the corresponding tree decomposition.
Deﬁnition ‘
Let T I (T,{Vt : t E T}) be a tree decomposition of G, the of
'T is
~dth T I a V —1 .
wt ( ) tg/(>;)(l tl )
v n___ “Wham”. _ . . .._~__.._i . M." M.._v_-_c_" m . . “mums v n___ 7....-Wmnn. _ J
Graph Algorithms — Lecture 13 January 17, 2025 4 / 21

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
The tree-Width of a graph G, is the minimum Width of a tree
decomposition of G:
tw(G) : min{width(T) : T tree decomposition of G}.
.1’ y {uvtvz} {y-Zﬂt}
t Z
{Stu}
{Lil/J}
,- {ma/u}
u {s. '11,, 1!}
{$317,111}
—

***************Ending Page***************


***************Beginning Page***************
***************page number:6**************
Tree-Width
Remark
tw(G):0ifand only if E(G) :Q. i
Proposition
If G 1's a forest with E(G) 75 Q, then tw(G) : 1.
tw(G) 2 1 by the above remark. If G is a tree, then
o let T be obtained from G by renaming t1, each vertex 'u Q V(G),
0 insert on each edge tutu (u'u G E(G)) a new vertex tzw;
o set Vt“ : {u} for all tu associated to u E V(G), and Vtuv : {u, v}
for all tm, E V(T) associated to u'u G E(G)
o (T,{Vt : t E V(T)}) is a tree decomposition of G with width 1.
Graph Algorithms — Lecture 13 January 17, 2025 6/ 21

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Proof (cont’d). A tree decomposition of a forest with k components can
be obtained by adding k; — 1 arbitrary edges to tree decompositions for
the components (without creating cycles).
U
{H}
a {(1,1)}
{uh/1,}
(l b
{d} {b}
{1w}
{6}
fC/\> K] {wf} {WI}
{f} {.11}
—

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Small tree decompositions
Deﬁnition ‘
A tree decomposition, T : (T, {Vt : t 6 V(T)}), is if there are
no distinct vertices t1, t2 6 V(T) such that V751 Q Vtz. ,
Proposition ‘
Given a tree decomposition of G, a small tree decomposition of G with
the same width can be constructed in polynomial time. ,
Let T I (T,{Vt : t 6 V(T)}) be a tree decomposition of
G with th Q Viz for t1,t2 E V(T) , t1 3i t2. We can suppose that
tltg 6 E(T) (otherwise, we ﬁnd adjacent nodes with this property, by
considering a path from t1 to t2).
Contracting tltg into a new node 1512 with V112 : Viz, gives a smaller
tree decomposition of G (it contains less pairs of vertices (t1, té) with
Vt; Q VtQ- ,
Graph Algorithms — Lecture 13 January 17, 2025 8/21

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Proof (cont'd). Repeat this reduction until a small tree decomposition
is obtained

D
IfT I (T,{Vt : t € V(T)}) is a small tree decomposition of G, then
lTl é IGI'
Proof. By induction on 'n, : [Gt If n : 1, then ‘Tl : 1.
In the inductive step, for n 2 2, consider a leaf t1 of T with neighbor
t2. (T — t1,{l/t : t E V(T — t1)}) is a small tree decomposition of
G’ : G\(V~¢1 \ Vtz). By induction hypothesis |T — t1| g |G’|, therefore

|T|:|T—t1|+1<|G'|+1<|G|-
U
—

***************Ending Page***************


***************Beginning Page***************
***************page number:10**************
Minors
Remarks
o If the graph H is obtained from G by contracting an edge m; into
z, then tw(H) g tw(G): in a tree decomposition of G, insert z in
every bag containing u or v, and then remove u and v from every
bag to obtain a tree decomposition of H.
o If H is a subgraph of G, then til/(H) g tw(G).
Deﬁnition
H 1's a ofa graph G if it can be obtained from G by iteratively
deleting and contracting edges.
Corollary
IfH is a minor ofa graph G, then til/(H) g tw(G).
Using the above remarks.
é
Graph Algorithms — Lecture 13 January 17, 2025 10/ 21

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Let TW;c : {G : tw(G) g k}. I

TW (Tree-Width - decision version)

Instance: G a graph and k E N.

Question: G E TWk?

Ties-Width (decision version) problem 1's NP-complete. I

Proof. Omitted. |
—

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Tree-Width is FPT (ﬁxed-parameter tractable)
Lemma
For every positive integer k, TWk is minor closed.
Theorem
(Bodlaender) For every ﬁxed k, the problem of determining whether or
not G 6 TWk can be solved in C’)(f(k) ' n) time.
Omitted. (f(l<:) is exponential in k.)
Notation: Let T I (T, { Vt : t E V(T)}) be a tree decomposition of G.
Then, if T’ is a subgraph of T, GT1 denotes the subgraph of G induced
by the set of vertices U Vt.
re V(T’)
Graph Algorithms — Lecture 13 January 17, 2025 12/ 21

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
(Node separation property.) Suppose T — t has connected components
T1, T2, . . ., T1,. Then the subgraphs GT1 — Vt, GT2 — Vt, . . . , GT1, — Vt
have 110 vertices in common and there are no edges between them.
N ~
Q ‘I, Ia
‘Qt-gaff‘,
IJQ“ \Q
—

***************Ending Page***************


***************Beginning Page***************
***************page number:14**************
(Edge separation property.) Let X and Y be the two connected com-
ponents of T after the deletion of edge my E E(T). Then, deleting
VI O Vy disconnects G into two subgraphs H X : GX — VI O Vy and
Hy : Gy — VI O Vy. That is HX and Hy share no vertices and there
is no edge in G With one endpoint in HX and the other in Hy. /
\l ~
§ ‘, Ia
‘.gmaﬂr\a
—

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Other properties:
o Let G be a connected graph with tw(G) : k, then {GI : k + 1 or
G has a k-vertex outset.
o If tw(G) : 1, then G is a forest.
o til/(PT >< P5) : min{r, s}.
o til/(Kn) : n — 1.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
A rooted tree decomposition of G is a tree decomposition T I (T, { Vt :
t E V(T)}) of G, Where some vertex 'r of T is declared to be the root.
Notations: let t be a vertex in a rooted tree decomposition T I (T, {Vt :
t E V(T)}).

o Ti is the subtree of T rooted at t.

o G [t] is the subgraph of G induced by the vertices in U Vz (i.

1:6 V(Tt)
e., G[t] : GTt).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
o Recall: a p-vertex coloring of a graph G : (V,E) is a function
c: V —> {1,2, . . . ,p} such that for all u'u G E, C(u) 73 C(11).
o Let H’ and H” be two subgraphs of G, with p-colorings c’ and
c”, respectively. c” is c’-compatib1e if for all v E V(H’) O V(H”),
c’('u) : c”('u).
o Let T I (T,{Vt : t E V(T)}) a rooted tree decompositions of G.
For every t E T and every p-coloring c of Gt, deﬁne
Pravda) Z { 1, if G[t] ‘has an c-compatible p-coloring E
O, otherw1se.
—
P're'uu(c) : 1 if and only if for all children 'u of u, there exists a c-
compatible coloring E of GU with PrevAE) : 1 ,
—

***************Ending Page***************


***************Beginning Page***************
***************page number:18**************
Proof. ":>" If 'y is a c-compatible coloring of GM, since GU is a

subgraph of GM, then the restriction of 'y to G1, gives the required

coloring E.

“<:” Suppose that u has exactly two children 'u and w, and we have

two c-compatible colorings E’ and E”, respectively (the proof is similar

for more children).

Since (T,{Vt : t 6 V(T)}) is a tree decomposition, V(GM) O

V(G[w]) Q Vu, so E’ is E”-compatible.

Combining E’ and E” gives E: V(G[u]) —> {1,2, . . . ,p}. Since (T, {Vt :

t E V(T)}) is a tree decomposition, there are no edges my E E(G) with

ac 6 V(GM) — Vu and y E V(G[w]) — Vu, so Eis a p-coloring of GM.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
—
If G, a graph of order n, has a small tree decomposition (T,{Vt :
t E V(T)}) of width w, then we can decide if G is p-colorable in
0(pw+1 - n0(1)) time complexity. ,
Proof. Transform (T, { Vt : t G V(T)}) in a rooted tree decomposition
(r is the root). For every 'v 6 V(T) and every p-coloring c of GU, we
compute Prevv(c): start at the leaves of T, and use the above proposi-
tion for the other nodes, in the right order.

G : Gm is p-colorable if and only if Pre'ur(c) : 1 for some c. Test-

ing whether c is a G1, coloring and computing Pre'uﬂc) can be done in

polynomial time @(n<9(1)), so the total time complexity is mainly deter-

mined by the number of candidates for c, which is p'vvl.

Complexity: |V(T)\ -p“’+1 -n0(1) : @(pw+1-no(1)).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Other applications - Similar approaches (more advanced dynamic
programming)
Theorem ‘
If G, a graph of order n, has a small tree decomposition (T, {Vt : t E
V(T)}) of Width w, the size of a minimum vertex cover of G ca be
computed in (9(21”1 - n0(1)) time complexity. ‘
Theorem ‘
If G, a vertex-weighted graph of order n, has a small tree decomposition
(T,{Vt : t € V(T)}) of Width w, a maximum stable set of G ca be
computed in O(4“’+1 - w - n) time complexity. ‘
Graph Algorithms — Lecture 13 January 17, 2025 20/ 21

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
G Groitortr A Graph Algorithms A G Groitortr — Graph Algorithms A G Groitortr — Graph Algorithms
A G Groitoru - Graph Algorithms A G Groitoru - Graph Algorithms A G Groitoru - Graph
Algorithms A G Groitortr — Graph Algorithms A G Groitorrr - Graph Algorithms A G Groitortr —
Graph Algorithms A G Groitoru A Graph Algorithms A G Groitorrr - Graph Algorithms A G Groitoru
- Graph Algorithms A G Croitorrr - Graph Algorithms A G Croitortr - Graph Algorithms A G
Groitoru A Graph Algorithms A G Groitorrr A Graph Algorithms A G Groitoru A Graph Algorithms A
G Groitorri A Graph Algorithms A G Groitortr - Graph Algorithms A G Groitorrr - Graph Algorithms
A G Groitortr A Graph Algorithms A G Croitortr A Graph Algorithms A G Groitoru A Graph
Algorithms A G Croitoru - Graph Algorithms A G Groitortr - Graph Algorithms A G Croitoru -
Graph Algorithms A G Groitortr — Th "tho ' Ara-(drill - Graph Algorithms A G Groitortr
- Graph Algorithms A G Croitorrr - ‘a game ibortr - Graph Algorithms A G
Groitortr — Graph Algorithms A G Croitortr - Graph Algorithms A G Groitortr — Graph Algorithms A
G Groitorrr - Graph Algorithms A G Groitorrr A Graph Algorithms A G Groitorrr - Graph Algorithms
A G Croitortr — Graph Algorithms A G Groitortr - Graph Algorithms A G Croitortr — Graph
Algorithms A G Croitoru A Graph Algorithms A G Groitorrr A Graph Algorithms A G. Croitoru A
Graph Algorithms G Croitortr - Graph Algorithms A G Croitortr - Graph Algorithms G Croitortr
A Graph Algorithms A G Groitoru A Graph Algorithms A G Groitoru A Graph Algorithms A G
(jroitoru - Graph Algorithms A C. Groitortr - Graph Algorithms A G Croitoru - Graph Algorithms A
G Groitortr A Graph Algorithms A G. Groitortr — Graph Algorithms A G Groitortr - Graph Algorithms
A G Groitorrr - Graph Algorithms A G Groitortr - Graph Algorithms A G Groitorrr - Graph
Algorithms A G Groitortr — Graph Algorithms A G Groitorrr - Graph Algorithms A G Groitortr —
Graph Algorithms A G Groitorrr A Graph Algorithms A G Groitorrr - Graph Algorithms A G (Iroitorrr
- Graph Algorithms A G Croitortr — Graph Algorithms A G Croitortr - Graph Algorithms A
—

***************Ending Page***************

