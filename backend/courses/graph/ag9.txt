***************Beginning Page***************
***************page number:1**************
(1. Groitor rr . Graph >\lgorithms (1. (1roirorrr . Graph >\lgorirhms (1. (1roirorrr . Graph .'\lgorirhms
(.1. (.‘roitorrr - Graph Algorirhrrrs il‘ (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - Graph
Algorithms (1. (1r'oiior'rr - Graph Algorithms ’ (1. (Yroitorrr . Graph Algorithms (1. (".r'oirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgorirhrrrs' (.1. (.1roirorrr — Graph Algorithrrrs :1‘ (.1. (froitorrr
Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms ‘ (1. Groiror rr . Graph >\lgorirhms (1. (1roirorrr
- Graph Algorithms (.1. (.1roitorrr - Graph Algorithrrrs sl‘ (.1. (.1roirorrr - Graph Algorithms (.1.
('Iroiroru - Graph Algorithms (1'. (1roirorrr . Graph .-\lgrn'ithm.s (1. (1roitoru - Graph Algorithms‘ Z‘:
(.1. (.froitortr - Graph Algorithrris “ (.1. (.1roitorrr - Graph \lgorirhrrrs (.1. (.froirorrr — Graph Algorithrrrs
(1. (1roitorrr - Graph Algorithms Z" (I. (1roirorrr - Graph Algorithms (1. (1roitorrr - Graph
Algorithms “ (1. (“roirorrr . Graph \ " ' ‘ '1 (‘ air ‘ . "iraph \lgorithms (1. (“roirorrr .
Graph Algorithms (1. (.roirorrr - (1%?réggkﬁrgsq,(fzgr%%tirrr - Graph Algorithms (1. (.roirorrr
. Graph \lgor'ithms (1. ('Ir'oitorrr . Graph Algor irhms l (1. (1|oiror tr . Graph ‘\lgor ithms (1.
(froiroru ~ Graph Algorithms (.Q. (Qr'oiror'rr ~ Graph Algorithms (.1. (.froitoru ~ Graph Algorithms 2*
(1. ('Iroitor rr . Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms (1. Groitor rr . Graph >\lgorithms
(.1. (froitor'rr - Graph Algoritlrrrrs *1 (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - (.lraplr
>\lgorithms (1. (1roirorrr - Graph .'\lgorirhms ’ (1. Groirorrr . Graph >\lgorithm.s (1. ("Iroirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgrirrirhrrrs' (.1. (.Irririrorrr — Graph Algorithrrrs “ (.1. (froitorrr
. Graph Algorithms (1. (1roitorrr - Graph Algorithms Z" (I. (1roitorrr . Graph Algorithms
—

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
a Network flows
o Preﬁows
0 General scheme of a preﬂow algorithm
0 Ahuja 8c Orlin algorithm
o Combinatorial applications
0 Bipartite matchings
O Digraphic degree sequences
0 Edge Connectivity
0 Vertex Connectivity
a Exercises for the 10th seminar (december 9 - 13 week)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
A preﬂow in R : (G, s, t, c) is a function a: : E(G) —> 1R such that
(i) 0 < $11" g CZ'J', Vij E E;
(ii) V1755, 61': Z$ji— Z$ij>u
ﬂeE UGE
ei (for 'L' E V \ {s,t}) is called the excess in node i. Ifz' E V \ {5,13}
and ei > O, then z' is an active node. If 'Lj 6 E, mij will be referred as
the flow on the arc z'j.
If in R there are no active nodes, then the preﬂow a: is a flow with
v(:z;) : et.
Idea of preﬂow algorithms: an initial preﬂow in R is transformed by
changing the ﬂow on the arcs in a ﬂow with the property that there are
no augmenting paths in R w.r.t. it.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
G is represented using adjacency lists. We will suppose that if z'j E E,
then ji E E too (otherwise, we add the arc ji with capacity O). Hence,
G is a symmetric digraph.
If a: is a preﬂow in R and ‘Lj G E, then the residual capacity of 'ij is
my‘ I Cij — 1%‘ + 1%
(representing the additional ﬂow that can be sent from node i to node
j using the arcs ij and ji).
(‘L ,mlj 0”,er + foru'
iQJ send (1: fU'I'U.‘ + backw [0]‘
on m'c ij
g 0],,1'” € g 9,an i backu‘ ?
at By e, i a B] + a
—

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
In the following, sending ﬂow from i to j means increasing the flow on
the arc 'L'j or decreasing the ﬂow on the arc ji.
An A-path in R W.r.t. preﬂow 11:, is any path in G having all arcs With
strictly positive residual capacity.
A distance function in R W.r.t. preflovv :1; is a function d : V —> Z+ s.t.
(D1) d6) I 0,
(D2) Wj E E,n-j > 0 :> d(z') g d(j) + 1.

o If P is an A-path W.r.t. preﬂow :r: in R from z' to t, then d(z') g
length(P) (the arcs of P have positive residual capacity and we
repeatedly use (D2)). It follows that d(1,) g 'ri, Where Ti denotes
the minimum length of an A-path from "L to t.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Preﬂows
Remarks

0 As usual, we denote by 14(1) the adjacency list of the node i. I

do‘)
11(5) do) +1 do‘) *1 0
Deﬁnition
Let a: be a preﬂow in R and d a distance function W.r.t. ac. An arc
ij 6 E 1's called admissible if .
Graph Algorithms — Lecture 9 December 6, 2024 6/47

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
If R is a ﬂow network, we consider the following initialization procedure,
which builds in 0(m) a preﬂow .1: and a distance function d w.r.t. a3.
procedure initializationo;
for (ij E E) do
if (i : s) then
$51" <- CSJ'
else
$17‘ (— O;
d[s] P n; d[t] <— 0;
for (i 6 V — \{s, t}) do
d[i] <— 1;
—

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Note that after the execution of this procedure, we have raj : 0, Vsj E
A(s). Hence the condition (D2) is not affected by taking d(s) : n.
For all arcs z'j, (D2) is fulﬁlled:
(1(5) I n Cm) :1 d(t) I 0
T'sj = j Tjt > 0
1 I 110') I d(i) +
s t
J'
Tjs > 0
l=d(1><"+l=d(5)+
—

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
The choice of d(s) : n means: there are no A-paths from s to t w.r.t.
:1; (otherwise, if P is such a path, its length must be at least d(s) : n,
which is impossible).
If this will be an invariant of the preﬁows algorithms; hence, when a:
will become a ﬂow, it will be a maximum value ﬂow.
Let us consider the following two procedures:

procedure push“); // 2' is a node different from s,t

choose an admissible arc ij 6 14(2);

"send" 6 : min{e,-, 731-} (flow units) from z' to j;
If 6 : 7",) then we have a saturated push, otherwise we have an unsatu-
rated push.

pIOCGdure Telabel(i); // 2' is a node different from s, t

d[i] <— min{d[j] +1 : ij E AU) and 'ij > 0}; j

—

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
initialization;
while (El active nodes in R) do
choose an active node i;
if (El admissible arcs in A(1L)) then
push(1l);
else
Telabel(i);
"d is distance function W.r.t. preflow :12“ is an invariant of the above
algorithm. At each call of relabel(z'), d(i) increases.
—

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
Proof. We already proved that the procedure initialization builds a
preﬁow a: and a distance function d w.r.t. 2;. We show that if the pair
(d, ac) satisﬁes (D1) and (D2) before an while iteration, then after this
iteration the two conditions are fulﬁlled too.

We have two cases, depending on which procedure push or relabel is
called in the current while iteration:

push(z') is called: the only pair that can violate (D2) is d(z') and d(j).
Since ij is admissible, at the push(i) call we have d(i) I d(j) + 1. After
the call of push(i), the arc ji could have now ‘rji > 0 (without being
before the call), but the condition d(j) é d(z') + 1 is obviously satisﬁed.
relabelﬁ) is called: the update of (1(1) is such that (D2) is fulﬁlled for
each arc ij with nj > 0. Since relabelh') is called when d(z') < d(j) + 1,
Wj with nj > 0, it follows that, after the call, d(i) increases (with at
least 1). U ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
In order to show that the algorithm terminates, it is necessary to show

that (during the execution) if a node z' is active then in its adjacency

list, AU), there is at least one arc z'j cu nj > 0. This follows from the

next lemma.

If in is an x-active node in R, then there is an ins A-path w.r.t. 2:. /

Proof. If :r: is a preﬂow in R, then a: can be decomposed :r: I $1 + $2 +

+ mp, where each ml“ has the property that the set Ak : {ij : ij E

E, 1;}; 72 0} is

(a) the set of the arcs of a path from s to t, or

(b) the set of arcs of a path from s to an active node, or

(c) the set of arcs of a cycle.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Moreover, in the cases (a) and (c), ask is a ﬁow. (The proof is algorithmic:
we construct ﬁrstly the sets of type (a), than those of type (c) and (b);
at each stage, we search the converse of a path of the type (a) or (c) (or
(b)); the preﬂow obtained is subtracted from the current one; since the
excesses of the nodes are non-negative, the construction can be realized,
whenever the current preﬁow is non null; the construction is ﬁnite, since
the number of arcs on which the current ﬂow is O, increases at each stage
of it.)

Since 2'0 is an active node in R w.r.t. :n, it follows that the case (b) will
occur for the node i0 (the cases (a) and (c) does not affect the excess
in the node to). The converse arcs of this path have positive residual
capacity (see the ﬁgure bellow), therefore they form the required A-path.
l1 J

—

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
r>0 r>0 'r'>0 r>0

1n>0 m>0 az>0 m>0
Vz' E V, d(1;)< 2n.
Proof. Indeed, if 1L has not been relabelled, then 01(1) I 1 < 2n. Other-
wise, before the call of Telabelﬁ), 2' is an active node, hence by Lemma
2, there is an is A-path P with length(P) g n — 1. By (D2), it follows
that, after the relabel, d(z') g d(s) + n — 1 : 2n — 1 (d(s) : n is never
changing). U

—

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Preﬂows - General scheme of a preﬂow algorithm
Corollary 2

Indeed, there are n — 2 nodes which can be relabelled. Each of
them can be relabelled at most of 2n — 1 times (by Lemma 1, the above
Corollary, and the initial distance d). U
Corollary 3

Indeed, when an arc 'Lj becomes saturated, we have (1(1) I d(j) +
1. After that, the algorithm cannot send ﬂow on this arc until it sends
flow on the arc ji, when we have d’(j) = d’('L') +1 Z d(z')+ 1 : d(j) +2.

Graph Algorithms — Lecture 9 December 6, 2024 15/47

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Preﬂows - General scheme of a preﬂow algorithm
Proof cont’d. Hence this flow change on the arc z'j does not occur until
d(j) increases With 2. It follows that an arc can not become saturated
more than n times and there are n0 more than nm saturated pushes
(since the total number of arcs is m). U
Lemma 3
(Goldberg and Tarjan, 1986).
Proof. Omitted.
Lemma 4

Graph Algorithms — Lecture 9 December 6, 2024 16/47

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Proof. By Lemmas 1 and 3 and by Corollary 3 of Lemma 2, the algorithm
terminates in at most (9(n2m) while iterations. Since d(s) : n is
never modiﬁed, it follows that there is no augmenting path w.r.t. the
ﬂow a: obtained, hence :r: is of maximum value: if P is an augmenting
path (in the support graph of G), then, by replacing along P each
backward arc with its symmetric arc, we get an A-path from s to t,
hencen:d(s)§d(t)+n—1:n—1. U ,
Instead of proving Lemma 3, we will present the Ahuja 8z Orlin algorithm
(1988) that uses a scaling method to reduce the number of unsaturated
pushes from (9(n2m) (Goldberg 8c Tarjan algorithm) to 0(n210g U).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Suppose that Cij E N and U : 1515ch + Cz'j). Let K : [log2 U].

Algorithm’s idea: We have K + 1 stages. For each stage p, with p taking

successively the values K, K — 1, . . . , 1,0, the following two conditions

are fulﬁlled:

(a) at the beginning of stage p, e,- g 2p, Vi E V \ {3, t}.

(b) during the stage p, the procedures push-relabel are used in order
to eliminate the active nodes, z', with e, E {21F1 + 1, . . . 2P}.

By the deﬁnition of K, in the ﬁrst stage (p : K), property (a) holds

(after the initialisation of the preﬁow we have e, : c5, or e, : 0, for each

z' 75 s, t, hence e,- g U), and, if property (b) will be maintained during

the algorithm (if the integrality of excesses is also maintained during the

algorithm), it follows that, after stage K + 1, the excess of each node

2' € V \ {5, t} is O, therefore we have a ﬂow of maximum value.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
In order to maintain the condition (b) during the algorithm, the general
scheme of a preflow algorithm is adapted as follows:

o each stage p starts by constructing the list L(p) of all nodes
z'l,z‘2,...,il(P) with excesses e, > 2P4, sorted non-decreasing by
d (this can be done with a hash-sorting in O(n) time, since
01(1) E {1,2,...,2n — 1}).

o the active node selected for push-relabel during the stage p will be
the ﬁrst node in L(p). It follows that, if a push is done 0n the
admissible arc 'L'j, then e,- > 2l"_1 and ej g 21"_1 (because d(j) :
d(z') — 1 and 2' is the ﬁrst node in L(p)). If 6, the ﬂow sent from 2'
toj by push(z'), is limited to 6 : min(e,, 737,21’ — ej), then (since
2P — 6]‘ Z 2P4) it follows that an unsaturated push sends at least

—

***************Ending Page***************


***************Beginning Page***************
***************page number:20**************
After the execution of pushh') the excess from nodej (the only one
for which the excess can increase) will be 8]‘ +min (ei, 715,217 — 8]‘) g
ej + 2p — ej g 2p, therefore (b) holds.
o the stage p is over when the list L(p) becomes empty.
In order to ﬁnd efI'lciently an admissible arc for doing the push, or to
inspect all the arcs leaving a node 2' for doing relabel, we will organize
the adjacency lists A(z') as follows:
o each list’s node contains: the node j, mzj, 733-, a pointer to the arc jz'
(from the adjacency list A(j)), and a pointer to the next node from
the list A(i).
o the list has associated an iterator to enable its traversal.
All these lists are constructed in 0(m) time, before the call of the pro-
ceduf..e..ti..1.1,ill?1..i??.1f°i9“:“New... _. J
—

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
initialization; K <— [log2 U]; A <— 2K+1;
for (p : m) do
construct L(p); A <- A/2;
While (L(p) 75 Q) do
let 2' the ﬁrst node in L(p);
search in 14(2) for an admissible arc;
if (ij is the admissible arc found) then
6 <- min(eZ-, rij,A — ej);
ei<— ei—5; ej <—ej+5;
"send" 6 unit flows from z' to j;
if (el- Q A/Z) then
delete i from L(p);
if (ej > A/2) then
addj as the ﬁrst node in L(p);
else
compute d[2] : min{d[j] + 1 : ij E A(z) and rij > 0}
reposition i in L(p);
set the current pointer at the beginning of AU);

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
The complexity time of the algorithm is dominated by unsaturated
pushes (all the remaining parts need 0(nm) time).
The number of unsaturated pushes is at most 8n2 in each stage of the
scaling, hence the total number is @(n2 log U).
Proof. Let d()
_ el' - z
F(;v) — , Z i2}, -
16 V,17£s,t
. . 2P - 2
At the beg1n1ng of stage p, F(p) < Z M : 212,2.
iEV 2p
—

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
If, in the stage p, is executed relabelﬁ), then there are no admissible
arcs z'j, and d(z') is increased with h 2 1 units. F(p) will increase by
at most h, Since, Vi, d(i) < 2n it follows that F(p) will increase (until
the end of the p stage) at most up to 4n2.

If, in the stage p, is executed push('1l), then this sends 6 2 2P_1 on the
admissible arc 'Lj With nj > 0 and d(z') : d(j) + 1. Hence, after the

. , 6-d(i) 6-d(j)
push, F(p) Will have the value F (p) : F(p) — T + T :
6 2P—1

F(P)—2j € F(P)—2T:F(P)—1/2-

This decrease cannot occur more than 8n2 times (because F(p) can
increase at most up to 4n2 and F(p) is non-negative). Clearly, the
number of unsaturated pushes is dominated by this number of decreases
of F(p).

—

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Summarizing, we have: I

(Ahuja-Orlin, 1988) The Preﬁow algorithm with excesses scaling has

time complexity (9(nm + n2 10g U).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
A. Finding a maximum cardinality matching and a maximum stable set
in a bipartite graph.
Let G : (V1, V2; E) be bipartite graph with n vertices and m edges.
Consider the network R : (G1, s, t, c), Where
0 V(G1) I {5, t} U V1 U V2;
E1 I {5'01 I 'Ul E V1},E2 I {'Ugt I 'Ug G V2},
E3 : {111112 I 'Ul G V1,’Ug Q V2,’!11'Ug E E(G)},
o c : E(G1) —> N deﬁned by
c(e)— 1, ife €E1UE2
— oo, if e G E3
J
—

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
+00
/A-r\
l \1
v1 v2

If a: : (2:17) is an integral flow in R, then the set {ij : i 6 V1,j E

V2 and xij : 1} corresponds to a matching M x in the bipartite graph

G, with |Mm| : 'u(.'1:)

Conversely, any matching M G MG gives rise to a set of non-adjacent

arcs in G1; if on each such arc 'L'j (2' E V1, j 6 V2) we consider wig/I : 1

and my : 2:]? : 1, and we put ch(e) : 0 on any other arc, then the

integral flow xM satisﬁes v(a;M) : \M|.

J

—

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
Hence, if we solve the maximum ﬂow problem in R (starting with the null
ﬂow), then we obtain in O(nm + n2 log n) time a maximum cardinality
matching in G. (the constant replacing +oo must be an integer greater
than the cardinality of any cut, e. g. n2 + 1 - see below.)
Let (S, T) be the minimum capacity cut (obtained in (9(m) time
from the maximum ﬂow found). By the Max-ﬂow Min-cut Theorem,
C(S, T) : I/(G).
Since 1/(G) < oo, taking S, : S O V, and T, : T O V, (1L : m), we
have (ﬁll-(52‘ : i/(G) and X : SlLJ T2 is a stable set in G (in order to
have c(S, T) < oo). Moreover, IX) : [V1\ T1I+|V2\Sgl : n — l/(G).
It follows that X is a maximum cardinality stable set, since n — 1/(G) :
a(G)) (by Konig theorem). ‘
—

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
B. Recognizing digraphic degree sequences
Let us consider the following problem:
Given (111312171 and (d;)¢:171, is there a digraph G : ({1, . . . , n}, E)
such that (15(1) I dj and dgu) I 01;, W I 1,7?
Obvious necessary conditions in order to have an "yes instanceII are:
d?€N,0§dZ-+§n—1and d;eN,0<d;<n_1,v¢I1,7;
Tl Tl
Z d?’ : Z d; : m (Where m : IE’).
izl 1:1
In this hypothesis, consider the bipartite flow network R : (G1, s, t, c).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
G1 is obtained from a complete bipartite graph Kn,” With bipar-
tition ({1,2,...,n},{1’,2’,...,n’}), by removing the set 0f edges
{11’, 22’, . . . , nn’} and by orienting each edge z'j’ (W 753' 6 {1, 2, . . . , n})
from z' to j’, and by adding two new vertices s, t, and all arcs st,
i€{1,2,...,n} andj’t,j E{1,2,...,n}.
The capacity function: C(sz') : dil, c(j’t) : dj’, C(z'j’) : 1, Vi,j : Lin
d” ’ \ _
J
—

***************Ending Page***************


***************Beginning Page***************
***************page number:30**************
If in R there is an integral flow, ac, of maximum value m, then from each

vertex 1L will leave exactly d; arcs, ij’, on which ch-j/ : 1, and in each

vertex j’ will enter exactly d; arcs, ij’, on which :cij/ : 1.

The desired digraph, G, is constructed by taking V(G) : {1, 2, . . . , n}

and putting ij E E(G) if and only if xij/ : 1.

Conversely, if G exists, then by inversing the above construction we

obtain an integral ﬂow in R of value m (hence, of maximum value).

It follows that, the recognition of digraph sequences (and digraph real-

ization, for positive answer) can be done in @(nm + n2 10g n) : (9(n3). ‘
—

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
C. Finding the edge-connectivity number of a graph
Let G : (V, E) be a graph. For s,t 6 V, s 5i t, we denote
o pe($, t) : maximum number of edge-disjoint paths from s to t in
G,
o ce(s, t) : minimum cardinality of a set of edges such that there is
no path from s to t in the graph obtained by removing it from G.
106(5, t) : 06(5, t).
Proof. Let G1 be the digraph obtained from G by replacing each edge
by a pair of symmetric arcs. Let c : E(G1) —> N a capacity function
deﬁned by c(e) : 1, Ve 6 E(G1).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Proof cont’d. Let 2:0 be an integral flow of maximum value in R =
(G1, s, t, c). If there exists a cycle C' in G1 with x3 : 1 on all arcs of
C, then we can put to 0 the ﬁow on the arcs of C' without changing the
value of the ﬂow x0. Hence, we can suppose that the ﬂow m0 is acyclic
and then m0 can be expressed as a sum of 'u(:z:°) integral flows :ck with
1/(mk) : 1.

Each flow ask corresponds to a path from s to t in G1 (by taking the
arcs on which the flow is not 0), wich is a path from s to t also in the
graph G.

It follows that 'u(:z:0) : pe(s, t), since any set of edge-disjoint paths from
s to t in G generates a O — l-ﬂow in R of value equal to the number of
these paths. ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
Proof cont’d. Let (S, T) be a minimum capacity cut in R; we have
c(S, T) : 11(xo), by the Max-ﬂow Min-cut theorem. On the other hand,
C(S, T) is the number of arcs with an extremity in S and the other in
T (since the arcs capacities are all 1). This set of arcs generates in G a
set of edges of the same cardinality and such that there is no path from
s to t in the graph obtained by removing it from G.

Hence we obtained a cut of capacity c(S, T) : v(a:0) : pe(s, t) edges in
G which deconnects s from t by their removing from G. It follows that
ce(s,t) g pe(s,t). Since the inequality ce(s,t) 2 pe(s,t) is obvious,
the theorem is proved. D

If G is a connected graph, MG), the maximum value of p E N for which
G is p-edge-connected, is

s,t€§tbn>,s¢t 64$’ t) (*)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
It follows that, to compute MG), it is necessary to solve the n(n — l)/2

maximum flow problems described in the above proof. This number

can be reduced if we observe that, for a ﬁxed pair (s, t), if (S, T) is a

minimum capacity cut, then

V'u € S and V'w E T ce(v,'w) g C(S, T) (**)

In particular, if (s, t) is the pair for which the minimum in (*) is attained,

we have equality in (**)

If we ﬁx a vertex so E V and solve the n — 1 maximum ﬂow problems by

taking t0 E V \ {so} we will obtain a pair (so, to) with C(So, to) : MG)

(to will be not in the same class with so in the bi-partition (S, T)).

Conclusion: MG) can be found in @(n - (nm + nzc)) : (9(n2m) time.)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
D. Finding the vertex-connectivity number of a graph.
Let G : (V, E) be a graph. For 5,156 V, s 73 t, if we denote
o p(s, t) : maximum number of internal vertex disjoint st-paths in
G,
o c(s, t) : minimum cardinality of a st-separating set of vertices in
G,
then, by Menger Theorem, we have
p(s, t) : c(s, t)(* * *)
Moreover, the vertex-connectivity number, k(G), of the graph G (the
maximum value of p E N for which G este p-connected) is
n — 1, if G : Kn
MG) :{ min C(S, t), if G ¢ Kn (* * **)
s,tEV(G),s;ét,st$E(G) J
—

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
We show that the equality (* * *) follows from the Max-ﬂow Min-cut
theorem, on an appropriate flow network.
Let G1 : (V(G1), E( G1)) be the digraph constructed from G as follows:
o V'u E V, we put av, b1, E V(G1) and 0,va G E(G1);
o Vv'w € E, we put bvaw, bwav E E(G1).
b1 a;
1 t ‘4—‘ I”
5 2 rm Ava!‘
b2
S
—

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Also, deﬁne c: E(G1) —> N by
C(e) I { 1, if e z avbv
oo, otherwise
Let us consider the ﬂow network R : (G1, b5, at, c).
Let m0 be an integral ﬂow in R of maximum value. In the nodes b,,('u E
V) enters exactly one arc of capacity 1 and from the nodes av(v E V)
leaves exactly one arc of capacity 1.
It follows (by the ﬂow equilibrium constraints) that $3- 6 {0,1} , Vij E
E(G1). Therefore m0 can be decomposed in 11(120) ﬂows :zzk, each of value
1, with the property that the arcs on which wk is non null correspond to
'u(m0) internal disjoint paths in G.
On the other hand, from any set of p internal disjoint st-paths in G,
we can construct p internal disjoint b3 at-paths in G1, on which we can
transport one unit of ﬂow. It follows that 11(wo) : p(s, t). ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Let (S, T) be a minimum capacity cut in R such that 1/(a30) : c(S, T).

Since 'z/(mo) < oo, it follows that Vi G S, Vj G T with 'ij G E(G1); we

have C(z'j) < oo, therefore C(ij) : 1, that is Elu E V such that 2' : an

and j : bU.

Hence, the cut (S, T) corresponds to a set of vertices A0 Q V such that

C(S, T) : |A0| and A0 is a st-separating set.

On the other hand, VA st-separating set, |A| Z p(s, t) : 'u(a:0). There-

fore

c(s, t) : 1A0] : c(S, T) : 'u(a:0) : p(s, t).

The above proof, which, on one hand, completes the proof of the

Menger’s theorem from lecture 5, shows, on the other hand, that, in

order to ﬁnd MG) will be sufficiently to ﬁnd the minimum in (* * **) by

solving |E(@)| maximum ﬂow problems, Where E is the complement of

G.
—

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
This gives an algorithm with time complexity
— 1
O ((M2) — m) (nm + n2 log 11)) .
A simple observation gives us a more efficient algorithm. Obviously,
1 1 2m
sz<'d :*(-'d ><i d :i.
( )\ {£151 0(11) n n 1752151 G('v) \ n g; 0(11) n
If A0 is a cut-set in G with |A0| : MG), then G \ A0 is not connected
and there exists a partition of V \ A0 (V', V”) such that there is no
edge in cross between V’ and V” and V'u’ 6 V’, V11” E V” we have
1001311”) I MG)-
—

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
It follows that solving a maximum ﬂow problem with so G V’ and to E
V” we obtain that p(so, to) : maximum ﬂow value : MG)
2

We can ﬁnd such a pair like follows: let l : [Tm] + 1, choose l vertices

arbitrary from V(G), and for each such vertex, 'u, solve all maximum

ﬂow problems p('u, w), with 'u'w ¢ E. The number of such problems is

@(nl) = c9 (n ((2% + 1)) = 0(m).

Hence the time complexity of ﬁnding MG) is (9(m(nm + n2 log n)).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
Exercise 1. Show that, by using a maximum ﬂow algorithm (in a certain
network), you can ﬁnd, in a O - 1 matrix, a maximum cardinality set of
elements equals with 0, in which any two elements are not on the same
row o_r column. g _ g _

Exercise 2. Let S and T be two disjoint, ﬁnite, and non-empty sets. We
have a function a : S LJ T e N. The requirement is to decide whether
exists a bipartite graph G : (S, T; E) such that dg(’U) : a('u), for all
'u € S U T; if the answer is affirmative you have to return the edges of
G (S and T are the classes of the bipartition in G). Show that this
problem can be polynomially solved as a maximum value flow problem
in a certain network.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Exercise 3. Every student from a cardinal n > O set S choose a subset of

4 optional courses from a cardinal k; > 4 set C. Conceive an algorithm

(with polynomial time complexity) which has determine (if exists) an

allocation of the students to optional courses from C’ such that every

student will be allocated to exactly 3 courses (from those 4 already

chosen) and each course gathers at most [a - n/kzl students (a 2 3).

Exercise 4.

(a) True or false? In a network R : (G, s, t, c) having distinct capaci-
ties there is an unique maximum value flow. Why?

(b) Devise and prove the corectness of a polynomial time complexity
algorithm which has to decide that if in a given network there is an
unique maximum flow.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
Exercise 5. An IT company has n employees P1, P2, . . . , Pn which has
to accomplish m projects L1, L2, . . . , Lm. For any employee P1- we have
a list L1- of projects onwhich he can work, and sZ- the number of projects
from L1- which can be accomplished by him in a week (si g |L¢|). Any
project will be assigned to one employee.

How can you ﬁnd the minimum number of weeks required to ﬁnish all
the projects by using flows in networks? ,
Exercise 6. The emergency evacuation plan of a buiding is described as
a n >< n grid; the cells borders of this grid are the escape routes to the
outside of the building (grid). An instance of the evacuation problem
contains the dimension n of the grid an m starting points (corners of
the cells).

—

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Exercise 6 (cont’d). The instance has a positive answer if there are m

disjoint paths towards grid frontier starting in the above m points. If

such paths do not exist, then the instance has a negative answer.

Find a representation of this evacuation problem as a flow problem in a

ﬂow transportation network. Devise an eflicient algorithm to recognize

a positive instance of the evacuation problem (what is its time complex-

ity?).

Exercise 7. Let G : (V, E) be a graph having n vertices {111,112, . . . , 'un}

and c : E —> R+ a capacity function on the edges 0f G. A cut in G is

a bipartition (S, T) of V. The capacity of a cut (S, T) is c(S, T) :

Z c(e).

eEE,\ef‘|S|:1

—

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
Exercise 7 (cont’d). A minimum cut in G is a cut (SO, T0) such that
C(So, T0) : min _ C(S, T)
(S,T) cut 1n G

(a) Show that we can determine a minimum cut in polynomial time
complexity by solving a polynomial number of maximum flovv prob-
lems in certain networks.

(b) For G : Cn (the induced cycle of order n 2 3) having all capacities

— 1
1, prove that there are n(n2) minimum cuts.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Exercise 8. Let G : (V; E) be a digraph and 'w : V —> 1R such that
w(V) O R+,w(l/) Q Rx 73 6. A subset A Q V is called a isolated
subset of G if there is no arc that leaves A. The weight of A Q V
is w(A) : Z w(v). Describe a polynomial time complexity using a
maximum vialfile ﬂow algorithm in a certain network that has to ﬁnd a
maximum weight isolated subset of G. J
Exercise 9. At the CS department there are p students (S :
{$1, $2, . . . , SP}) who want to graduate and k professors (73 I
{P1, P2, . . . , Pk}) For the ﬁnal graduate examination (also called exit
examination) teams of r professors will judge the students ﬁnal projects.
For a given project each professor either has the competences to judge it
or not, i. e., we know the set, 'PZ- Q P (731- 75 Q), of professors specialized
on the project of student Si. Each professor Pj can participate to at
most nj teams.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
Exercise 9 (cont’d) Each student must present this project to a team of

T(< k) professors, a(< r) of them being specialized on this project and

the remaining ('r — a) are not.

(a) Devise a network ﬂow model to organize the judging teams (which
professor will attend which project presentation).

(b) Give a characterization of the existence of a solution to this problem
in terms of maximum flow in the above network.

(c) What is the time complexity for deciding if a solution exists? ,

—

***************Ending Page***************

