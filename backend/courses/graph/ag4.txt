***************Beginning Page***************
***************page number:1**************
(1. Groitor rr . Graph >\lgorithms (1. (1roirorrr . Graph >\lgorirhms (1. (1roirorrr . Graph .'\lgorirhms
(.1. (.‘roitorrr - Graph Algorirhrrrs il‘ (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - Graph
Algorithms (1. (1r'oiior'rr - Graph Algorithms ’ (1. (Yroitorrr . Graph Algorithms (1. (".r'oirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgorirhrrrs' (.1. (.1roirorrr — Graph Algorithrrrs :1‘ (.1. (froitorrr
Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms ‘ (1. Groiror rr . Graph >\lgorirhms (1. (1roirorrr
- Graph Algorithms (.1. (.1roitorrr - Graph Algorithrrrs sl‘ (.1. (.1roirorrr - Graph Algorithms (.1.
('Iroiroru - Graph Algorithms (1'. (1roirorrr . Graph .-\lgrn'ithm.s (1. (1roitoru - Graph Algorithms‘ Z‘:
(.1. (.froitortr - Graph Algorithrris “ (.1. (.1roitorrr - Graph \lgorirhrrrs (.1. (.froirorrr — Graph Algorithrrrs
(1. (1roitorrr - Graph Algorithms Z" (I. (1roirorrr - Graph Algorithms (1. (1roitorrr - Graph
Algorithms “ (1. (“roirorrr . Graph \l " ' '1. ‘ oi r "iraph \lgorithms (1. (“roirorrr .
Graph Algorithms (1. (.roirorrr - (irgllﬂgfgﬁllrrgg, (2953mm - Graph Algorithms (1. (.roirorrr
. Graph \lgor'ithms (1. ('Ir'oitorrr . Graph Algor irhms l (1. (1|oiror tr . Graph ‘\lgor ithms (1.
(froiroru ~ Graph Algorithms (.Q. (Qr'oiror'rr ~ Graph Algorithms (.1. (.froitoru ~ Graph Algorithms 2*
(1. ('Iroitor rr . Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms (1. Groitor rr . Graph >\lgorithms
(.1. (froitor'rr - Graph Algoritlrrrrs *1 (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - (.lraplr
>\lgorithms (1. (1roirorrr - Graph .'\lgorirhms ’ (1. Groirorrr . Graph >\lgorithm.s (1. ("Iroirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgrirrirhrrrs' (.1. (.Irririrorrr — Graph Algorithrrrs “ (.1. (froitorrr
. Graph Algorithms (1. (1roitorrr - Graph Algorithms Z" (I. (1roitorrr . Graph Algorithms
—

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
a Path problems in digraphs
o Shortest paths - Solving problem P2 for dags: topological sorting
0 Shortest paths - Solving problem P2 for non-negative costs
0 Shortest paths - Solving problem P2 for real costs
o Shortest paths - Solving all-pairs shortest path problem P3
o (Fast) matrix-multiplication
9 Exercises for the 5th seminar (october 28 - november 1 week)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
A directed acyclic graph (dag) is a digraph Without cycles.

A topological ordering of (the vertices) of the digraph G : (V, E), with

lGl : n, is an injective function 0rd : V —> {1,2, . . . , n} (ord[u] : the

ordering number of the vertex u, Vu G V) such that

u'u G E :> 0rd[u] < 0rd['u],Vuv G E.

G : (V, E) is a digraph Without cycles ifand only ifitL has a topological

ordering.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Proof: "4:" Let 0rd be a topological ordering of G. If C’ :
(u1,u1ug,ug,...,uk,uku1,u1) is a cycle in G, then, by the property
of the function 0rd, we obtain the following contradiction
o'rd[u1] < ord[u2] < < 0rd[uk] < 0rd['u,1].
“:>" Let G : (V, E) be a digraph of order n without cycles. We show
by induction on n that G has a topological ordering. The induction
step:
let v0 G V;
while (d6('l)0) 51$ 0) do
take u E V such that u'uo € E;
'uo <— u;
return v0. /
—

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Obviously, since G has no cycles and V is ﬁnite, the algorithm termi-
nates and the returned vertex 'uo has no incoming arc. The digraph
G — v0 has no cycles and by induction hypothesis has a topological or-
dering 0rd’. The topological ordering of G is
1 if 'u : v0
d : ’
or ['11] { 0rd’['u] + 1, if 'u € V \ {'00}.
From the above proof we get the following algorithm for recognizing dags
and constructing a topological ordering for the "yes" instances:
Input: G : ({1, . . . , n}, E) digraph with |E| : m.
Output: "yes" if G is a dag, and a topological ordering 0rd; "no" oth-
erwise.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
construct the array d5[u],Vu E V;
count <— 0; S <— {u 6 V : dau] : 0}; // S is a stack or a queue;
while (s 7r z) do
u <- pop(S); count + +; 0rd['u] <— count;
for (w E A['u]) do
GEM — —;
if (dam : 0) then
push(S, w);
// time complexity C’)(n + m);
if (count = n) then
return "yes" 0rd;
return "no";
—

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
P2 Given G = (V, E) digraph; a : E —> 1R; s 6 V.
Find P;- € Ps¢,Vi 6 V, s. t. a(P;*Z-) : min{a(Psi) : Psi G 7351'}
P2 With G : ({1, . . . , n}, E) dag, with ordh'] : 'L', Vi E V, and s : 1.
Property (I) holds and the system (B) can be solved by "substitution".
'u,1 <— 0; before[1] <— 0;
for (i : 2,7) do
ul- <— oo; beforeh'] <— 0;
for (j : W) do
if ('uq' > UJ' + 0,35) then
ui P uj + aji; beforeﬁ] <— j;
// The time complexity is (9(n2) or @(n + m) if we use adjacency
lists instead of cost-adjacency matrix;
—

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
P2 Given G : (V, E) digraph; a : E —> R; s G V.
Find Pf, G 7351',Vz' G V, s. t. a(P:,~) : min{a(Ps,~) : P5, G 7351'}
P2 with a(e) 2 0,Ve E E.
Property (1’) holds and a solution of the system (B) can be obtained
with the Dijkstra’s algorithm, which maintains the following invariant:
S Q V and
(D)
V16 S u, : min{a,(P$,) : Psi E 'Psi}

{W 6 V \ S u,- : min{a(P$,-) : PS,- G 'PSZ', V(Ps,-) \ S : {2}}
Initially S : {s} and, in each step (of a sequence of n — 1 steps), a new
vertex is added to S, until S : V. Hence, by the invariant (D) from
above, P2 is solved. ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Dijkstra’s algorithm
S e {s}; before[s] <— 0; us <— 0;
for (t' 6 V \ {5}) do
ui <— a“; beforeﬁ] <— s; // (D) holds
While (S 5i V) do
ﬁnd j* G V \ S such that ujw : min{uj : j G V \ S};
S <- S U {j*};
for (j G V\S) do
if (uj > 117* + 077) then
“j P “1* + am; beforetj] P 1”‘;
In the initialisation step we can replace ui <- a“ with ui <— oo. '
—

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Proof of correctness of Dijkstra’s algorithm

Since (D) holds after the initialization step, we have to prove that if

(D) holds before a current while iteration, then (D) holds before next

iteration.

Let S Q V and 21,1,...'u,n satisfying (D) before the current iteration.

First we show that ifj* is such ‘U,_7'* : min{u]- : j 6 V \ S}, then

Suppose that 3P3? 6 73¢ such that a(Pslj*) < 117*. Since S and ui

satisfy (D), we have

“1* I min{a(st*) 1 Psr E 7751*, V(st*) \ 5 I {j*}}-

It folows that V(P$1j*) \ S 75 {j*}; let k be the ﬁrst vertex 0n Pslji

(starting from s) such that k §§ S. ‘
—

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
Proof of correctness of Dijkstra’s algorithm (cont’d)

Then a(P51j*): a(P51k) + a(P,1j*). By the choice of k, we have V(P51k)\
S : {k} and, since (D) is satisﬁed we have a(P51k) Z uk. We obtain that
ujw > a(P51j*) 2 uh + a(P,11-*) 2 uh (the costs are 2 O, so a(P%J-) 2 0.
But this contradicts the choosing of j *.

It follows that in the current iteration, after the assignment S <— S LJ
{j*}, the ﬁrst part of (D) holds.

The for loop after this assignment is necessary in order that the second
part of (D) to be fulﬁlled after the while iteration: Vj E V \ (S U {j*})
min{a(st) I P516 735]‘, V(st) \ (5 U {j*}) I {1}} I
min {min{a(st) 1 P515 7351', V(st) \ 5 I {j}}(: 117'),

min{a(st) 1 P51‘ E 73511V(st)\5 I {j,j*}}(: 0%)}- ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Proof of correctness of Dijkstra’s algorithm (cont’d)
The ﬁrst argument is uj (the value before the updating from the for
loop), and let the second argument be or];
Let Pslj an sj-path such that aj : a(P$1j), j* E V(P51j) and V(Pslj\
(SU{j*}) : {j}; we have aj : a(PS1]-*)+ a(PJl*J-). Since we have proved
that S U {j*} satisﬁes the ﬁrst part of (D), it follows that a(P§J-*) I up
and hence aj : 117* + a(P]~1*]~).
If e(P]-1*j) 7s ejtj, it follows that there exists an t e V(Pj1*j) n s, t‘ 7s 7*.
Hence uj g a(P;‘Z-)+ a(PZ-1j) : 114+ a(PZ-1j) g a(Psll-)+ a(PZ-1j) : a(P51j) :
Olj.
We have obtained that the only possibility to have aj < uj is when
a(Pj1*j) I ajq, in this case aj : up + aJ-tj < uj, which is the test in
the for loop of algorithm (uj is the value before the updating from the
for loop).

D

—

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Time complexity of Dijkstra’s algorithm
Since the for-loop from the While step can be replaced (equivalently) by
for (j e Nam) do
if (uj > 117* + aj*j) then
uj <— uﬁ + aﬁj; beforeLj] <- j*;
the overall time spent by the algorithm to update the values of Uj is
<9( E d§(j*)) I OW)-
j*€ V\{$}
Hence the time complexity is dominated by the sequence of minimum
117* ﬁndings. ‘
—

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Time complexity of Dijkstra’s algorithm

o If the selection of the minimum 117* is made by parsing (Uj)jev\5,
then the algorithm runs in time O((n—l)+(n—2)+- - -+1) : (9(n2).

o If the values of uj for j € V \ S are maintained in a priority queue
(e.g. a heap) then the extraction of each minimum takes (9(1) time,
but the time needed to execute all uj reductions is in the worst
case (9(m log n) - there are (9(m) possible reductions, each needing
0(log n) time for the heap maintaining (Johnson,1977).

o The best implementation is obtained by using a Fibonacci heap
with time complexity (9(m + n log n) (Fredman 8a Tarjan, 1984). ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
o In order to solve the problem P1 using Dijkstra’s algorithm, we add
a test to stop the execution when the target vertex t is introduced
in S. The worst-case time complexity remains the same.

o A nice heuristics directing the search toward t is obtained with
the help of a consistent estimator, that is a function g : V —> 1R+
satisfying the following two conditions:

(i) Vi E V, uz- + 9(2) g min{a(Pst) : Pst E 'Pst and i E V(Pst)}
(ii) Vii e E,9(i) é an + 90)-
o Clearly, g('1l) : 0, Vi is a trivial consistent estimator. /
—

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
a If V(G) is a set of points in an Euclidean space then, by taking
9(2) = the Euclidean distance from 2' to t, we obtain a consistent
estimator in the hypothesis that conditions (ii) are fulﬁlled.

a If g is a consistent estimator, then the choice ofj* in the Dijkstra’s
algorithm is made by

“1* + 90*) I min{u1'+ 9(1) 1j€ V \ S}-
The correctness of the proof is similar to that given for 9(1) : 0,
Vi.
o This algorithm is part of the A* family of algorithms.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Bellman-Ford-Moore algorithm
If there is z'j E E such that al-J- < 0 then Dijkstra’s algorithm can fail
("best ﬁrst" strategy does not work). Assuming that
(1’) a(C) 2 0,VC cycle in G,
we will solve the system
'u,s : 0

B . a
( ) { 'uq' : 1111111751‘ (Uj + 07¢),VZ 75 S
by successive approximation.

H.‘ ._._. Ash.‘ ..__. -vn.‘ t--. J

—

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Bellman-Ford-Moore algorithm
Let us deﬁne
(BM) uik I min{a(P) ; P e 7351-, |E(P)| g k},v¢ e V,k I 1,11 _ 1
Since the length (number of arcs) of every path in G is at most n — 1,
it follows that if we construct

111 I (“tr-wilt),

112 I (u12,---,ui),
then u“1 is a solution of the system (B). Since the values of u1 are
clear, if we give a rule of passing from uh to u":+1 we obtain the following
algorithm to solve (B):

—

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Bellman-Ford-Moore algorithm
usl P 0;
for (i E V \ {5}) do
u} k a“; //obviously (BM) holds.
for (k : m) d0
for (z' : U) do
11.er1 <— min (uZ-k, minjﬂ (qu + 09-1));
In order to prove the correctness of this algorithm, we will show that if
11k satisﬁes (BM) then uk+1 satisﬁes (BM), for k : m ‘
—

***************Ending Page***************


***************Beginning Page***************
***************page number:20**************
Bellman-Ford-Moore algorithm
us : 0

B t
( ) { 'uq' : 1111111751‘ (Uj + 07¢),VZ 75 S
For z' € V, let us consider the following sets of paths:

A:{P : P673515 1engthofP<k+l}

B : {P : P 6 73M‘, length ofP g k}

C':{P : PEP“, 1engthofP:k;+1}
Then, A : B U C’, and
min{a(P) : P E A} I min(min{a(P) : P E B},min{a(P) : P E C})
Since qu satisﬁes (BM) we have

min{a(P) : P E A}: min(uf,min{a(P) : P € C})
—

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
Bellman-Ford-Moore algorithm

Let min{a(P) : P G C} I a(P°), for P0 G C’. Ifj is the vertex

before i G P0 (such aj must exist since P0 has at least two arcs), then

a(P0) : a(P2]~) + aﬁ 2 ujk + aj, (since P2, has k: arcs and uk satisﬁes

(BM). Hence

min{a(P) : P 6 A}: min(uf,rjn7ién(ujk + 0%)),

that is, the value assigned to ufﬂ in the algorithm.

The time complexity is (9(n3) if the minimum in the second for loop

needs (9(n) time.

The shortest paths can be obtained as in Dijkstra’s algorithm, if the

array beforeﬂ, trivially initialized, is appropriately updated when the

minimum in the second for loop is found.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Bellman-Ford-Moore algorithm
0 We can add to the algorithm the following step:
if (at e v such that uZH > minj¢¢ (ufvl + em) then
return " a negative cost cycle exists";

In this way we obtain an 0(n3) time test if the digraph G and
the cost function a violates condition (1’) (otherwise afil cannot
be decreased). The cycle of negative cost can be found using the
vector beforeﬂ.

o If there is k: < n - 1 such that u'“ z ukH , theh the algorithm
can be stopped. Based on this idea, it is possible to implement the
algorithm in (9(nm) time, by keeping the vertices t' for which the
value ui is changed in a queue.

—/
—

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
P3 Given G : (V, E) a digraph and a: E —> 1R ﬁnd
Pg; € Piﬁvnj € V, s. t. a(PZ‘j) = min{a(Pij) : P17‘ E 7317'}

o Let uij : min{a(PZ']~) : Pij 6 7911} Hence, we have to ﬁnd the
matrix U : (Uij)n><n, when the cost-adjacency matrix A is given.

o Each shortest path can be obtained in (9(n) time if during the
construction of the matrix U we maintain the matrix Before :
(beforeZ'J-Mxn, in which beforeij :the vertex before j on the shortest
path from i toj in G.

o If the pair (G, a) satisﬁes condition (1’), we can solve P3 by calling
Bellman-Ford-Moore algorithm for s E {1, . . . , n}, with overall time
@(n4). There are faster solutions that we’ll discuss in the next
slides. v

—

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Iterating Dijkstra’s algorithm

If all costs are non-negative, we can solve P3 by applying Dijkstra’s

algorithm for s 6 {1, . . . , n}, with overall time (9(n3).

The iteration of Dijkstra’s algorithm is also possible when we have nega-

tive costs, but condition (1’) is fulﬁlled, after a nice pre-processing. This

is the Johnson’s algorithm.

Leta: V —> R such that V'Zj G E, (1(1) + aij 2 a(j).

Let E: E —> R+ given by EU : aij + 04(1') — a(j), Vij E E.

We have ﬁij 2 0 and it is not difficult to see that for any Pij E 'Pij,

(*) WPZ'J') I a(P¢j) + [61(1) — (10)]-

Hence, we can iterate the Dijkstra’s algorithm for ﬁnding the shortest

paths with respect to costs E. ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
Iterating Dijkstra’s algorithm
Relation (*) shows that a path is of minimum cost with respect to cost
E if and only if it is of minimum cost with respect to cost a (since
6(Pij) — a(PZ-j) is a constant which does not depend on P/L'j). So, we
have the following algorithm:

1: ﬁnd a and build the matrix Z;

2: solve P3 for Z, returning F and W;

3: ﬁnd U(’U,1'j: Eij — 06(1) + 0(0)),
The step 2 needs (9(n3) by iterating Dijkstra’s algorithm. The step 1 can
be also performed in 0(n3), by choosing a node s 6 V and solving P2
with the Bellman-Ford-Moore algorithm (which tests also if condition
(1’) is fulﬁlled).

—

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Iterating Dijkstra’s algorithm
Indeed, if (uni 6 V) is a solution for P2, then (um E V) satisﬁes
the system (B), so uj : mini¢j ui + aij, that is, Vij 6 E, we have
uj g ul- + aij. Hence, aij + uZ- — uj 2 0, Vij E E, which shows that we
can take a(z') : ui, Vi 6 V such that the condition (*) holds.
Floyd - Warshall algorithm
Let
“I; I min{a(Pij) I P11 G 7%‘, V(Pij)\{'1;,j}<_:{112,~-,k — 1}}
Vi,j E V,k: 1,n+1.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
Floyd - Warshall algorithm

Obviously, ullj : aij, Vi,j € V (we suppose that au' : 0, Vi G V).

Moreover,

uikfl : min {uZ-kj, usC + ulljj},Vi,j G V, k : 1,7.

This follows by induction on k. In the inductive step: a shortest path

from i to j Without internal vertices 2 k + 1 either does not contain

the vertex k; and its cost is uZ-kj, or contains the vertex k and then its

cost is all}; + u]; (by the Bellman’s optimality principle and induction

hypothesis).

Obviously, if we get us < O, then there exists a negativ cost cycle C‘

passing through the vertex z' with V(C’) \ {z} Q {1, . . . , k — 1}. ‘
—

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
for (z' : Lin) do
for (j : 1,7) do
before('1l,j)+i;
if (z' : j) then
au- <— O; before(z', i) <— 0;
for (k : Lin ) do
for (2' : Lin) do
for (j : 1,7 ) do
if (aZ-j > (Mk + akj) then
aij <— am + akj; before(z',j) <- before(k,j);
if (2' :j and aij < O) then
return "negative cycle";
—

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
This method for solving P3 is known as Floyd - Warshall algorithm:

Obviously, the time complexity of the algorithm is (9(n3).

If we know that the digraph has no negative cost cycle, then if the diag-

onal entries of A are initialized with oo, the ﬁnal value of each diagonal

entry is the minimum cost of a cycle passing through the corresponding

vertex.
—

***************Ending Page***************


***************Beginning Page***************
***************page number:30**************
(Fast) matrix-multiplication

Suppose that the condition (1’) is fulﬁlled and in the cost-adjacency
matrix the diagonal entries are 0. Let

u; : min{a(PZ-j) : PZ-J- 6 7913-, PZ-J- has at most k; arcs}
Vi,j E V,l<: : 1,n— 1.
Let us denote by Uk : (ufj)1<Z-7j<n for k E {0,1,2,...,n — 1}, Where
U 0 has all entries oo, except the diagonal entries which are all O. Then,
iterating the Bellman-Ford-Moore algorithm can be described in a ma-
trixrfworni aszi , , w w ‘ , , , h‘ w , , j
—

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
(Fast) matrix-multiplication
for (m e V) do
if (i 7s j) then
ug- <- oo;
else
ug <— 0;
for (k:0,'n,—2 ) do
for (m e V) do
“5+1 I Egg (11% + ahj);
—

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
(Fast) matrix-multiplication
Let us consider the following "matrix-multiplication":
VB, C E Man; B ® C : P I (pij), where pi)‘ I 1111303,], + ij).
k:1,n
Note that the ® operation is associative and that it is similar to the
usual matrix-multiplication.
We can write UM1 : Uk ® A and, by induction, we obtain
U1 z A, U2 z 14(2),...,U"_1 z A<"—1),
where AU“) I A(k_1) ® A and 14(1) z A.
In the hypothesis (1’) we have: Am) : Amil), Vp with 2p 2 n — 1.
Hence, computing successively, A, A(2), A“) : A(2)®A(2), . . ., we obtain
an (9(n3 log n) time algorithm for solving P3. ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
—
If ® operation is implemented with faster algorithms, the above n3 in
the time complexity of the algorithm can be replaced by n1°g2 7 : 112-81
(Strassen 1969), or by 1223728639 (Cooppersmith 8z Winograd 1987, Le
Gall 2014). ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Exercise 1. Run the Dijkstra’s algorithm on the following digraph.
W
2
V
3 ' 1
s u
‘ 4
v
Z
—

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
Exercise 2. Find the minimum cost paths starting in s on the following
acyclic digraph using the ’substitution’ algorithm.

t 1 Y W

o ’ v’ 3 r
u .
2
S
—

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Exercise 3. A graph G is given functionally: for each vertex v E V(G)
we obtain N g(’U) at cost 1; alternatively, after a preprocessing of cost T
(T >> 1), we obtain Ng('ll) and also Ng(w), for all vertices w 6 V(G).
In G, a path P is constructed by starting from an arbitrary vertex
and choosing an unvisited neighbor from each current vertex until no
choice is possible. After the path is completed we can compare its cost,
Online(P), with the best possible cost at which it can be obtained,
Oﬁiz'ne(P). Devise a strategy of accessing the sets of neighbors such
that
Onl'me(P) g (2 — %) - Oﬁine(P).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Exercise 4. Let D be a digraph and a : E(D) —> Rl, b : E(D) —> R1.
Devise an eflicient algorithm for ﬁnding a cycle 0* of D, such that
a(C*) . a(C) .
TQM‘) : min {17(0) : C’ cycle 1n D .
Exercise 5. In the problem of ﬁnding the shortest paths from a given
vertex s to all vertices of a digraph G : (V, E), we have a cost function
c : E —> {O,1,...,C} Where C’ E N does not depend on n : |V| or
m : |E| How do you modify the Dijkstra’s algorithm in order to reduce
the time complexity to C’)(n + m)?
—

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Exercise 6. Let D : (V, E) be a strongly connected digraph of order
n and a : E —> R a cost function on its arcs. If X is a walk, a path or
a cycle in D, then a(X), the cost of X, is the sum of the cost 0n its
arcs, len(X), the length of X, is the number of its arcs, and aavg(X),
X
the average cost of its arcs, is aavg(X) : 137502). Let
agvg : min_ aavg(C').
0 cycle 1n D
For a given vertex s G V and k E N*, we denote by Ak(v) the minimum
cost of a s'u-walk of length k in D (if any, otherwise Ak('u) : oo). ,
—

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
Exercise 6. (cont'd)
a) If D doesn’t contain negative cost cycles, but there exists a cycle C’
with a(C’) : 0, prove that there exists a vertex 'u G V such that
1471(1)): min{a(P) : P is a s'u-path from s to 'u in D}.
b) Show that if ajvg : 0, then
. A (v) — AW’)
* _ Tl
(MMC) aavg — 221%} 05151254 n — k '

c) If agvg 75 0, transform the function a such that the new function
a’ satisfy the hypothesis from b) and from (MM C ) which holds a’
follows that (MM C ) holds for every function a.

__.c.c .._._. ._c.‘ .. w--. __.c.c . J
—

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Exercise 7. In various applications for a given digraph G : (V, E),
a : E —> R+ we have to persistently answer to a question of the following
type: What is the shortest path between s and t? (5,13 E V, s 75 t).
For a very large digraph, G, it is proposed the following bidirectional
Dijkstra algorithm:
o build up the inverse of G, G’, with a cost function a’ : E(G’) —> Rim
given by aéj : aji, Vij € E(G’);
o successively apply a step from Dijkstra’s algorithm to G and a
(starting from s) and to G’ and a’ (starting from t);
o when vertex u is introduced in S (the set of labeled nodes in Dijk-
stra’s algorithm) by both instances of the algorithm we stop;
o return the path from s to u in G joined with the inverse of the path
from t to u in G’.
Prove that this procedure it is not correct, by giving an example that is
inconsistent with it.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
Exercise 8. Give an example of a digraph with negative-cost arcs for

which Dijkstra’s algorithm fails.

Exercise 9. Let G : (V, E) be a digraph, a : E —> 1R+ a cost function

deﬁned on its arcs, and 11:0 E V from vvich any other vertex in G is

accessible. An SP-tree for the triple (G, a, x0) is a directed rooted (in

x0) tree of G, T : (V, E’) such that the cost of the path from x0 to u

in T is the cost of the shortest path from $0 to u in G, for every u E V.

(a) Prove that an SP-tree always exists.

(b) Devise an algorithm that ﬁnds an SP-tree.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Exercise 10. Let G be a connected graph. Prove that
a) any two maximum length paths of G have a non-empty intersection.
b) if G is a tree, then all maximum length paths in G have a non-
empty intersection.
—/
Exercise 11. Let G : (V, E) be a connected graph.
a) Show that there exists a stable set, S, such that the spanning
(bipartite) graph H : (S, V \ S; E’) is connected, Where E’ :
E\ (V \ S).
2
G —1
(b) Prove that a(G) 2 M.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
Exercise 12. Prove that any tree, T, has at least A(T) pendant nodes.
Exercise 13. Let G be a graph with n Z 2 vertices and m edges.

a) Prove that G contains at least two vertices of the same degree.

b) Let 'r(G) the maximum number of vertices having the same degree

in G. If we denote by dmed : 2m/n, show that
n
r G > ll .
( )/ deed _ 26(G) + 1
Exercise 14. Prove that a digraph has an unique topological ordering
if and only if it has a Hamiltonian path and all other arcs are directed
forward with respect to a traversal of this path.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Exercise 15. Let G : (S, T; E) be a bipartite graph with the following
properties:
- |S| : n,|T| : m (n,m 6 N*);
- Vt G T, INg(t)| > k > 0 (for a given k < n);
- ‘W1, t2 6 T, if t1 7i t2, then {Ng(t1) fl Ng(t2)] I k;
Prove that m g n; /
Exercise 16. Let G : (V, E) be a digraph; we deﬁne a function fG :
73(V) —> N by fG(@) : 0 and fG(S) : |{'u : 'u is accesible from S}|, for
o 7r s g v.
(a) Prove that, for every digraph G, we have
fG(S) +fG(T) >fG(SU T) +fG(S n T), V5’, T Q V-
(b) Prove that (a) is equivalent with
fG(Xw{v})—fG<X) >fG(Yw{v}>—fG<Y),\1X c Y c V,Vv e my
—

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
Exercise 17. A student decided to run each day from his home to the
university campus. The city map contains m two-ways street segments
(a segment lies between two intersections) whose strictly positive lengths
are known. He wants t0 go only uphill (hence slower in the ﬁrst part
of his running) before going only downhill (hence faster in the second
part). (An uphill street segment is a segment ending in an intersection
of strictly larger altitude than its starting intersection; a downhill street
segment is a segment ending in an intersection of strictly lower altitude
than its starting intersection.)

(a) Describe an efﬁcient algorithm (0(n + m) time complexity, where
n is the number of intersections) for ﬁnding the minimum cost path
meeting the student requirements (if such a path exists). .

—

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Exercise 17. (cont’d)

(b) After a few days of running he ﬁnds that the structure of the path
makes it too exhausting and decide to accept routes that contains
level street segments, hence, in the ﬁrst part of the path he wants to
go uphill or level, while in the second part he will accept downhill
or level segments.

Give an eﬁicient algorithm to solve this new problem; what is the
time complexity of such an algorithm? ,

Exercise 18. Let G : (V,E) be a digraph and let V be the family

strongly connected components of G. Deﬁne the digraph Q : (12,5 ),

where for every H’, H” 6 V, H’H” 6 <9 if there exists an arc 'u’v” E E

such that 'u' E V(H’) and 'u” G V(H”). An ordering v1,v2,...,'un of

the vertices of G is called a SP-topological ordering if for every arc

'ujvi E E, with 1 g i <j g n, the vertices 11¢,111+1,---,'Uj belong to the

same strongly connected component of G. ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
Exercise 18. (cont’d)

(a) Prove that Q is an acyclic digraph.

(b) Devise an (9Q V] + IE!) time complexity algorithm for ﬁnding a SP-
topological ordering of the vertices of G.

(c) Prove that for any path D in G there exists a SP-topological or-

dering of the vertices of G v1, '02, . . . , 'un such that for every two
,Y?Tfifis...?i?f’j .6‘ K‘? )1?§7’3?§9PFS 1069557’; 9591?}??? ‘1 < j ' a
—

***************Ending Page***************

