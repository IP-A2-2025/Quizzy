***************Beginning Page***************
***************page number:1**************
(1. Groitor rr . Graph >\lgorithms (1. (1roirorrr . Graph >\lgorirhms (1. (1roirorrr . Graph .'\lgorirhms
(.1. (.‘roitorrr - Graph Algorirhrrrs il‘ (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - Graph
Algorithms (1. (1r'oiior'rr - Graph Algorithms ’ (1. (Yroitorrr . Graph Algorithms (1. (".r'oirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgorirhrrrs' (.1. (.1roirorrr — Graph Algorithrrrs :1‘ (.1. (froitorrr
Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms ‘ (1. Groiror rr . Graph >\lgorirhms (1. (1roirorrr
- Graph Algorithms (.1. (.1roitorrr - Graph Algorithrrrs sl‘ (.1. (.1roirorrr - Graph Algorithms (.1.
('Iroiroru - Graph Algorithms (1'. (1roirorrr . Graph .-\lgrn'ithm.s (1. (1roitoru - Graph Algorithms‘ Z‘:
(.1. (.froitortr - Graph Algorithrris “ (.1. (.1roitorrr - Graph \lgorirhrrrs (.1. (.froirorrr — Graph Algorithrrrs
(1. (1roitorrr - Graph Algorithms Z" (I. (1roirorrr - Graph Algorithms (1. (1roitorrr - Graph
Algorithms “ (1. (“roirorrr . Graph \l " ' '1. (‘ oi r "iraph \lgorithms (1. (“roirorrr .
Graph Algorithms (1. (.roirorrr - (irgllﬁggtﬁiﬁllrrg-sgﬂ (2953mm - Graph Algorithms (1. (.roirorrr
. Graph \lgor'ithms (1. ('Ir'oitorrr . Graph Algor irhms l (1. (1|oiror tr . Graph ‘\lgor ithms (1.
(froiroru ~ Graph Algorithms (.Q. (Qr'oiror'rr ~ Graph Algorithms (.1. (.froitoru ~ Graph Algorithms 2*
(1. ('Iroitor rr . Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms (1. Groitor rr . Graph >\lgorithms
(.1. (froitor'rr - Graph Algoritlrrrrs *1 (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - (.lraplr
>\lgorithms (1. (1roirorrr - Graph .'\lgorirhms ’ (1. Groirorrr . Graph >\lgorithm.s (1. ("Iroirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgrirrirhrrrs' (.1. (.Irririrorrr — Graph Algorithrrrs “ (.1. (froitorrr
. Graph Algorithms (1. (1roitorrr - Graph Algorithms Z" (I. (1roitorrr . Graph Algorithms
—

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
a Graph Theory Vocabulary
o Associated matrices
9 Data structures
a Path problems in digraphs
o (Di)graph traversal
o Shortest paths
a Exercises for the 4th seminar (october 21-25 week)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
Let G be a graph with V(G) : {111,...,'un}. The adjacency matrix of
G is the matrix A : (aij)1<Z-j<n G Mnm({0, 1}), Where
a-- _ 1, if 'ui and 'uj adjacent
Z] — 0, otherwise ‘
A graph and its adjacency matrix.
“Z O 1 1 1 O
1 O O 1 O
1 1 O O 1
O O 1 1 O
—

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Let G be agraph with V(G) : {111,...,'un} and E(G) : {e1,...,em}.
The incidence matrix of G is the matrix B : (bij)1<¢j<n G
Mnxm({0, 1}), Where
b--— 1, if ej is incident with vi
Z] — 0, otherwise ‘
A graph and its incidence matrix.
1 1 0 0 0 0
z 001001
O 1 O 1 1 O
O O O O 1 1
—

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
The eigenvalues, eigen vectors and the characteristic polynomial of the
adjacency matrix are called eigenvalues, eigen vectors, and, respectively,
characteristic polinomial of the graph. These are the objects of study
for spectral graph theory.
For digraphs, similar matrices can be deﬁned with entries in {-1, 0, 1}
in order to point out the direction of arcs.
Let G be a digraph with V(G) : {1/1,... gun} and E(G) :
{e1, . . . , em}. The vertex-arc incidence matrix of G is the matrix

1, if ej is incident from v,

bZ-j : —1, if ej is incident into '0,- .
0, otherwise
—

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Let G : (V, E) be a (di)graph With V : {1, 2, . . . , n}

o If A : (aij)1<¢j<n is the adjacency matrix of G then, representing
it as a a 2-dimensional array, we need 0(n2) time for initialization
(depending on the programming language).

o Hence any algorithm that represents G with adjacency matrix has
9(n2) time (and space) complexity.

o Testing if two vertices are adjacent is done in (9(1) time, but passing
through the set of neighbors Ng('u,) (or Ng+(u)), for a certain vertex
u € V, needs Q(n) time - unpractical for large sparse graphs.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Let G : (V, E) be a (di)graph with V : {1,2, . . .,n} and |E| : m.

o Every vertex u G V has a list, A(u), of its neighbors in G:

> when G is a graph A(u) : Ng(u);
> if G is a digraph, then A(u) : Ng(u) I {v E V : uv G E};

o If G is a graph, then each edge u'u E E generates two elements in
the adjacency lists: one in A(u) and one in A('u); the space needed
is 0(n + 2m).

o If G is a digraph, then the space needed is (9(n + m).

o Adjacency lists can be implemented using linked lists or using ar-
rays.

o Testing if a vertex u is adjacent to another vertex 'u in G needs
(9(dg(u)) time, but passing through the set of neighbors Ng(u) (or
N§(u)), for an arbitrary vertex u 6 V, can be done in 9(dG(u))
time (and not in (9(n) time as in the case of adjacency matrix).

—

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Graph traversal or graph search is an algorithmic paradigm specifying
a systematic method to pass through the set of vertices reachable by
paths starting from a speciﬁed vertex in a (di)graph.

Given a (di)graph G : ({1, . . . , n}, E) and s E V(G)

"efﬁciently" generate the set

S : {u E V(G) : there is a path from s to u in G}.
G Will be represented with adjacency lists, because, during the traversal
process, we need to handle in an efficient way the set of neighbors of the
curl?9l.,Y?Ft.?X-. ,. ..

—

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
for v E V do
label(v) <— —1; parent(v) <— —1;
label(s) k O; pa¢ent(s) k O;
create queue Q containing s;
While Q 75 6 do
u <— p0p(Q);
for 'u G A(u) do
if label('u) < 0 then
label('u) <- label(u) + 1;
parenﬂ'u) <— u; push(Q,1/);
—

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Properties of BFS. It is not diflicult to prove that:

a S : {u € V : label(u) Z O};

o Vu 6 V, label(u) : dg(8, u) (the distance in G from s to u);

o Variable parent deﬁnes the bfs-tree associated to the search from s:
if G is a graph then the bfs-tree is a spanning tree of the connected
component containing s; if G is a digraph then the bfs-tree is an
arborescence (directed rooted tree in which all arcs point away from
the root s).

o The time complexity of BFS(s) is (9(n5 + m5), where n5 : |S| g
|V| : n, and mg : |E([S]G)| g |E| (this follows easily by ob-
serving that each node in the adjacency list of a vertex from S is
accessed exactly once).

—/
—

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
Two BFS’s on the same digraph (starting from z and from 'u):
I 2(1) 11(1)
14(1) : [y]
06(2) M3) Z(2)
A<Z) : My]
A(u) I w
1K4) 'v(5) 1(3) 11(4)
u 1/ AW) I [Z]
11(5)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
for v E V do
label(u) <— —1; parenﬂu) P —1;
label(s) P O; parent(s) P 0;
create stack S containing s; n5 k O;
while s 7s r21 do
u <— t0p(S);
if ((11 P ne$t[A(u)]) 5i NULL) then
if label('u) < 0 then
n5 + +; label(v) <— n5;
parenﬂ'u) k u; push(S, v);
else
delete(S, u);
—

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Properties of DFS. It is not difficult to prove that:

o {u 6 V : label(u) 9 0} is exactly the set S of the vertices reachable
by paths from s;

0 Vu E V, label(u) : visiting time of u (s has visiting time 0);

o Variable parent deﬁnes the dfs-tree associated to the search from s;

o The time complexity of DFS(s) is (9(n5 + m5), vvhere n5 : IS‘ g
|V| : n, and mg : \E([S]G)| g lE| (this follows easily by ob-
serving that each node in the adjacency list of a vertex from S is
accessed exactly once). /

—

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Two DFS’s on the same digraph (starting from z and from a3):
14(1) = [y]
y z AW) = [1w]
y(2) z(5) 31(2)
14(1) = [1M]
A(u) = (0
u(3) 11(4) u(3) 11(4)
u 1; A(v) = [z]
z(5)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Let G : (V, E) be a digraph, with V : {1, . . . , n}.
0 Each directed edge (arc) e € E has associated a cost a(e) G R
(weight, length etc).
o If G is represented with adjacency lists, then a(z'j) is a ﬁeld in the
node of adjacency list of 'i (representing the arc z'j)
o For ease of notation we will use the representation of G with the
cost-adjacency matrix A : (a,j)1<,~1jgn, Where
a1,- :{ a('1lj), if ij e .E '
oo, otherw1se
—

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
o Here, oo denotes a big real number with respect to actual edge
costs (e.g., oo > 71-15132; a(z'j)) and we suppose that oo i a : oo,
oo + oo : oo.

o It is also possible to use oo as an unsuccessful access to the data
structure used to represent the matrix A.

0 For 7L,j G V, the set of all paths in G from 2' toj is denoted by 7315:

7913' : {P : P is a path from 2' to j}. ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
—

a If Pij E 7917, Pij : (2' :)'uo, v0v1,111, . . .,v,,i1,'uri1vr,'ur(: j), then

V(P¢j) : {'00, v1, . . . , '11,}, E(PZ-j) : {110111, . . . , 'u,»_1'ur}.
o The cost of Pij E 7915 is
a(PZ-j) I 0 + Z auv-
Mempij)

0 In particular a(Pii) : 0.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Single-pair shortest path problem.
P1 Given G : (V,E) q digraph; a : E —> 1R;s,t€ V,s 75 t.
Find P; € 7357;, such that a(Ps*t) : min{a(Pst) : P5,; E 735,5}.
Single-source shortest path problem.
P2 Given G : (V,E) a digraph; a: E —> Rs E V.
Find Pf;- € 7331',Vi 6 V, s. t. a(P;‘Z-) : min{a(Ps¢) : P31- G 7331'}
All-pairs shortest path problem.
P3 Given G : (V, E) a digraph; a: E —> R.
Find Pg; G Pij,Vi,j G V, s. t. a(Pi*j) : min{a(Pij) : Pij E 7917}
—

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
o The cost-adjacency matrix representation of the pair (G, a) implies
that 'PZ-j 5i Q, W,j E V(G): if a(PZ-j) < oo, then Pij is a true path
in G, and if a(PZ-j) : oo, then Pij is not a path in G but it is a path
in the complete symmetric digraph obtained from G by adding all
missing arcs (with oo costs).

o It follows that all sets over which a minimum cost element is re-
quired in the problems P1 - P3 are non-empty and ﬁnite and all
minimum paths required are well-deﬁned.

o The algorithms for solving the problem P1 are obtained from those
solving the problem P2 by adding an (obvious) stopping test.

o The problem P3 can be solved by iterating any algorithm for the
problem P2. We’ll see that there are more eﬁicient solutions.

WWW
—

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
1. Communication Networks. The digraph G : (V,E) represents a
communication network between the nodes in V and with E modeling
the set of directed links between nodes.

o If a(e) 2 0 (Ve 6 E) represents the length of the direct connection
between the extremities of e, then the problems P1 - P3 are natural
shortest paths problems.

o If a(e) Z 0 (Ve € E) represents the time needed for the direct
connection between the extremities of e, then the problems P1 - P3
are natural fastest paths problems.

o Ifa(e) € (0,1] (Ve 6 E) represents the probability that the direct
connection between the extremities of e works properly, and we
suppose that edges work properly independent of each other, then
the problems P1 - P3 become most reliable paths problems:

—

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
If PZ-J- E 731-]- for some pair i, j E V, then the probability that this path
works properly is (by the independence assumption)
P'rob(P1-J-) : H a(e).
e€E(PiJ')
By taking a’(e) : —log a(e),
log P'rob(PZ-j) : log H a(e) : — Z a'(e).
6EE(PZ'J') 6EE(PZ'J')
By the monotonicity of the log function it follows that the problems
P1 - P3 with costs a’, give the most reliable paths in communication
network.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
2. PERT Networks - Critical Path method (CPM). PERT (Path
Evaluation and Review Technique) is a method to analyze (especially)
the completion time of each task in a given complex project.

a Let P : {A1,A2, . . .,An} be atomic activities of a large project

P (n is big). (P, <) is a partially ordered set, where Ai < Aj if
z' 5i j and activity AJ- can be started only after the activity AZ- was
ﬁnished.

o For each activity Ai, its completion time 15¢ is given (estimated).
Find a scheduling of the activities of the project to minimize its total
completion (calendar) time.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
We can associate a directed acyclic graph to the problem in this way:

o to each activity Ap (p E {1, . . .,n} we add an arc 1ij with cost
GU???) I tP;

o the node ip corresponds to the beginning event of AP and the node
jp is associated to the ﬁnishing event of it;

o if an activity Ak can start only after the activity Ap we add the arc
jp'llk (dummy activity). J

—

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
o The construction of the digraph is ﬁnished after adding a node s
corresponding to the start event of the project linked by arcs sip for
each activity Ap with no incoming arcs, and a node t corresponding
to the terminal event of the project linked by arcs jpt for each
activity A1,, with no outgoing arcs.

o In the obtained digraph, the maximum cost of a path from s to t
is equal to the minimum completion time of the project.

o A maximum cost path is called a critical path since any delay of an
activity on this path infers a delay of the Whole project. ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
A]:tl A82t8 0
u 0
l
0
A61t6 0
0 ~ °
A32t3 O ¢
0.710110
A72t7

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
3. Knapsack problem (O — 1). We are given a knapsack of size b G N,
and n objects of sizes a1, . . . , an € N. Also is known the proﬁt pi 6 N of
inserting the object i (2' E {1, . . . , n}) into the knapsack. We are asked
to choose a ﬁlling of the knapsack of maximum total proﬁt.
Let xi, for i 6 {1, . . . , n}, be a boolean variable having the meaning that
a31- : 1 if and only if the object '1; is inserted into the knapsack. Then
the knapsack problem can be stated as

TL TL

max {Elli-‘Bi : Z aZ-wi g b, xi G {0, 1},V'1L : Ln}.
1:1 1:1
—

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
o Let G : (V, E) be the digraph With V : {s}U V1 U...LJ VnLJ{t},
Where V1- : {10, 1'1, . . . , ib} is associated to object 1L, z' : 1,7
o The arcs of G and their costs are:
> 510 and $1“1 with a(slo) = 0, a(sla1) : p1 (either the object 1 is
added to the knapsack with proﬁt p1 and ﬁlling level a1 , or it is not
added, with the proﬁt and ﬁtting level 0).
> (z — 1)jz'j with (1((1' — 1)jz'j) : 0, Vi : 2,7,Vj : W (the object
i is not inserted into knapsack: from the ﬁlling With the ﬁrst i — 1
objects and ﬁlling level j, we pass to a ﬁlling with the ﬁrst 2' objects,
Without object i; the ﬁlling level remains j and the additional proﬁt
is 0).
> Ifj — ai 2 0, then we have also the arc (z — 1)j_“*z'j with a((i —
1)j_“1z'j) : p1- (We can arrive at the ﬁlling level j by inserting the
object i to a ﬁlling with the ﬁrst 2' — 1 objects, With the ﬁlling level
j — 111-)-
—

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
> njt with a(njt) : 0, Vj : 0,7. l
—
o Each path from s to t in G corresponds to a subset of objects with
the ﬁlling level g b and With the total proﬁt equal to the cost of the
path. Since, conversely, to each ﬁlling of the knapsack corresponds
a path from s to t in G, it follows that the knapsack problem can
be solved by ﬁnding a path of maximum cost in the directed acyclic
graph G.
o The static description given above for G can be transformed into
a procedural one, giving the usual dynamic programming solution.
Note that the problem is NP-hard (the order of G could be expo-
nential in the input size of the problem). ‘
—

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
0 1:0 O 2:0 n:0
s
111 2 2:1 11:1
0
. . O
I n12
p1 : 0
I 0 2:a2 I
lzal
2:'a1+a2
I 0 I
11b .—,.—>
2:b n:b

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
P2 Given G : (V, E) digraph; a : E —> R; s G V.

Find P; G 7351',Vz' G V, s. t. a(P;~) : min{a(Psi) : Psi G 7351'}
Let G be a digraph, s G V(G) : {1,...,n} and a : E(G) —> R, s. t.
(I) a(C’) > 0, for all C cycle 1'11 G.
Then (ul, . . . , un) is a solution of the system of equations

Us : O I I
(B) 1111' I miIle + aji) 1f and only 1f
1751
Vt E V(G), ZIP;~ 6 Psi s. t. ui = a(P;‘Z-) = min{a(P) : P E 7951'}. ,
—

***************Ending Page***************


***************Beginning Page***************
***************page number:31**************
Proof:

"<:“. Let P; be an optimal solution of P2 and ui : a(P;‘i).

The hypothesis (I) implies that us : 0, i.e., the ﬁrst equation of the

system (B) is satisﬁed. For i 5i s, the path P; has a penultimate vertex

j. If PSJ- is the path from s toj determined on P;- by j, we have

“i I (‘(PZZ') I (‘(1331) + “11> a(P:j) + aji I 111+ aﬁ-

Now, we show that ui : uj + aji. Suppose that ui > uj + aji, i. e.,

a(P$J-) > a(P;“J-). ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Case 1. z' Q V(P:j). Then P1 : P;- o (j,ji,i) 6 7351‘ and a(P1) I
a(P;‘j-) + aJ-Z- < a(P$]-) + ajz- : a(P;‘i), a contradiction (P; is a shortest
path).
Pa]
—

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
Case 2. i G V(P:j). Let P; : Psi o P17, the two paths determined by
the vertex z' on P2}. Then the cost of the cycle C’ : Pij o (j,jz',z') is
a(C) : a(PZ'j) + aji : a(P;‘j) — a(PSZ') + aji : 117+ a]; — a(Ps¢) which is
g uj + ajl- — a(P;"Z-) : Uj + aJ-Z- — ul- < 0, a contradiction (the hypothesis
(I) is violated).
—

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Hence the "c" part of the theorem is proved. J

We proved above that if j is the vertex before z' on a shortest path from

s to 2', then the path from s toj determined byj on this shortest path

is a shortest path from s to j. Inductively, it follows:

Bellman’s Principle of Optimality: If P; is a shortest path from s to

z', then Vj 6 V(P;*Z-), if P;- : st o Pji, then st (respectively Pji) is a

shortest path from s toj (respectively fromj to 2').
—

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
":>". We show that if (u1,. . . , an) is a solution of (B), then
(a) EIPSZ' G 7351' such that ui : a(Psi), Vi E V.
(b) W G V, uz- : min{a(P) : P E P$¢}(: a(PSl-)).
(a) If i : s, then us : 0 and the path P55 satisﬁes a(Ps$) : O : us.
If z' 5i s, let us consider the following algorithm
'u <— z'; k <— O;
While 'u 75 s do
ﬁnd W s. t. up = uw + aw;
// there exists such a w since uv satisﬁes (B)
ikP'U;k‘—|-+;’U<—’w;
The algorithm ﬁnd the path P : (s :)1§k+1, tk+1ik, 1k, . . . , 1'1, 1110, 2M: 2')
with P G Psi and ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
11(13): a(¢k+1ik) + ‘ ' ' + t1(1ii0):
(uilc — uik+1)+(uik_1 _ uik) + ‘ ‘ ‘ + (“in _ uii) z
uio — Wk“ I Ur — us I “1',
In each while iteration 'w ¢ {'L'O, . . . , ik_1} (else we get a cycle of cost 0,
violating the hypothesis (1))
Note that, with the notations in the above algorithm, we have ui :
uh + 0411.
(b) Let ﬁl- : a(P;‘Z-), Vi 6 V. By the above proof, U1, i : Lin satisfy
the system (B)
Suppose that u : (u1,...,'u,n) 73 (ﬂ1,...,ﬂn) : E.
Since us : us = O, it follows that there is 2' 75 s such that ui 75 ﬁt‘ and
Vj 6 V(Psi), j 5i z', uj : U), where Psi is the path built in (a) for U).
—/
—

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Then ui > ﬁi : ﬁn + am : M1 + am Z ui (the ﬁrst inequality holds

by the choice of 1L, the second holds since ui satisﬁes (B)).

The contradiction found shows that u : E, that is the components of u

are shortest paths costs.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
—
From the above proof it follows that for solving P2 is sufficiently to
found a solution of the system of equations (B). The corresponding
shortest paths can be obtained as in part (a) of the proof: if vve have
ul- : uk + aki then k is the vertex before i on the shortest path from
s to 2' (of cost ui ) In the algorithm that solves (B) we maintain an
array before[l..n] With entries from V U {0} With the ﬁnal meaning
beforeh'] :the vertex before z' on a shortest path from s to z'. The
vertices of this path can be found in (9(n) time by constructing the
sequence 1L, beforeﬁ], before[bef0re[i]], . . . , s. ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
Shortest paths - Solving problem P2
Remark 3 ‘
If the algorithms solving the system of equations (B) circumvent (by
the maintenance of the array before) 0-cost cycles, then the problem
P2 is solved, even the uniqueness of the solution is lost. Hence these
algorithms Will solve P2 under the hypothesis
(1’) a(C’) 2 0, for all C cycle in G. ,
Remark 4 ‘
If, in the problems P1 - P3, G is a graph and not a digraph, vve can
use the algorithms for digraphs by replacing each (undirected) edge of
G with a symmetric pair of arcs, each having the cost of the edge. Note
that this approach works only for non-negative costs of the edges (if an
edge has negative cost, then the 2-cycle formed by the two symmetric
arcs replacing the edge has negative cost, hence hypothesis (1’) is not
satisﬁed).

Graph Algorithms - Lecture 3 October 18, 2024 39/50

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Shortest paths - Solving problem P2
Remark 5
Since the sets 731-1- are ﬁnite (and non-empty), we can consider problems
similar to P1 - P3 by replacing min with max.
Remark 6
The use of the obvious relation maXIQA ac : — minm€A(—ac), by replacing
the costs aij by —aZ-J-, works only for digraphs in which, for each cycle
C’, we have a(C’) g O (in particular, this approach works for digraphs
without cycles). If the digraph has cycles, longest path problems are in
general NP - hard.

Graph Algorithms — Lecture 3 October 18, 2024 40/50

***************Ending Page***************


***************Beginning Page***************
***************page number:41**************
Exercise 1.

We say that a graph G : (V,E) is sparse if m g cn2/logn (n :

| V|, m : |E|) The reason is that we can represent the adjacency matrix

A of G using only 0(n2/ log n) memory space such that the answer to

a query "a(z',j) : 1?" could be done in 0(1) time.

Describe such a representation. /

Exercise 2.

Show that there is no ordering e1, e2, . . . , e10 of the edges of the graph

K5, such that: e10 and e1 are not adjacent and eZ- and e¢+1 are not

adjacent for each 1 g i g 9. .
—

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Exercise 3. Let G : (V,E) be a graph of order n and size m with
adjacency matrix A. From the set 0f all 2m possible orientations of all
its edges we choose one and consider the vertex-arc incidence matrix
—1, if 'u is the initial extremity of the arc e
qve : 1, if 'u is the ﬁnal extremity of the arc e .
0, if e is not incident With 'u.
Prove that A + QQT is a diagonal matrix and ﬁnd the combinatorial
interpretation of its diagonal elements.
—

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
Exercise 4. Let D = (V, E) be a digraph with V : {111,112, . . . ,vn} and
E : {e1, e2, . . . , em}. Let B : (bij) 6 Mnxm({—1,0, 1}) the incidence
matrix of D, Where

1, if ej is incident from 'ui

bij : —1, if ej is incident into 'ui .

0, otherwise
Prove that det(M) E {—1,0, 1} for every square submatrix of B (that
is, B is a totally unimodular matrix).

—

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Exercise 5. Let G : (S, T; E) be a bipartite graph with V :
SU T : {v1,v2,...,vn} and E : {e1,e2,...,em}. Let B : (bij) G
Mnxm({0, 1}) the incidence matrix of G, where

b~ _ 1, if ej is incident with vi

Z] — 0, otherwise ‘

Prove that det(M) E {—l,0, 1} for every square submatrix of B (i. e.,

B is a totally unimodular matrix). ,

Exercise 6. Let G be a graph with n vertices and m edges.

(a) Prove that if G is bipartite if and only if G doesn’t contain odd
(induced) cycles.

(b) Devise an @(n + m) time complexity algorithm for deciding if a
given graph is bipartite. (An algorithm for recognizing bipartite
graphs.) ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
Exercise 7. Let M G be the edge-vertex-edge incidence matrix of a given
graph G : (V, E), that is MG : (my-)Kigm, Where
léjén
V :{U1,’U2,...,’Un},E : {e1,e2,...,em}.
m-- _ 1 if el' is incident with Uj
Z] — O otherwise

(a) Prove that if T is a tree, then by removing from M T a column

corresponding to a given vertex we get a square non-singular

matrix.
(b) Prove that if C' is a cycle, then MC is a non-singular matrix if and

only if C' is odd. I‘

—

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Exercise 8. Let G : (V, E) be a graph With n vertices and m > 1
edges. Consider the following algorithm:
G’ <— G;
While (Elu E V(G’) such that dG/(u) < m/n) do
G’ P G’ — u;
return G’;
(a) Determine a time complexity of an efﬁcient implemenation of the
above algorithm.
(b) Prove that the returned graph, G’, cannot be a null graph.
(c) Show that any given graph contains a path of length 2 m/n
—

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
Exercise 9. The diameter of graph G is the greatest distance between
any two vertices in G. Two vertices form a diametral pair of vertices if
the distance between them equals the diameter. Show that the following
algorithm ﬁnds a diametral pair of vertices in a given tree T:
0 starting from some vertex of T, perform a bfs (Breadth First Search)
algorithm; let u be the last visited vertex by this search.
9 perform another bfs on T starting from vertex u; let v be the last
visited vertex.
9 return the pair (u, v). ,
—

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Exercise 10. Show that the DFS traversal can be used to devise an 0(n)

algorithm to ﬁnd an even cycle in a 3-regu1ar graph of order n.

Exercise 11.

(a) Show that for a bipartite graph with n vertices and m edges we
have 4m g n2.

(b) Write an @(n + m) time complexity algorithm which has to test
if a graph (with n vertices and m edges) is the complement of a
bipartite graph.

—

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
Exercise 12. Show that a graph G is bipartite if and only if every induced
subgraph H satisﬁes the inequality: 2a(H) 2 |H| ,
Exercise 13. Let G : (S, T; E) a bipartite graph and X E {5, T}. G is
called X-chain if we can order the vertices of X: 2:1, m2, . . . wk (|X| : k)
such that

NG($1) Q NGUBZ) Q Q NG($k)

(a) Show that G is S-chain if and only if is T-chain.

(b) Suppose that G (which is bipartite) has order n, dimension m,
and is represented using the adjacency lists. Describe a S-chain
recognition algorithm With @(n + m) time complexity. ,

—

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
Exercise 14. Let G be a graph; we denote by b(G) the graph obtained

from G by inserting a new vertex in the middle of every edge of G.

(a) Show that b(G) is a bipartite graph.

(b) Show that G 2 H if and only if b(G) z b(H). Using this re-
sult prove that the isomorphism testing between two graphs can be
polynomial-time reduced at the isomorphism testing between two
bipartite graphs. ,

Exercise 15. Let G a bipartite graph; prove that G is connected if and

only if it has only one bipartition with stable sets. ,

—

***************Ending Page***************

