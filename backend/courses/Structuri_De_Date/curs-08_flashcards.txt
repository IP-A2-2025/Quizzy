[{content={parts=[{text=--FlashCardSeparator--
Single
--InteriorSeparator--
What is considered an inversion in bubble sort?
--InteriorSeparator--
A pair (i, j) with i < j where a[i] > a[j]
--InteriorSeparator--
easy
--InteriorSeparator--
5
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which of the following sorting algorithms are based on comparisons?
--InteriorSeparator--
(right) Bubble Sort
(right) Insertion Sort
(wrong) Counting Sort
(wrong) Bucket Sort
--InteriorSeparator--
medium
--InteriorSeparator--
2
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the time complexity of Bubble Sort in the worst-case scenario?
--InteriorSeparator--
O(n^2)
--InteriorSeparator--
easy
--InteriorSeparator--
7
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which of the following is the principle behind Insertion Sort?
--InteriorSeparator--
(right) Assume a[0..i-1] is sorted and insert a[i] to make a[0..i] sorted.
(wrong) Repeatedly swap adjacent elements to move larger elements to the end.
(wrong) Divide the array into sub-arrays, sort them, and merge the results.
(wrong) Find the minimum element and place it at the beginning of the array.
--InteriorSeparator--
medium
--InteriorSeparator--
9
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the time complexity of Insertion Sort in the best-case scenario?
--InteriorSeparator--
O(n)
--InteriorSeparator--
easy
--InteriorSeparator--
10
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What are the approaches for selection sort?
--InteriorSeparator--
(right) Naive Selection
(right) Systematic Selection
(wrong) Divide and Conquer
(wrong) Dynamic Programming
--InteriorSeparator--
medium
--InteriorSeparator--
12
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the time complexity of Naive Selection Sort?
--InteriorSeparator--
O(n^2)
--InteriorSeparator--
easy
--InteriorSeparator--
13
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Heap Sort uses a max-heap. What property must this max-heap satisfy?
--InteriorSeparator--
(right) a[k] <= a[(k-1)/2]
(wrong) a[k] >= a[2*k+1] + a[2*k+2]
(wrong) a[k] >= a[(k+1)/2]
(wrong) a[k] <= a[2*k+1] and a[k] <= a[2*k+2]
--InteriorSeparator--
hard
--InteriorSeparator--
14
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the time complexity of Heap Sort?
--InteriorSeparator--
O(n log n)
--InteriorSeparator--
easy
--InteriorSeparator--
21
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is the core idea behind the Divide and Conquer paradigm?
--InteriorSeparator--
(right) Divide the problem into smaller subproblems.
(right) Solve the subproblems and combine the solutions.
(wrong) Iteratively improve a solution until an optimal one is found.
(wrong) Build a solution step-by-step by choosing the optimal option at each step.
--InteriorSeparator--
medium
--InteriorSeparator--
23
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the space complexity of Merge Sort?
--InteriorSeparator--
O(n)
--InteriorSeparator--
medium
--InteriorSeparator--
25
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What operations does the 'divide' step of Quick Sort perform?
--InteriorSeparator--
(right) Determine an index 'k' between 'p' and 'q'.
(right) Ensure elements before 'k' are less than or equal to a[k], and elements after 'k' are greater than or equal to a[k].
(wrong) Divide array into approximately equal sub arrays.
(wrong) Simply copies array elements to sub array structures.
--InteriorSeparator--
hard
--InteriorSeparator--
28
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In Quick Sort, what is the worst-case time complexity?
--InteriorSeparator--
O(n^2)
--InteriorSeparator--
medium
--InteriorSeparator--
33
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What can improve the efficiency of quicksort?
--InteriorSeparator--
(right) Choosing a pivot that divides the array into comparably sized subarrays
(wrong) Always selecting the first element as the pivot.
(wrong) Avoiding recursion.
(wrong) Using a linked list instead of an array.
--InteriorSeparator--
hard
--InteriorSeparator--
34
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the complexity of Counting Sort?
--InteriorSeparator--
O(k + n)
--InteriorSeparator--
medium
--InteriorSeparator--
36
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is the core principle behind Bucket Sort?
--InteriorSeparator--
(right) Elements are uniformly distributed over the interval [0, 1).
(right) Divide [0,1) into n equal subintervals.
(wrong) The keys are guaranteed to be unique integers.
(wrong) Elements must be sorted in reverse order.
--InteriorSeparator--
hard
--InteriorSeparator--
39
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the average complexity of Bucket Sort?
--InteriorSeparator--
O(n)
--InteriorSeparator--
easy
--InteriorSeparator--
40
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which sorting algorithms have a best-case time complexity of O(n)?
--InteriorSeparator--
(right) Bubble Sort
(right) Insertion Sort
(wrong) Heap Sort
(wrong) Merge Sort
--InteriorSeparator--
hard
--InteriorSeparator--
42
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
When is Merge Sort recommended?
--InteriorSeparator--
When a stable sorting method is required.
--InteriorSeparator--
medium
--InteriorSeparator--
43
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which sorting algorithm is recommended when average performance is more important than worst-case and a stable method is not needed?
--InteriorSeparator--
(right) Quick Sort
(wrong) Merge Sort
(wrong) Heap Sort
(wrong) Insertion Sort
--InteriorSeparator--
hard
--InteriorSeparator--
43
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
Which sorting algorithm could be applied when values are within a specific range of integers?
--InteriorSeparator--
Counting Sort
--InteriorSeparator--
hard
--InteriorSeparator--
44
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which sorting algorithms run in O(n log n) time in the worst case?
--InteriorSeparator--
(right) Heap Sort
(right) Merge Sort
(wrong) Quick Sort
(wrong) Insertion Sort
--InteriorSeparator--
hard
--InteriorSeparator--
42
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the initial state assumption for insertion sort?
--InteriorSeparator--
a[0..i-1] is sorted
--InteriorSeparator--
medium
--InteriorSeparator--
9
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which of the following are characteristics of QuickSort?
--InteriorSeparator--
(right) Not a stable sorting method.
(right) Has an average time complexity of O(n log n).
(wrong) Requires O(n) extra space.
(wrong) Guarantees O(n log n) time complexity in all cases.
--InteriorSeparator--
hard
--InteriorSeparator--
43
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What data structure is used in heap sort?
--InteriorSeparator--
Max-heap
--InteriorSeparator--
easy
--InteriorSeparator--
14
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is a disadvantage of using merge sort?
--InteriorSeparator--
(right) O(n) space complexity
(right) Greater constant factor than Quicksort
(wrong) Unstable sort method
(wrong) O(n^2) time complexity
--InteriorSeparator--
hard
--InteriorSeparator--
43
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What values are assumed with Bucket Sort?
--InteriorSeparator--
The values are approximately uniformly distributed.
--InteriorSeparator--
hard
--InteriorSeparator--
44
--FlashCardSeparator--
}], role=model}, finishReason=STOP, avgLogprobs=-0.1783085771690208}]