***************Beginning Page***************
***************page number:1**************
Rust programming
Course — 6
Gavnm Dragos

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
®; Agenda for today
1. OOP concepts in Rust
2. Traits
3. Super traits / inheritance
4. Special traits
5. Operators

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
L

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Rust structures have both a role of a structure and C++ class. However, there are
several differences between how a class in C++ and its equivalent in Rust are
designed,
Maybe one of the most important one, is that methods for every object are
implemented separately (and not as part ofthat object definition). This techniques
allows rust to define traits (characteristics) that can be define for every object
(including the one that are already part of the standard library and basic types),

To add a method to a class, use the impl keyword,

follow by the name ofthe class.

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
ﬁi Methods

Methods are defined with the - construct with the following format:
- [visibility] I methodiname ([pammsh e> <returnitype> {m}
- [visibility] I methud_name (self, [pummsp r> <Ieturn_type> (...}
- [visibility] I methodiname (8152", [para/"51) -> <retumitype> (...)
‘ [visibility]. methodinarne (&mut self, [pﬂrumsh ,> <retumitype> (,..)

Where:

» [params] 9 is a list of parameters (similar to the one that can be added to a
regular Rust function)

- [visibility] 9 a set of keywords that explain the visibility ofthat method

- <return_type> 9 the return type of that method

- self, &self, &mut self 9 used if the method is applying to the object. If not
prezent, the method is considered static.

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Let's see a very simple example:
Rust

value: 1;.1
\
le Mytlass -;

+11 mrqamr wm { "v'H’,VElUE +: 1; }

H gL'LLSKleF') r: 532 ( J"1¥.vﬂluE; }
'1
Fn MUM) 4

let rm obj : Nyl lasﬁvalueﬂ};

obj.nv£1);

println!(“-{ I‘ ,objgeuw:

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
®
Let's see a very simple example:
Rust
\’ cuxpm

value:

‘
getﬂ; 1 r: ( return .value; }

1—

H'7\_1HL\ 1;

printlnll“ ",',¢mget1_‘v7:

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
®
Let's see a very simple example:
Rust
\’ cuxpm

value:

‘
‘l
r’ a 1 < - +: - \
getﬂ; 1 r: ( return .value; }
pmnnnu ,uvmgetx_ 1/:

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Let's see a very simple example:

Rust cu

"W" W‘ m.‘ ‘ tn” mus-W
Value: ‘a t

‘ W ‘1 h -

3M 1W1 ‘ m value;
m JHUKHH ~1>\-; A's/31“! <: 1, ; i"“1w"“j‘¢‘r1 ‘(31?e*:1' " V ‘
w ayHS-va 7, -:_' z HtA/alue; " . ‘Ht Ht‘ ‘ """Jt ‘ MUG’ ‘

‘in W _“ I, 3mm uHmU y'
""' ‘ . 7' . vmmw :m;
m m ob] Z HwJQL'Waluezej; H 7
objmalue : 5. M ITE'IBT,’ 5'
pmntlnH“{1“,nbj,qrt\'v\z “MM mt" ,ULWQ.‘ H.

1 ‘

OB]: Notice that methods in Rust that receive a &selfare translated as const

methods in C++ (see method get)

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
lfthe &5e|f/ &mut self or self are omitted when defining an object method, that
method is considered to be static. In this example, method printiname is static and
can only be access via the class/struct name specifier,

Rust Cw

*"""f1'“"'“_mi ‘ ‘111;; 147,135; '

‘ w “e it‘. w L11.’

' i r i 1m, value,

{H W m J Wm ‘WW i

vi‘,"'l.1"122;i7 m? Hal'ai i; ‘ "a": M“ "Wm MW“ W

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
I
Statlc Methods

lfyou want to calla static method from a regular method you can use either "Self"
(with capital "5"] as a type, or the name of the type you are implementing a
method for.
m M

w Hm "mum-h

‘ pmyha t:
w 1r WU t;
pvlanM“ V. mug; .mlueu
V Ha)!‘ t 1
7 Walueﬂul‘
,7‘, t t H h

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
'
Statlc Methods
lfyou want to call a static method from a regular method you can use either "Self"
(with capital "5"] as a type, or the name of the type you are implementing a
method for.
m mm-

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
There are also no static data members in Rust‘ However, we can use global variable
to achieve a similar result as a static data member in C++. When we are going to
talk about visibility, we will show how this global variables can be hidden.
Rust Cw
LiuLL '~l,llJL; > V v7 ,
HM: m, ill" Wild-V, 1
i Wt»
I’ V , r ,. _ , m value;
H‘ WWW,‘ ‘l will m S'L'Lli i ;.,: _
‘ iii-m’ l myiclassixi l l" mud“ ,1 Z m;
‘ r mm wmmri
‘H mum J‘ l"‘,[171:73‘1‘11:ii:‘l2lr V
W Marian" pun-m “mm ,ll,rrlIiElI (‘UM i'i;
pmmii-iii“ii“,ii,r =.:r.:;gwi ix; l
l

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
'
Statlc data members
There are also no static data members in Rust‘ However, we can use global variable
to achieve a similar result as a static data member in C++. When we are going to
talk about visibility, we will show how this global variables can be hidden.
Rust c”
-

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
I
Statlc data members
As a general rule, it is not recommended to create a global [mutable) variable to be
used as a static field for an abject‘ However, since some designed patters (such as
Singleton) might require such an approach this is allowed but must be done in such
a way that access to that variable is limited [so that we reduce the chance of an
undefined behavior).
If such a construct is used without the - keyword, the code will not compile.
Rust
valu?‘ r 'va mxims i: 1‘
m i,1i”’-: e 1e; i W a; mutihl! mm
mi l l l , iii i - +: 11 ; illiﬂHiE ‘ll-IliLhHi. .u ms YILE.‘~1L\ LIU.E UHJElAHEJ
{w i». i r'Ptu'n w la ; i "mm"

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
g; Calllng methods
Another interesting thing is that (semantically) Rust has “self” (in different forms)
as the first parameter for methods that are associated/implemented for a structr
This implies that a method is a little bit different than what we know from C++. In
C++ a method can only be called by the actual object, in Rust a method can be
called in two different ways:

- abjectmetholearaml,Param1,..Paramnl,where object is of type —
or

' ObjectTypezzmethod ([reference]obiect, Paramr Paramw Paramn)
Where [reference refers to the fact that the first parameter should reflect its
definition ( I, or -)

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Let's see an example:
RuSl‘
‘u'tr'ltialﬁ l l value Z 10
mmw 1 “value : .valuel: “we: 20
uvmml l
w 7 lvaluezlﬂln
J; : want-2:20};
umunl .HHl,
~mw ﬁts“.
Notice that we have called print_a method in two different ways !

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
® Calllng methods
Also, there is no difference between a regular function that is designed to take the
first parameter a reference or an object of type “A”, or a similar method
implemented for type “A”. In this example, we showcase this behavior. Method call
receives a pointer to a function that has a first parameter of type &mut A and the
second parameter of type u32. Both “g” and ”A::f” qualify for this type of functions.
Rust

“Mir r ‘t i»,iiwnr\iriii i1. ul 5

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Rust does not have a constructor-like method similar to what C++ has. This is
because any struct has a clear initialization way Where each field MUST BE
INITIALIZED. However, constructors can be simulated via static methods:
Rust Cw
mu» 'lyClJEl l ill will u 1
value: lJl ‘u ll,‘
l m value,
“M mm“ i l'lvltlﬂffvﬂll't ll valuei.'l ll’
'nclu-s'; 1' value .al l: m“ “WW l
l ' ll'vlilahi llal;
‘I pm new “=::.1\n“ ,wsmluei,
m ma’ w; I; l
lit m : ‘JigklaiiviIlir'iat'i'llal‘
l

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
®
Constructors
Rust does not have a constructor-like method similar to what C++ has. This is
because any struct has a clear initialization way Where each field MUST BE
INITIALIZED. However, constructors can be simulated via static methods:
Rust CNr
wearer qt; i7; l

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
Constructors
Rust does not have a constructor-like method similar to what C++ has. This is
because any struct has a clear initialization way where each field MUST BE
INITIALIZED. However, constructors can be simulated via static methods:
Rust c”
push m
wwm 1i: m l mov ecx,10 mov dword ptr' [rsu],ecx
rutuwi r value’ .wl i: call Myclassncreate —> MW @BXAWOM DU‘ [rip]
i mov dword pt!‘ [m] ,eax pep w
Pet

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Constructors
Rust does not have a constructor-like method similar to what C++ has. This is
because any struct has a clear initialization way Where each field MUST BE
INITIALIZED. However, constructors can be simulated via static methods:
Rust CNr
—

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
Constructors
Rust also have a special type call Self that refers to the current type (not object)‘ It
is often useful when returning an object of that type.
Rust Rust
value‘ ,1 value: ‘L
VHLLHH -; “1w; .t ,L, MW” , value: .‘t r.
1‘ t
minr'v 1 hunt r
u : ’ILV>JLL\18‘, : :.u'ut1bsllv]\;
w-mtn“ .ualuet, w-mu t “ u .valuet.

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Constructors
Let's try a more complex case (where the class has multiple members).
Rust
value: ,l
data‘ [ :39]
return l value: .11, data: [MSG] .1;
“mm l l
m 7 :.rlr:w1,2‘l:
prsml" “,m.\/;.1ue;,

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
Constructors
Let's try a more complex case (where the class has multiple members).
RUST
lea mum]
mov emu
call MyClass: :new

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Let's try a more complex case (where the class has multlple members).
Rust MW byte w [MPQFHJED
MW mm r 1
mm mm" m, [Wm] ‘h 1
mov dworﬂ In" [rSD'KhLE-Ix
mnv qwnrd w [rSIHJGMHTX
mnv Ward DU‘ [rsD'SEer-(X
mov award utr [r5w52h],ea><
m the m [vsp'ﬁYhLdl
m "hmwm
_‘_ P . , MW mum
‘WM’ ‘ 1 ' ‘ ‘7" ‘ (all meme‘
return a value: .11, data: [MSW 1; MW mm": W [gym]
; m “Lawn m [mpaan]
mov Faxrllhm'd Dtr [rwexh]
MW mm pt, {mum ‘ N“ 1
mnv rnxqwm-d Dtr- [rswblh]
mnv word utr #004me
m mmm nu [werAh]
mov Word utr- {FIX'B(M>H1><
MW \‘ﬂmenrd an [mum] <
mnv Ward DU‘ [wouuhln'dx
mnv mX,dwurd DU‘ [rsleAM
m mom w WHMWX
mov deurd utr [rsP'SEM
W Wu w [mpzammx

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
Let's try a more complex case (where the class has multiple members).
mm ( (1855
value: , I
data‘ [ 36] Dubhc
) ink VDIUL',
im 1 , dalaléldl‘
P m (v Ml‘ P )7) < mm vom a Y ,, w , m U l ,‘,
mm l value: m, ‘ ;
data: [d;36] value ' ‘l,
1,, \ dale/(WM),
) <~>wnﬁ .sxzeoﬂ la,
l
l my
F” O { void w ‘.1
let m : I2 (1,2), (&,1,n,,
print‘( ()“m-valuE>, (56d v , value‘;
l l

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
g; Constructors
In reality, there is no real difference on how Rust constructs an object (as opposite
on how C++ does it)‘ Both ofthem receive the address where the actual object is
located and construct it there‘

Usually, Rust uses names like:
- newL“)
~ fromlﬂ.)
‘ with_...(...)
to describe a constructor However, any name can be used.
OBS: from is part ofa trait and while it is used ta construct an abject it is usually
associated with that trait‘

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
Keep in mind that defining a function similar to a constructor does not imply than an
object can not be created in different ways, In the next example, we create an object
of type MyCiass using two different methods (::create(r.,) and structure initialization).
Rust (via create met/rad) Rust (w structure miria/imiun)
mu» @1115; l :tr .t: must; r

value: i; value. 13:,
w-wi i"‘,ii€'i'- i i rii i'iiiia'wi

@1115; s: value .al i: H.111; i value: .nl i:

i i
m W ~ii i tn “mi-iii i

w m Z -i,i.,ia:;;mwwuw | 1w rii1‘~i‘,‘tia::i\.iallle:1\7,‘$

tliliitii ,i ,lIi.\/31ull'i; wmzr 'i , rlLvalue'H

—

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
g; Constructors
One advantage of construction an object like this, is that we can return an error when
trying to construct an object, while using the constructor concept in C++ makes this
task more complicated,

Let's assume that we have an object (of type Student). For each student we have a
name and a grade 9 but the grade should be between 1 and 10c

Using a constructor (like in C++) you can not return an error (so in theory every object
is valid). In Rust, we can return an Option<> or a Result<> and only if the result is valid
(- for Option or .for Result) we obtain an instance of a specific type.

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
Let's see an example:
1 7
Wm < 0mm
EM" ~ 514mm
7 “a” sZ:Some1Student(grade: 10, name "Dragos" n
)mpl \
F" MUM, R ,~~\',@\'\~ 17> ( >4
‘v Hm, v H 1w», m 1“ H, w NH‘ m 1- u\“\n,(<*1!/W <
‘v H \ ‘Wm {gradez ,A MZMJ, nerve, : l~ ‘waw,
v
PCtAr'v Mm,
m 0 (
let 51 V i (M ‘>1w5)?
19¢ 51 V : 1 w ' New;
PrinthIW‘ (HUM),
pmnl]n\{‘ q >y,<2,\,
)

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
g; Constructors
Keep in mind that static functions are possible in C++ as well‘ This means that the
same technique can be used there (create an object via a static function). The only
difference is if we need to allocate a class in the heap or if we need to create an array,
Since C++ builds a class directly in the allocated memory, there is a need of a
constructor method that can be called automatically when an object is created.
Rust works by creating a temporary object first and then assigned it to the actual
object (transfer the ownership). Because of this, any kind of static function will work
as we will need to provide that temporary object first, and then the assignment is
performed by Rust. /

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
Obviously, there is no implicit default constructor in Rust. However, it is a common
practice to name it new, while other constructors that imply creating from a specific
type prefer the prefix from (as a derivation from the trait From)‘
Rust
e-l LALl r'i‘,l:1J>‘2 l

value: n1, m1:MvClass(value:O)
» mZIMyClass ( value‘ 10}
'lutl HMLYSE l

l" “Mr » 1mm l il),£l:i£:\‘va1ue:0: r

l' lrulll jPZlml. till‘ H llVlILUL' ~i ‘lyrllra-sivalua. 11',‘ l
i- mm r

v-r ml , lltFlESEivrierui'lI

Lat ml e llWILJEL'I’l"JViLJPIl_1Gl1

pruritlrili il"l ' ,mlji;

wwmrvr ‘.7; ,mzr;

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
®
Functlonal update syntax

The usage of I operator is also called functional update syntax‘ It implies that you
can use this to call another initialization method (that will be called first) followed
by you own changes. Let's see some example:

Rust

X 1,
_ . l ~<: 5i y’ 3, name “ablll l i

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
®
Functlonal update syntax
The usage of I operator is also called functional ugdate syntax‘ It implies that you
can use this to call another initialization method (that will be called first) followed
by you own changes. Let's see some example:
Rust
it , W i
t
_ nine t v
it‘. 7. i ‘not,’ Hm; ii i
111m i i
t ‘1: ‘
name: "will.
_ my,“ i

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
®
Functlonal update syntax

The usage of I operator is also called functional ugdate syntax‘ It implies that you
can use this to call another initialization method (that will be called first) followed
by you own changes. Let's see some example:
Rust

MM‘ i

\‘

1 l
I will i

Lilliitlnli'hb]: in,

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
I
Functlonal update syntax
The I operator has to be the last from the declaration.
Rust
1 t
1 Qwai-ggnmnmj?" arm m W Wm
1m ‘V ; 1 t .‘n. ,v H.‘ Mm- ; 1
Mt“: V v
Livilntln‘ "Gin: \ \‘l

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
I
Functlonal update syntax
When using functional update syntax, you can also use another object [of the same
type) as your base:
RUE!
1' , \
mm, Q ‘
hm“; :7 \ e 1 4 x 11, y 1U, name 1 \
j} j """u obj:TEst(x:5,y:5,name:"xyz"},
‘we; "mm baseITesl ( x. 5, y s, name. “"y

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
However, there are a cou -|e of litfalls that we need to take into consideration:
Output
, r
5mm \ r ' 0bj:Test(x: 12m; 5, name: "abd'k
X v baseﬂesux 111v S,narne “123";
y v
r "we ‘ Notice tha this
imp; r snipped works as
m (‘r ;V> \, (X .,,y HAW (r W»: expected!
‘M u r
let mut base V I {5);
base x V 121,
m obj r r
Mm» t
.base
enintlnlx' r0)‘ r v‘ r1» , ob],base),

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
However, there are a cou -|e of litfalls that we need to take into consideration:
r r "mummy: hm qr Mum m.‘ W, h.“
5mm r Wm K 11 n
x , r
y v 12 1 1e! uh] I res! (
name , n r rim“,
j 1; r r “.8!
, r , i7 v.1 .m m .1 mm here
.' \ ~~~~ value hurrnuld her! amu- var-nil muv!
M U ( ‘ l I: I: Iv Iv Iv d
V . WY . Z ml WU. mm mm ecause mm. .5 (we 5m"; , u K m m
i131‘??? - h >, MM m my W
list nhj r (
X m‘
.base
brimlnzr ~ (0)‘ r w r1“ , 0mm“),

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
g; Functlonal update syntax

Let's analyze a little bit better what the next piece of code implies:

Steps:

1, Initialize obj with all fields that are provided (in our case —) “I"]

2. Copy/Move all elements from base that are not needed by the current
initialization (in our case, since we alread initialized "I", we will assign "I" and
”-']. For ” ” everything is 0k, but "i' will be moved as it does not
contain the trait.

3. As such, tr in to print base after this step is invalid [as it has a partially moved
member —yi).

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Now the code works, but notice that we don't rint base.name that was moved !!!
Output
, \
Sm,“ ‘ ( ' obj:Test(x: 10, v: Smame: "123“ ), base x1123, base.y:5
x ,
y ,
name ,
imu <
M1“ t» \' (X‘1,y~1,rmmb mw»;
‘m u \
let mut base V I {5);
base x V 121,
m m r <
X 1m‘
.base
bﬁntlnlx" (0)‘ \ v‘ , (1‘ ' ,1) , ub],base.x, base.y),

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
g; Method overloading
Rust does not support — (in the sense that there can not be two
methods with the same name as part ofthe same implementation of one class). We
emphasize the word: "some implementation ofone class" as methods with the same
name are allowed with traits [we will discuss about this later) or with
generics/templates.
One major advantage here is - (if you have multiple functions with the same
name, its is not always clear how parameters must be converted to match one of the
functions). If you only have one function with a specific name, this issue will NOT be
encountered anymore. /

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Let's see an example:
Struct k
value: .
)
impl (
m (mm self, vl: > ( —
selﬂvalue+7 \1) wmmml 6“me WWW‘ wvrh m? m
} WW rs s ,
x
Fn (amt self, M: , ,2: > { 3 M WWW W, v1 ‘21H
selfA/aluew \,1+v2; s \ \ W ‘ v1.
v H ,
> \ \i' lewus dcﬂmnuﬂ a‘ add Mr:
) a \ J in aaawmu sci‘, v1 111, v1 111) (
m 0 4 EH > W1 W1,
let m 7 (value:€}; \ \fmmhmdwmm
m. (16);
m. (12,20),
prlntlnl[“{} ,rmvallle);
I‘

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
/ Method overloadlng
The solution in this case Is to change the name ofthose two methods:
struct (
valuP: ,
\
1mm 4 om m
fn (Smut self, v1’ ) ( p
selfvaluew t1, 40
kn (mm self, \1: J w. > <
selfvvaluek vlwz:
}
)
‘H (J (
let mut m 7 (valuew),
m. [16]]
m. (16,22);
println|( Q ,m.value),
\

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
g; Destructors
Rust does not have a destructor method (in the sense of a specific method with the
same name as the class) as C++ does. However, there is a special trait called - that
can be used to define a function with a similar scopes
Furthermore, the lifetime of one object or its transformation can be controlled via
methods that receive self as an argument (notice that it is self and not &self or &mut
self)‘

This technique transfers the ownership and as a result one can convert that object into
another one, or it can drop it.
We will discuss more about destructors when we talk about traits.

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
®
Let's see an example:
Rust
k Destruzt object \
‘I End program
Jezhur'. Wk“ Y, J‘
pr]an‘\_"Déstru:t chinct 1w,
mm :1
m Z mamas},
“mm-m "My;
pr‘1nf1n!\"End program" ):

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Let's see an example:
Rust
VHlMlEI ,
J'wruJ. mu‘ J -;
Wrnwmy-Dpsmtt whim m, “@3111 >1“ M11 m
" \
m : {value m, n \ m MW M
pr‘1nf1n!\"m,value Z “,HhvaluE‘; \ ‘ “ ‘ ’ in“ > m1 m < m W
x x
‘ nu» rm, {unzHun ma», ulme'uhxp m m! "ex-Av!" >2“ “mm muv!’ m
\ m M H mud“ ;
x

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
Consummg an object
Let's see an example where we convert one object into another (by converting we
refer to a transfer of ownership between object fields). This is often known as
consuming one object and producing another one !
Rust
| . r
j“ 11 V l W ‘ W V r Student:Studenﬂmatn 10.5"ng 2,r\ame worm";
“if: “:‘f“~*"‘** ‘ ‘was’ ‘m "3"”: mm“ ‘ Average:smtiemmreugergrade ‘llYJIWE “ther
“r , m. .
n A“ H“ err r. my... r‘. Mrnrnm... 1
WW1...‘ mm r .mdnkrnwg1».n1 A. nanw r Hm;
‘r 5 r wrwmm 16.9ng1iih s. mm .n- W1. In.“ r ‘11;,
yrrl'r'hv‘ r r r r..1
.r 53 Z >1 M .‘1'7r..7.rnr~r-.7.r WM r,
Drlriln‘ _- ‘>7 1,5“

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
. Consuming an object
Let's see an example where we convert one object into another (by converting we
refer to a transfer of ownership between object fields)‘ This is often known as
consuming one object and producing another one !

R“! erruribllill WM. U- mm or» 3
1 11 i unnumt' smugm : 1:’) is);

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
E; Consuming an object
There are several conventions that are usually used in Rust when writing a method
that consumes/converts an object:

1. use — if you want to consume current type and obtained a new object
by transferring ownership. This type of method receives a I as a first argument.
r in ; It
erl iii i_jill:. 1'.» l.. l
2. use to_<type> if you want to create a new object and keep the original object
(usually this means making a copy/clone of some of the data members of the
original object). This type of method receives a - as a first argument.
iiil l’i [Evn ‘7- i,..i,‘

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
E; Consuming an object
There are several conventions that are usually used in Rust when writing a method
that consumes/converts an object:

3. use _ if you want to convert an immutable reference of t e “A” to an
immutable reference of type “B”, This type of method receives a a as a first
argument, Usually this means that type “A” has a data member of type "B".

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
/ Consummg an object
Let's see how these converslon will look like for our Student structure
m M
1m .
mam-
in M r
mat r
W1“ l Arr» \ r
Em“ Sm "m r m, “51m, J, Ownership of"Student: name"istransferred
in rm» q r
W, M, m, , ‘Q1, Wm“ L Ampy/clone 0f“5tudem::name“ is made
"m 5m hm

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
Implementing methods (static and non-static) is not limited to structures, it works
similar for enums. To access the enum value, use the sel ke word
Wm \

m1 >, Output
‘ “M l mm ‘rue
mp] 1 vismt false

Fri Mselfi > '

'ml'l SCltt
Mil’) r> r WW mil-‘i
i 1M‘ itlliii my,»

} ,
l
r" f? 1

letx: mum

m y 7 F'satll s},

prlrrtll'lll' v (l ,xv (i),

pmmu‘ m (i ,yv 1m
r

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
/ En u ms
The same logic could have been obtained via an ”-” statement, "-”
statement or "matches!" macro, instead of usin a match‘

m (Eiselty) t
retnrr n let amnzseu < true ) E15? ( False )
Fn Mselh w ' )
\H't SCH t
Mu") r> < M» W Hm“)
i 1w wwv mse,»
‘n mm)» t
-' let ‘wt-(7) 1 mm

Output tm m;

x\>ml true 1

“mm” ) Mm False;

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
/ En u ms
Static methods can also be implemented for an enum [they are in particular useful
when creatin enum ob'ects .

z /
cmlm l Output
Mt l‘
l» ( ‘ |nt[]O),Fluat[15]
lTlDl \
Fn 1 a H ) > l
all,“ l'v'ﬂxlmh
.»
Fn (£14: 17> {
‘ctrn I Floati IlJtlr
l
l
M L> 1
let x V 11m,
12¢ y 7 11 m;
pmmz; (m) (y H )1
l

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
7
Traits
L

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
g; Traits
In Rust a trait is a set of characteristics that an object has, Formally, a trait is very
similar to an interface, However, from a semantic point of view, it is closer to a C++
abstract class,

From the semantic point of view, a trait is a list of methods that can be
implemented for an existing type (IMPORTANT: not necessarily a newly created
type, but also types that are already deﬁned)‘
To implement a trait for an existing
structure/enum, use the impl keyword.

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
Let's see a simple example:
mm <
1 X Output
bait ( 5
m (am 52m,
m (Faun mm
imp; m- <
m (1mm self! j self x471, 1
Fr‘ Klimt 521“, 3 Selfvx :1, i
‘m 17 <
Jet mut m = (x EM
m. mm mm u:
m. H:
Przrvtlnh U ‘m XM

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
Let's see a simple example:

Rust Cw

w» ,m v } "v. Wrw-mvWWWFM ;
a J‘ W ‘

, ‘ Hm ,M \'\:\\:B‘

Us» 1W?‘Huynnwww 1 “ “U ‘L ""“ Z U‘
" “""JW' H“ ‘+7., Y>‘,\'1'<:' “H w Inf!"uruh'u"H'Frrnn'uf ;
WNW.‘ ‘Hm

> W ‘

' . V m

J ‘V 1Mfmmwurwgut \ v ~41 1 H ‘<1 1‘ H H U W M ‘ M ‘
r‘ in‘; MM 3m :2M X471» 1 gm 71,121“ '1, 1 l‘
a mrvmur w 1 up :1‘; .7 " “ " " "" ' ' “ "'
V , W m 7 WA H H Z 2.
Mm um 1m ‘:m 1m ‘= H WW.‘ 1W.“ 1w‘-
m.‘1€"\ ‘I 5 ' ' ' ' ' '
v meH m 4‘ “din "
‘ ‘ ' ‘ \\vr?’1“ “<1“_uv..

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
®
Let's see a simple example:
RMSI
MW Mm w [m],3
m mm
(m m“ 1mm ‘m
153 mm
‘ , H 1:, an ﬁrst )mplw m
1e“ pix-[M] m a
- ' - ' - ' ' [an ﬁrst implSB mt
ME“ " m mm]
[an ‘1m Wm a“

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
® Traits
When implementing a trait, we can use the type Self to refer to the type where we
implement the trait. This allows to define a trait and be more generic [not needing t0
specify the type of some parameters).
Rim
fl‘ l 179155,, l
_ 7r V; 1gb: Max»; in?» 55:1‘ '1 AUDI‘
in‘ T'l'vvnrr r“ l>‘,‘lrv
r Wr'rmriw m ‘v’
‘l m2 = MLM ‘lulu
plﬁtliW r ii r_ V 1: “Leggy ‘Win

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
/ Tra Its
However, a virtual method (in C++) is interestin from the polymorphic point of view.
This behavior can be modeled Rust usin, the ke word:

Output
mm 4 )
5mm k y chm
tram ( in (mm > e , \ @3555
17W] For‘ ~
r" “Wm q R < » ~ )
Mp1 m j
m (mew > Q ( v v' \ )
'r" <0‘ , Kdyn \ <
puntlmt' n m. 1>~,,
)
m n (
15-: chi a 7 (1,
h“ ohJJ') * (.M
\Eobjiah
’&ohj7h\,;
v

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
/ Tra Its
However, a virtual method (in C++) is interestin, from the polymorphic point of view.
This behavior can be modeled Rust usin, the ke word:

Output
mm 4 r
5W“ K 3 (Hank
trelt ( in (melt) > 54 . ‘r UassB
)mpl For‘ ~
r" New, e> R < ‘r r r
Mp1 For j
; v 1; > r t
; " “e ‘ ‘L ( ‘ ’ Noticethe usage or as the type ofobj, This
F'v f0‘ , My" r r translates that obj ls a reference to a type that
> pmunw r} > 1H, implementsthetraithmL
e" w r
lei obi a e t",
hr‘ Unjih 7 tn
‘mum
'iwbjibl,
>

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
®
However, a virtual method (in C++) is interestin from the polymorphic point of view.
This behavior can be modeied Rust using the keyword:
(1255A
CiassB
mime! (0 (hé DDJPU
mimel in a Vii!"
1,5 “rams!
m rdx,i1mp1$<hrstz (1155A, ﬁrst “my mm; mmwmmm
(an ﬁrsr *prlntiname
v ii mums H H 1“ “WWW!
1.5 “Mime (rm, rm NW mm <57FFeswsnAan)!
i’ 7' VJ M‘ L» ‘Y {all hrst'»DmMJ-vvic

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
®
Traits
However, a virtual method (in C++) is interestin from the polymorphic point of view.
This behavior can be modeied Rust using the i keyword:
(1255A
CiaSSB
m “pm
,r H U, “Mi r r r W Mm W [selﬂﬂ'cx
mm we": a" [WDUIIMX
r mov raxmwurd PV‘ [vfutnﬂrv]
‘ (a!) mx

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
® Traits
This means that the size of an object that implements some traits does not change in
Rust. “ClassA” in both Rust and C++ has one member (“x”) that has 4 bytes‘ However,
in C++ due to the virtual method get_name, an instance of ClassA also contains a
pointer to a vfptr (and as such a size of 8 (for 32 bytes) or 12/16 for 64 bytes).
Rust w c++ m
, . Hun i i,
will i in’ a,‘ .- ‘,1: Mimi.“ .;
. m .t,
7M .1“, w the; ; We
m 12¢ we sjélti 7:11:77, i emu 11w vi" 'w-zt PM‘ wei J2 ;
prl'itlii i i std :ivien:::1:e It: ‘:VQIIQW i‘ [W]F'lll'Fl“,IVI?ii'li:l?ZZ-I-ll‘

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
I
Tra Its
Furthermore, the same logic applies for arrays [or for any kind of structure/enum that
uses a structure that implements a trait that define a virtual method‘
RUST
r
“[1555A“

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
So |et’s anal ze and see how the classic 0| mor-hism exam-Ia works in Rust.
sxrurt k
nvnm] cows! (\er II‘ VI,
)
svuzt Wm - Out u!
,V [\rde
snuct Mm , Rwanye
> Wu»; QM m?‘ Hcm'ruls \ \ ,, \ ‘ ‘» Tm?“
MM mm“ ;
wtm <9st {m ‘w meﬂﬂde A ‘ ‘ ,;
w
vmd ‘ 4
' ‘A,
[A] w
m 1 m, L,‘
m m a,‘
' X5 , \ * I‘
' ,

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
®; Traits
Let’s recreate the same example for polymorphism in Rust.
We will do this in 3 steps:
1, Write the -trait and implement it for -, - and -
2, Write initialization methods for -, - and -
3, Discuss how -function should be written in order to illustrate the
polymorphism,

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
® Traits
Step 1: Write the Figure trait and implement it for Circle, Rectangle and Triangle
Rim
r‘ HEW‘ 1
in my“: g All 7- my.
in in.» -; =_ w‘ v r r- ru'l
n r 'iilngl' 1 ,1 r 1‘ y PM r. h. ii rm r
r, w ljigldl u: l1?1,37.y:715_;3j
:17,‘ re Pi‘ m’) r
run M ll'i V lbw; ‘r r;
M Flgue l r mung“.
hi kt we will A ‘as.’ r r V r n
in rm,‘ (i MN» 1
will M 5:vlll'll1"ll r ‘r r

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
® Traits
Step 2: Write initialization methods for Circle, Rectangle and Triangle
Rim
w in h‘ i
in izvd ‘V C1 ‘:1: i
in M MVP-Luigi: r
Fifiiiiléixﬂhy'mmulﬂihh Zﬂ'i
w r, NM‘ 1
in r-JV new» i
Tr'ler'ul-zix [m1,z]‘»,r=rv:~,1rv:~"r

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
I
Tra Its
Step 3: Discuss how main function should be written in order to illustrate the
polymorphism.
:r >1.‘ 21".} 1, l mm 5mm VLEVUHQJ,
ft“ W‘ ‘ ' erwmr "amulet we.
J" i WW‘ W “UMP/M“
. l
luv l i u Mir lv'rl 1 ill iw ‘lUUlV'lilugra wwn V _
The fact is that we can not create an array with traits similar to how we do it in C++
(Rust assumes that the first item is the type of array and as such for this example, the
code will not compile).

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
I
Tra Its
Step 3: Discuss how main function should be written in order to illustrate the
polymorphism.
RIIS!
Hm Hm 1, [m
_ ' ‘ ‘ " “ mangle
Now the code works and output a similar result as the code from C++;

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
®; Tra its
Step 3: Discuss how -function should be written in order to illustrate the
polymorphism,
[u] ptrtu a - object
ptr to vtable oi trait Figure for circle object
[1] plrll) a - ublecl
ptr to vtable oi trait Figure for Rectangle object
[Z] plrtu a - object
ptr to vtable oi trait Figure forTriangle object
Let's see how "figure" is organized in memory. Notice that each element in the array
consists out of two pointers (one towards the data [a Circle struct, a Rectangle struc
or a Triangle struct) and the second one towards the vtable for trait Figure that was
implemented for Circle, Rectangle and Triangle.

***************Ending Page***************


***************Beginning Page***************
***************page number:76**************
I

Tra its

Step 3: Discuss how main function should be written in order to illustrate the

polymorphism.

RIIS!

lilill“ in i ‘j Z
I'm“. l 3E l 1m him-i ldm FAEuvwrll l
; Z "lit giltr ‘it ‘Fri, Lirrrryg “r5, ii,r 51=Li y,yr
Keep in mind that we can not use a "an Figure type” outside of a box as we can not
know at compile time the size of an object that implements Figure trait.

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
a Tra Its
Step 3: Discuss how main function should be written in order to illustrate the
polymorphism.

Rust
Figuri rel-m 1mm r: ml H‘ [m
mg ngrm. W'rr r Tnarrgle
J 1min“ 1 .F)g.;>tJau-:r M;
The same can be done with a vector (instead of an array) with similar results.

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
The previous code can be adjusted so that we can returned a boxed trait from a
functions Let's see how get_a_figure looks like in assembly:
Rust
H thing.‘ Mr 1:1‘ r 1,, mm .
rm‘ :1’? ‘ q "3?":w ‘mm-p1‘; WM , ; [er
,‘ " ‘ " ‘ Rectangle
H MW‘ 1 Trrarrg\e
w w raw-s V .2‘: Pp‘;- 1. Flyr'e M r.
i n‘ z r
Flgur-l yrhnw .rr,‘ mm
‘ Mg figumwrywr 1,
J 1mm 1 .6ng mm‘

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
m whmmpﬂachm]
. . {an hm-.(mk .W
The preVIous code can be adjusted so that w- M in? // 5m of 2 mm
function‘ Let's see how get_a_figure looks Ii \ m, wlnmm mmangwmm
mm mm W [nHJoinmle],v~a><
Rust MD mm;mmjmunm
M, a UL.‘ ML ‘V .
' *1; 7; a ‘ M‘ M‘ M 1 navmjnmzjmﬂnm=
w W 1 _1 : ‘ g w ‘ ‘ M “WWW p0‘ [muumw]
W» " H m mimm p" [tempistzckiuwzls]
'\ mov qwnrd ptr [rzx].rd><
HJVH‘ \ 1 mow cdxmwnrd pn- [temp SQDKK (IFUCJI
7 ‘m V =. M ‘. W mm w [w-Joﬂrcn 1],“,
‘ n‘ 2 ‘. mcv mm w [r25 natummrlnx
‘ W | M ~ . ‘M M W m mnmpnmm Flguvs) Mime]
‘ ‘ ' . . ‘ W mm Dtr [resvvtablﬁlﬂax
\ W REYURNjRDijNUION
‘g Mud/‘H; _
J mum , '12P? WM
; Rmmjmmﬂmmm
; W “WWW W [mdamjmw]
W mmwd W [reswtablej
m v'ﬁvaAGh
DOD raw
m

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
Tra Its
The previous code can be adjusted so that we can returned a boxed trait from a
functions Let's see how get_a_figure looks like in assembly:
Rust 0+ (upproxlmanan)
m r r ;
1:)" minivan;
.rrq. Hm ,r r;
W 7w v
.ptrLtQJJata 7‘ :
.ptr‘7t':rivtahls 7 wrmzzmq
rm. n r

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
'

Tra Its

Keep in mind that returning a boxed (dynamic) type is different than returning an

implementation of a trait . The next code will not compile as Rust will assume that all

return branches must return the same thing (a circle] just like the first return branch

does.

Rust

l ‘n i in mil fur-l 1 1m V er r W- r
‘ 15 i mm Recurrilennewth
l »»»»»»»»»»»»»»»» 1,,lttld §.rl[¢ (.rtrl t .nlnd §.rl[¢ thtsn=r.

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
® Tra Its
If we return the exact same type from all branches ofthe getiaiﬁgure function, the
code compiles‘
Rust
r" r, numb w‘ V. Mr w
; we new r‘
I‘ a, M‘ r‘
w a Z Er-Liaihirvnmh
J )vrterr‘: 1 v3 let rzner 1‘
Let's see what happens when we create the "a" variable.

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
g Tra Its
If we return the exact same type from all branches ofthe getiaiﬁgure function, the
code compiles‘

Rust
Ina rouhr
[an hrs! wing“
Let's see what happens when we create the "a" variable.

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
If we return the exact same type from all branches ofthe —function, the
code compiles‘ m mm
W mm DU’ rmdresuurm
mu ma
W r V. m lnxilsjmriliku
r r t‘ ; mov WNW W [erratum
. ‘ ‘ {an (1rd: m
‘ ’ ‘ 1m,» REYURMJRDMJIINKYIDM
‘ ‘r Inx_ls_mr_zim:
1 MOV v~<x,nword Ptr [addressinfia]
{an (1rd: m
IEWRNJRUHJHNETIDN:
W WWW W Mame”),
add was»
m /
Let's see what happens when we create the “a” variable.

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
I Tralts
If we return the exact same type from all branches ofthe —function, the
code compiles‘

Rvsl 0+ (uppmximalron)
Warmth‘ r7». r .M'">"7|t:r'|r‘\,\'\1‘r|f‘Ht’ 1.“;
rrr\::u1 .r r-ﬁm
Mm »:M,r r‘ Z H.
r'rjt'm'r'r .‘w r‘ return‘
.r )rrtlrrH“ ".1 ;-:t \EHE} 1‘ return;
I ‘ l [ r .
(“Al r. r Wm ‘g.
F > - Z ~ r r.

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
a Tra Its
If we return the exact same type from all branches ofthe getiaifigure function, the
code compiles‘

Rust Rust

i ii tit n Nil‘ i L'"?li,1ih.>iilv

J )vitenli l v3 lei lEllEl i‘ ,i )iitlii‘ ll .a :et l:ll2 l‘
As such —) these two pieces of code are similar (in terms on how the compiler
generates code). The assembly code (for x64) is actually identical for both cases (even
if from the semantic point of view, “a” has a different type).

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
I
Tra Its
Methods from a trait can have a default implementation (much like a virtual method
from C++). This means that if that method is not overridden, the default implementation
will be used. To imlement a trait without override its method, use:
<traitiname> <type> { } i
Keep in mind that this is possible only if all method from the trait have a default
implementation !
Rust
New, 1H2 A l 7- 5 4 "Default new?“ l i
u m l

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
®
Tra Its

Atrait can have both default (implemented methods) and unimplemented method and
they can use one each other.
Rust

yn' "r “W n" ‘ t t

mm "when" fv-cm ‘ NU, mm‘

Hm‘ 1 _

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
a Tra Its
What's different in Rust in terms of how a trait work, is that a fruit can be implemented
for other types as well (even if they are not defined in that program 9 etg. for example a
system t‘lpel- Rust
In this case, we createa new trait, called it y W H H H A, z
BitCount that can be implemented for ‘H Wt": t, “HM l t r w 1
tvpe u32- ill 11L iiiiiii T méil‘

value U ‘l
As a result, every variable or constant of 3:: l 53:: ' limp l l‘
type u32 will have a function called mm
compute_bit_count that counts how
many bitswithvaluelavalue has. j‘ r,“ y
Dr) lillll‘ I; V 7 l ,x.:»nmrt2 List :Jll l" it:

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
Notice that you have to implement this trait for every type in order to work‘ The
following code will not compile as i32 does not implement the trait‘
twin i @521‘; V) , jigsaw m Wm mm mp M (m w W m m W
} 77> Vchmn ~S 17 u
mm w < l
m (mu; V> i
Jet M value Z "self, i
let Mt count 7 OuBZ, V help 1mm; mm mm can any be used 1r m m“ is implemented m m “m
count r count * 1m“: :7; ,7, j’ "’ ‘ ‘
mm Z mm ,' Z, 1 i m“ “mum
l l ’
returi count,
>
m u l
printjnl( H i; ll U 4wa 1;),
prlﬂtlﬂll [7v Vi 1711‘ r U ,zmz 1;),

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
® Traits
Another interesting example is the following. There is no method in class String that
can be used to set/change the existing string with a different one. You can obviously
run a .clear() followed by a .pushistr(..t) to do this, but you can also do it using traits ©
RUSI
'r w minim,’ r
‘nine-n r;
,rw Wt w n .r r,
tn rm‘ 1
it w S V :n-W 1m‘ H r;
piliilii“ l5‘.

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Tra Its

A trait can also have constants defined as part of the tralt. That constant should be
seen as a static variable (it does not af'fect in any way the size of the structure that
implements that trait).
Rust

amount: l5, Output

MIG

M . r n n» w l ""100

r r l H HWH r‘! V 198. slleoORONIJ

1r Hr Wt mllr r r 41‘
M {.1 View, M =n~ m Iétltwnt :En, .Zne: 15;‘ :tnjmm V .VM, 1

prurll'ﬂr r ‘vanuuHLl.

"ha-UIQH mwum

[Hotl'ﬂr r ‘lemma:

rr'lntl'r“ r ll‘.3td::rn>:rr w w = ml m,

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
I
Tra Its
A constant value defined in a trait does not necessarily need to be instantiated as part
of the trait definition. However, that constant needs to be initialized in implementation
Rust
“1.1M, 1n 'rzu' WE. “1.11111 1 1115.5,» WW

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
g Tra Its
A constant value defined in a trait does not necessarily need to be instantiated as part
of the trait definition. However, that constant needs to be initialize in implementation.
Output
m:D
(onst DIFAULT , m:1234
slzeofRON:4
(om DEFAULT V 1224,

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
g; Tra its
Similarto constant values, a trait can have types defined within the trait, And just like
constant values, the actual type of a defined type within a trait can be set up at the
trait or implementation levels
Let's analyze the following problem:

' We need to convert from both Celsius and Fahrenheit to Kelvin

' Let's also consider that Celsius is represented as an i32, while Fahrenheit is stored in
an f32 value‘

' To do this, we will define two types (Celsius and Fahrenheit) and a trait [that describe
how the conversion to Kelvin is performed.

~ We will also define a third type (Kelvin) that just returns its value. We will use it r a
different discussion.

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
® Traits
Step 1: Define structures for Celsius, Fahrenheit and Kelvin as well as the conversion
trait.
Rust
\mlm‘ t,
:iri ii :diiiri its’!
_ rim +51,
" i i ‘i hi, i
Mm r;
Notice that trait TemperatureConverter has an inner type [ConversionOutput) that i
not yet defined !

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
® Tralts

Step 2: Implement TemperatureConverter for both Celsius, Fahrenheit and Kelvin types.
Rust
Hi mm WW mm in My

i H WW will‘ ,

-i , 7 in‘: i V 1n :st “Jimmy Manama 4 173: »
Hi mm WW mm in lli'rln'i‘ .;

t “minimuiwi 7 in’.

-i , 7 r. We i. ‘V in w mummy l ‘H ism V 34.6‘ 1.3‘ 4 12.15, »
Hi MW WW mm in -‘ l, .;

i H H, H. WW,‘ , in.

-i , 7,. We‘. ‘V in w mummy ‘imam;
Notice that we have different formulas for those three types, and that we define
ConversionOutput for all implementations [i32 for Celsius and f32 for Fahrenheit and
Kelvin].

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
. Tra Its
Step 3: Write a -function that showcase how the trait works‘
FMS!
Umfljn kélflllil ‘Milling; r. ‘ ‘v URN?’ ." ‘1!,wa ‘ v CelsmAZ-M : mummy?)
y.v1mMH'Wdhrrnhmh 1‘ Z mm, ‘ ' ‘a M, . H >‘ ‘ m. Fahrenhwlmu 51 : KEN-"1111 105571
x 1 ; ‘(we 59.: ;>‘ _ Kemmso 1; : Neh/mLSO 2)
p‘)ntl\‘\"lelvinl > ~31‘,ij ,v, \ value, MU» HM)
OBS: This technique is sfmi/ur to the usage oftemplutes/geherfcsv We wi/l however
discuss about templates/generics and the/‘r usage with structs/enums and traits in
another course.

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
I
Tra Its
Keep in mind that using this technique (an inner type that is defined in the
implementation ofthe trait) will not allow any kind of polymorphism as there is no
similar definition for the trait methods.
RUST
i l ‘ll r l
'iivi-ii l Halli! Maj ll
1"
m 1r‘ “all '
y . ismpsrsiurEEUhysrisr i mu,i be ,EECt-rsa
l
y vvvvvvvvvvvvvvvvvvvv hF,p VFF,,“ ‘hF ‘Vrn,,,‘Fd ‘pr
i iampavaiuiarunraiiai rair@i=,ui~Hipui V rips

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
I
Tra Its
Keep in mind that even if We modify the way We define the Box (by adding an explicit
request for the ConversionOutput type, all elements from the iist MUST have the same
ConversionOutputType !
RUST
mm i i
: M,‘ 1 mite: mm n.
i‘
wi- W‘ iii-i Uth vi‘ m n: i;
| 1m “mm rcsolvin: (nuns as
| “wimummw (WMMMM 012

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
I
Tra Its

Now lt works‘ Keep in mind that both Kelvin and Fahrenheit type have the same type
for the ConversionOutput U32).
RIIS!

Hull V_ = ‘lid 150,2

llllll H ,n ll:
OBS: While this technique is working, it is not usually usedfor polymorphism {as it
implies to make sure that types that have a super'troit have the some internal type —
thus making the concept of internal type less relevant as it can be hardcoded}.

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
'
Traits
A trait can also contain static methods, that can have a default behavior or not, and
in the last case, those methods should be implemented for types that implement
the trait, Obviously, since a static method in a trait is not linked to an instance of the
type that implements that trait, things like polymorphism can not be achieved with
these methods.

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
A structure/enum can implement mu\tip|e traits What happens if there are two traits
thatdeﬁneamethodwiththesamename? —
WWW] manna 111110111 1m 1" mu
> mm 1, 22 21
mm ( w @591‘, 1:111 ; 1> . v n r1-1nr1n'l'\y',x mums“,
(mt ( m @591‘, m1»; 7 > , g “““‘m\lnﬂlu [mm mum
m1.” < 11m ;
M “1111.11 =1 1, 1mm m 1 N 1M 11.11 “.111
mp1 m '1 1w m tynr [1m “
m (aseu, ,111; :1 r> { 77> “Wm N 11 s
MW 5m value ~ @112;
, 11 f" “mum. 11111 1111 > 121(
> m. mm“. ,1“ 1.11m m M m1 m m m“ Wm
)mp] m 4 m- m W 11W
m (KseH, “<11, 11 V> 1; » 5rc\mzn.r5.lé_y
) MW 5&1‘ value / “>112; 15 n1 twmmw, 1.11! 1221 I 132 r
> W WWW" m assonavd mm" m- mm" 11
M (H 1 m1 (WHY
Jet X Z “3112116); Z’ Wu" ‘ U ‘Mlltttllliiil"
pr)ntln‘1 U ,x 1m, ".1" 11mm“. m Wm" 1mm" W mm“. ,1
) 11 “7111mm Q ,Yraltﬂiith/IKILX, DH:

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
I
Tra Its
The solution is to specifically explain Rust that, it needs to call a function defined from
a specific trait. The format for this call is:
type-name trait-name>:: (&0b1, Paraml, Paraml, Param")
Where is on object of type that implements
Rust
, wall»: l 1
wwtmn“ cantata ,5“;
_ cr'lntl'iii“ rm 1w; ,5‘ =

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
I
Tra Its
The solution is to specifically explain Rust that, it needs to call a function defined from
a specific trait. The format for this call is:
type-name trait-name>:: (&0b1, Paraml, Paraml, Param")
Where is on object of type that implements
Rust
-|
Rust
within“ ,st is i‘
With-w Hun/1;» ,s l,

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
Super traits

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
g; Super tralts
Rust does not have an inheritance model, similar to what other languages have
where a type can be derived from another type and as such inherits all of its parent
properties, data members and methods,
However, Rust allows a certain type of inheritance by providing the concept of a
super trait. If “A” is a super trait for “B” , then any structure or enum that
implements "B" must also implement “A”
The format is similar w the wav inheritance is
done in c++ (name ofthe trait, followed by ':' and
the name of the supertraitjr /

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
®
Let's see an example:
)7qu
‘ ~‘* ‘ ' “‘ d“ ‘ ‘ \ ‘ mm" Mm? V m WWW”; rw Dana
Hm“
1 ehlde

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
Let's see an example:
(Pan g
Fn {\ﬁselF) '> 8‘ , OUKPLIK
:rm k maxispeed : 140
m \mm, V> ‘ name: Dame
>
mm H
m1 For 1
Fr‘ (22,146) V> ~ "pm" MB‘ ‘
3
mp1 m {
in 11mm V> a j 12b ‘n w A , j
i
w i: 1
m a Z 3),
pmntlnh’ v , w U , d. m,
pmmu W n , a 17>,
>

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
® Super tralts

Any trait derived from another trait has access to all of the methods defined in the
super trait‘ Similar, via Self type, it can access any constant defined in the super trait
and instantiated in the struct or current trait.
Rust

i i V rm mm i.

1i Vii a.“ =. w V a.“

a WW gm”; w 1 ri-wlwwi i l i i i ,ifﬂwt may i‘,\'l'21il§i\ SPEIDH 1

m» HEN swim: in: V mi

rim Mia ~= w Mimi; ‘ i w, ;v
:l Mt l‘ l i

Vat d 7 [lain ‘l,

it; int :l'IEﬂi i;

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
g Super tralts
Multile inheritance is also ossible as a trait can be a su -er trait for mutti -|e traits‘
(ran: 1

in 156?] '> E r
‘ Output
mm (
r" (“in V» , Name :Dava
: Speed1140
traxt : t; CotoIIBtue
fri “itself! '> Q J
an“: .;>
mu m r m rm”; V> 1 m i ;>
mp1 m gr" mien; V> § i V r i w
)mpl for (m {kselfji V> Q r rm i 1
M 1i, i
m (1 7 w‘
pmnl]n'( . r; ‘a, my
prlntln'( it‘ 4:) ,a. r);
printlnlr' ~ ii) ,a. m,

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
®
Super tralts
Multiple inheritance is also possible as a trait can be a super trait for multiple traits‘
Rust

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
A similar code in C++ would look \ike this‘

M nae,“ V> E vu'Lua] (1mm (her - 1; Z u‘

f [1355 pulzli: L

tr‘ 1;" Him d vmual unsigned int (1 Z a,
’ , , 5N pub)“ 1
twin > {mm V> Q . vmual (oust um < ;) Z g‘
,mm .> class publk ,pubhc '
m 1 mp * ( > ‘mum turwt (Mr- ' {; ovum-16L‘ My.)
Mp) m , ) WW3] un<1gnéd lnl 17 mmrmds 4m)
“1:1 ‘m ‘ ( ' Vlftual (oust char < j‘, overrule <. .\
m 11 < )3 W

m n 7 ~>, "“m H (

pmmn'( . n ‘a, my I‘ V H‘

prlrvtln'( r {1) ,a. g)‘, y H‘ 3; ‘£1;
a pmm1m~~ x) ,d. U” 9:7‘ 71’. (:1):

>

***************Ending Page***************


***************Beginning Page***************
***************page number:114**************
At the same time, multiple traits can be super trait for another trait. Semantically
this is explained in the following way:
trait <r|ame>: SuperTruitl + Super"Truit_, + SuperTrait” {...}

This is in particular useful when using templates/generics as it can be used to eXpiall'l certain type of
llrnitations (erg. the type used In a genenc must implement Trait1 , TraitZ, l,
This format is often referred as trait combos.

Rust

malt when : l'l)'SLALiEVTV’3iL + l"'l\,‘591l(ilnfléll)‘SLlUEPTV'éUL + l'lyiililiﬂiuper'li'aiL l

l

1mm Hylrelt inr HullaSS l

***************Ending Page***************

***************Beginning Page***************
***************page number:115**************
g Super tralts
The same examle 9 but with trait combos.
(ran: 1
M 156?] '> E ,
‘ Output
trait i
m (3“15/ V» a , Nam :Da“
: appeaﬂm
mm ~ < compame
{n Mself‘, '> ,
~n-mt .;>
mu m < m (mew) V> 1 m w ;>
mp1 m {Fn mien; V> § k V t 1 x
)mpl for (m {kselfi V> Q ( pm y 1
m n, <
m d 7 ~m
pmnl]n'( . U ‘a, my
prlntln'( m 4:) ,a. ()j,
primlnu ~ U ,a. m,

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
g Super traits
The same examle 9 but with trait combos.
Veh\c\e Color
I Dacia

***************Ending Page***************

***************Beginning Page***************
***************page number:117**************
Special Traits

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
g; SpeCIal Tralts
Rust has some special traits that can be used to improve certain operations or how
some types behave:
- Traits that reflect certain properties (Copy, Clone, Debug, etc)
- Traits that reflects operators (addition, substraction, etc)
- Traits that reflects comparations between types
- Traits that reflect casts and/or conversions between types
These traits can be overridden. In some cases, Rust can automatically implement
some special traits via — attribute. /

***************Ending Page***************

***************Beginning Page***************
***************page number:119**************
E; Special Traits
To automatically tell Rust that it needs to implement a trait for a specific class, use
— attribute. The general format is:

#[derive(Trait1, Traitz, Traitnl]
List of these traits (that are also called derivable traits):
—m_
CODY Suppﬂﬂ fwﬁuﬂv Semantics
Clone Add SIIWWK (u (lune an 0mm
Debug Debugmiwmatiunfwall ohm
Hash Pwvid: a way iv wmvuie a hash fur a mierencl (Compiler controlled]
Dehult Default valuefuran Ublec!
Eu Cnmparailun WWW! l Equal)
Partilliﬂ Cumparatlun WWW‘ l Equal and not Equal)
0rd Szi an Obieﬂ to be mmvarabl: (can be ordered]
Pani-lom Satan nbimm be Partial wmvarabl: (can be urdered]

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
g; Speual Tralts (Copy & Clone)
Copy trait indicates "Copy semantics”er a specify trait. Clone is a super trait for
Copy trait (so any implementation of Copy trait implies Clone traits as well).
Notice that Copy trait has no defined method, This is because this trait implies
byte-wise copy for any object upon assignment. Clone imply Sized (a trait that
indicates that the size ofthe object that has this trait, must be known at compile
time). This is to be expected if Copy implies a byteewise copy (a memcpy). /

***************Ending Page***************

***************Beginning Page***************
***************page number:121**************
Special Traits (Copy & Clone)
Clone trait, however, can be implemented
RIIS!

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
® SpeCIal Tralts (Copy & Clone)
Clone trait, however, can be implemented
Rust
1| t t . t
:1 w Mn ut-x
MW Ur
1
‘ TH." i mm w > value 1 m
1e: v 7 we; t,‘ t;
1c’ 1 7 x;
pr “rm-M w t :x x value‘ v mluv, 1 uh“: ,
OBS: NDIICE that the default Implementation (obtained via #[derlve(C0p}/, Clans” uses byte W/se tapy
far bath clone and assignment.

***************Ending Page***************

***************Beginning Page***************
***************page number:123**************
. Speual Tralts (Copy & Clone)
A newly create struct can implement Copy trait only if all of its fields implement
Copy trait.

Rust
l "Within rn- my w, W i. ‘Mr-Wm W mt M.
MW , ‘ T :n'r m“ l». 1 w
name 1 l .y Marilyntmn
l
mil l r v H V H v .l namezﬂrlﬂg
' ‘l “'11”? 1- “7"”! 117 "‘ H‘ "'l l 1m) nun a“) M! lmplcmn! up»

.' l
In tnls case, one of tne fields (name) does not Implement Copy trait and as such the entlre structure
can not implemented it.

***************Ending Page***************

***************Beginning Page***************
***************page number:124**************
g; SpeCIal Traits (Dlsplay & Debug)
Rust has two traits (Display and Debug) that should be used to display an object‘
Both Debug and Display traits have the same methods, however there are some
differences between them:
- -trait can be used with #[derive(”.)], - can't
' - is designed for user-facing, while - is merely a developer way of

validating information about an object‘

- Debug requires a special format I

***************Ending Page***************

***************Beginning Page***************
***************page number:125**************
a SpeCIal Traits (Dlsplay & Debug)
Let's see some examples:
Rust
penny-ii i i ix‘;
Notice that it is fairly easy to print any kind of object if we implement (via
#[derive(Debug)] )the Debug trait for it. Rust will create a default implementation
for this trait that will print each field from that structure.

***************Ending Page***************

***************Beginning Page***************
***************page number:126**************
SpeCIal Tralts (Dlsplay & Debug)
Let's see some examples:
Rust
“NHL valu! 1}‘
Wm, w" M

***************Ending Page***************

***************Beginning Page***************
***************page number:127**************
SpeCIal Tralts (Dlsplay & Debug)
Let's see some examples:
Rust
RUE!
m- n w 1 “HyHumher :7 “my ‘value : m“; a

***************Ending Page***************

***************Beginning Page***************
***************page number:128**************
g; Specral Tralts (Default)
-trait is used to describe a default initialization value for an object‘ lt works
like a static (constructor method that creates an object. All basic types implement
that trait. Furthermore, trait can be defined via #[derive(.,.)],

Besides basic types, more than 150 types in Rust implement default‘
Usage:

***************Ending Page***************

***************Beginning Page***************
***************page number:129**************
. -
Spec1a| Tralts (Default)
Let's see some examples:
Rust
‘ 1 100
1 11111-1 1 1 o
} 1 1.111.111 11111 1 l]
‘ 111111-11 1
Z 11111111111
1111111111" ualuew
11171117111111 11
p1-‘11t11-1111 1

***************Ending Page***************

***************Beginning Page***************
***************page number:130**************
‘ I
SpeCIal Tralts (Default)
Default trait can be automatically implemented via #[deriveiaJ] attribute. All ofthe
structure members MUST implement Default trait as well‘

W‘ i MyNumbcr lvaluz-‘D,float unﬂagfalsci
um: _ MvNumbEr[Value:0,flozt U.0,flag False)
mm. .
ma

= , 1 mPulh l‘
,vr mm“ t.
w mm“ t.

***************Ending Page***************

***************Beginning Page***************
***************page number:131**************
. . .
SpeCIal Tralts (Default)
Default trait can be automatically implemented via #[deriveiaJ] attribute. All ofthe
structure members MUST implement Default trait as well‘
Rust
l enmle.““ Wm" mm ku'hnmvn-mmr-FnH ram." v' m “what;
1 1» i My‘ Wu"Hm-mm”

“we _ i m m“ Default 15M! implemented m

mat; . l Hystmnmmnumnaun

mg ,

mzrra

pr “Hr-ll“ t.

***************Ending Page***************

***************Beginning Page***************
***************page number:132**************
® SpeCIal Tralts (Default)

When #[derive(.n)] attribute is used to automatically implement the Default trait

for an enum, you MUST also specify the default variant (to do this add #[default]

before the e default variant in the enum)i

Rusz

| l 5rd .dcffmlt, M
Fed‘
Mum

81W.
hm»

l,’ “a. w l ;
w >1 a wry-l mm» if
ivy-ml “it l it‘.

***************Ending Page***************

***************Beginning Page***************
***************page number:133**************
You can also overwrite some default value and keep the rest ofthem by using the
following syntax —when constructing an object (this is in fact
another usage of functional update syntax in Rust):
,mm .\ Output
X‘ ~ x:MyStruct(x:U,\/:lese, z 0.0, name: ""l
Z; ,' y: MyStructlx 10,y false,z 0'0, name: W‘)
Hm ZIMyStructlx u, y: true,Z:OG, name "10“)
é" u <
let x 7 i l"
letyi {X 1a,. iii,
let z : WW; w . m y mew 1 (‘in
printlnll‘ (>)‘,><),
punk-ii l >l d,»
pmum (v) ‘1;,
i

***************Ending Page***************

***************Beginning Page***************
***************page number:134**************
g; Speual Tralts (Eq and PartlalEq)
I and -traits are used to describe if how to check the equality or
difference between two object. PartialEq is the super trait of Eq.

Notice that "I" (noteequall method has a default implementation. This mean that
normally, a type that implements this trait only needs to overwrite the I method.
The “I' is useful for types (e.g. floating values) that have special cases (such as
NaN) where different values (in term of bit comparation) might have the same
interpretation.

***************Ending Page***************

***************Beginning Page***************
***************page number:135**************
SpeCIal Tralts (Eq and PartlaIEq)

Let's see a simple example on how to use PartialEq:
RUSI

wlun R

1 ‘value :: "k “value
I M} ‘Ni Wilma‘ 18};

> ‘V: l'value: 193,"

H Iwmwwwz an v dv- my» "w.

***************Ending Page***************

***************Beginning Page***************
***************page number:136**************
® SpeCIal Tralts (Eq and PartlaIEq)
PartialEq and Eq traits can be automatically implemented via #[derive(..,)] attribute.
Keep in mind that PartiuIEq is a super trait of Eq and as such if you derive from Eq
you must derive from PuniaIEq as well‘ All of the members from that structure
MUST implement PartialEq and/or Eq.
_ value 3'
:w miwi i
s", ‘1 = l',vn~lwajue:1\3l.
sat v 7 le'viisilvalue: lﬁlt
'A' ~ l/ 1
r-mmr r it ‘r r‘,

***************Ending Page***************

***************Beginning Page***************
***************page number:137**************
SpeCIal Tralts (Eq and PartlaIEq)
- and I traits can be automatically implemented via #[derive(..,)] attribute.
Keep in mind that PartiuIEq is a super trait of Eq and as such if you derive from Eq
you must derive from PuniaIEq as well‘ All of the members from that structure
MUST implement PartialEq and/Oor Eq4
Rust
I’ -\ l Wldertnsipirltiliklll
val“? , l ~ l WM Vlilduﬁfuuipmvwluzrvud
extra l
WW: lualue' 1e‘ em i mm: m ii»
7 {valuez 1v?‘ extra l field, 1n ll‘
r-r-w-wa'». rm ,y w- cmmls i-w,

***************Ending Page***************

***************Beginning Page***************
***************page number:138**************
®
SpeCIal Tralts (Ord and PartlaIOrd)
- and traits describe a way to compare two ob‘ects‘ - is a
supertrait of and PartialEq isasuper trait 0f—
Rust [Panic/0rd mm definition] Rust (Ordering)
wtwmm . ‘ ‘v: i 1 7- v , [qnl V 0,
WM", r 1v
Mm.“ rm‘ n ‘W w‘ \_ ‘mm m, H
‘ 1%; ‘w W 5. ‘J .;
“twin J§,¢1;;7mew, Hm‘; WWW” M
‘ \fm ,\Vu n '1 .;
"mm-1» ,,.»\.1JH,M>W_ 'nru'whv\-d|,.v.‘\
1 i
mmwu ‘mm; Furw't'tr", SvaHEPEnt-tlr' \ :Wm Z i
1 ‘ 1 a

***************Ending Page***************

***************Beginning Page***************
***************page number:139**************
g SpeCIal Tralts (0rd and PartlaIOrd)
As PartialEq is a super trait of - “eq” and “ne” methods are inherited from
Partialqu 0rd trait also implements method like min, max and clamp.

We trait l <Self> f
Fri (Kielf, n i"l Eselfl > v
r" hm, rm gem e> mr W Sm ,
T (self, st er‘, :: l
Fri (self, "llH: Self] > SelF where SElFI ,
r
‘ {self ,r 7
fn (self, m- self, rm Self‘, e> self where self: l
i ﬂasrrtllui'r <7 mm,
Else lr self > ll» < He)
_ Elf-r ' self ‘

***************Ending Page***************

***************Beginning Page***************
***************page number:140**************
Speual Tralts (Ord and PartialOrd)
Let's see an example to understand how max, min and clamp methods work.
[WWW "Hahn Z ., SmaXIZ) :5
,W "i "Sminllﬂi r Winn. 5m|n(10l =5
when‘ ‘-5.¢taripw.-:~,i Z ".5 um m. , sclampleI5
mwm "s..:1iwm.4r : 1-H.‘ 1.4m Silampl7,9):7
l s clampllA) :4
.clamp(...) method keeps a value within an interval. If it is lower than its lower
bound, the value returned will the lower bound of the interval. If it is greater than
the upper bound, the value return will be the upper bound of the interval.
Otherwise, the value will remained unchanged.

***************Ending Page***************

***************Beginning Page***************
***************page number:141**************
g SpeCIal Tralts (0rd and PartlaIOrd)
Let's see a simple example that illustrates how to manually implement PartialOrd.
w ~44 ‘my, l
5mm l value: j» Output
Jmpl m l .
Fn use“, w‘ 5.521;; > -' selfvvalue W "'l'l‘l‘.v€luE l Yls blggerthanx
>
Amp] Fur <
in {Eselh “l U new V> < > {
J selﬁvzluemt invalue l \‘etrr Z/mEl Hireetarl, l
F Selﬁvaluewtu'rwalue ( \‘chrr Sn/Vl II "l~:l,, ‘
"mm Wm; ‘Wu,
)
>
m l‘, 1
let x V (value 15"’
Int y ' lvalut‘ m»,
.v W 1
prlﬂtlﬂl: JL l l l ,t ‘,l
>
l

***************Ending Page***************

***************Beginning Page***************
***************page number:142**************
SpeCIal Tralts (0rd and PartlaIOrd)
When #[derive(m)] attribute is used to automatically implement the PartialOrd,
keep in mind that the automatic logic is to compare each variable in the order they
were added in the structure.
Rust
1e M‘ i i
i
if ' cwrw = SomelLessl
' CMPlX,1]=Somcchssl
l CMP(x,t] : SomelGreater)
a i i1 m, i; m. mu h
Z i .1,1u,'._"2\3.v3 m All
[Tyrlnl "(litVlKvyl : .t'ii‘2'il {myrrh i i;
prin‘lnl "(l'tplmzl : w“ in ‘in it.
Way-w "mu-Al 1 W- ‘.1 imrll
alluvial-[lipinu Z an,“ n, W a

***************Ending Page***************

***************Beginning Page***************
***************page number:143**************
g; Speual Tralts (Drop)
Rust does not have a destructor (in a traditional, descriptive, manually defined C++
way). However, there is a trait called -that serves a similar purpose (it contains
a method that is being called when the scope of an object ends)‘

While in most cases, you don't really need to implement this trait (as Rust will
automatically destroy object), there are some scenarios (egi when managing an
external resource, a socket, etc) when this trait might be required.

Drop can not be automatically implemented via #[derive(...)] attribute.

OBS: Keep in mind that Rust will not allow you to cull .dropl) explicitly.

***************Ending Page***************

***************Beginning Page***************
***************page number:144**************
Let's see an example:
Rust
‘ \nrver mm scope Wm end ngm now \
\v m \ , Druppmg (‘1:20)
F"1"»1"““["'UF‘P1"‘E L a". =, Mam mock scope wm end ngm now‘
‘ ‘ Dropp\ng1v:10)
‘ V W EH ,
mum “Inner Marl‘ :mpe mll and ngm mw z

***************Ending Page***************

***************Beginning Page***************
***************page number:145**************
I ‘
Speual Tralts (Drop)
As previously stated, explicit destructor calls (via -) method are not allowed.
Rust
, w-mw l "WWW w: l", ‘v “ l 17"“)
OBS: Ifullowed, these culls could lead to the wrong behavior of some objects (e.g. if
the destructor closes some handles) if the object is being used after the call to
.dr0p().

***************Ending Page***************

***************Beginning Page***************
***************page number:146**************
® Speual Tralts (Drop)
The order .dropl) method is called is also different how C++ is doing. First it is called
for the main object, then for every field from that object in the order of the
declaration.
Rust
Mi lift‘ l v
time m: w. 1 a: the; t; £11418 l Dropping MyStruct
:1 Dropplng ClassB
W‘ tw, in til-=1
‘WNW .7 i i phylum l‘ i is l‘ .l
in‘ r w Fir min 1
WNW-i“. ii,” nllrliWi i i i‘ m:

***************Ending Page***************

***************Beginning Page***************
***************page number:147**************
I ‘
Speual Tralts (Drop)
Another observation is that -trait can not be implemented for object that have
Copy semantics. This is because object that implement -trait are normally
copied (via a memcpy method) and as such memory deallocation can be handled
automatically‘
Rust
> l in“, “at allnupi a“ (,ups “,(h instll (“is

***************Ending Page***************

***************Beginning Page***************
***************page number:148**************
I ‘
Speual Tralts (Drop)
Another observation is that implementing Drop trait for a struct will disable the
partial move ability. Let's analyze the following example:
“5' M
rim:
pr‘) mini ">1 w.
r
Notice that moves the value of field name from structure Test.
But this is a partial move as the structure Test (through its member ”><”) is still
available (we can actually print t.><).

***************Ending Page***************

***************Beginning Page***************
***************page number:149**************
I ‘
Speual Tralts (Drop)
Now let's implement Drop trait for the same structure. We will notice that the
same example does not work anymore (meaning that you can not move individual
fields from a structure anymore — as the new Drop implementation implies the
entire structure is being moved)‘
Rust WWW»; ‘WW M. a nur .1; ma lw l W h WNW,“ rhr- my new
l Hit MW, mum r ml»: rue a,“ :nw; t mm‘ no»,
[W'J'i'lnl "x: v‘ u

***************Ending Page***************

***************Beginning Page***************
***************page number:150**************
g; Specral Tralts (Slzed)
-trait is a special trait that indicates that current type has a know size at
compile time‘
This purpose is controlled by the compiler. Vou cand not implicitly implement it but
it is very useful for bounds (in generics) where this trait might be re uired. |t is also
possible to relax the bounds that request a Sized object by adding i in front of it
(-l. This removes the bound for an object to be Sized. /

***************Ending Page***************


***************Beginning Page***************
***************page number:151**************
Spec1a| Tralts (Slzed)
Explicit implementation of- trait is not allowed:
RUSK
l
€ ‘ Viv,vvvvvvvvv,vv,vvvvvv ,mp, n, 2,_Fn nu‘ 2,,nan

***************Ending Page***************

***************Beginning Page***************
***************page number:152**************
Spec1a| Tralts (Slzed)
Notice that even if Sized can be a super trait for another trait, that trait can not be
used to instantiate a dynamic object.
Rust
1 ~ grtrpnru,rgvbvll
r 5 m, BM,“ m- V 8.. m‘; m.
H11‘ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:153**************
g; Speual Tralts (Deref and DerefMut)
- and — traits are used to explicit dereferencing 0 erations an equivalent
to operator*/operator-> from C++). This mechanism is called .
If a type I implements Deref (with Target type set to type I) then:
- .can be coerced to I
- ‘implicitly implements all methods from I
OBS: Deref and DerefMut simulate the concept of inheritance (in the sense that
methods and data memberfrom another type (e.g. parent class) are accessible
via the child object.

***************Ending Page***************

***************Beginning Page***************
***************page number:154**************
g SpeCIal Tralts (Deref and DerefMut)
Let's see an example:
amp-n

use stduwsl \' - '>,
mm < X , y 2 From B: X=lU, v=1, From A: 3:0
druzl {h ‘a )
Jmp] :Fn 117>11b (x:2,y0),aD)])
impl Fur‘ i
\
mp1 m g

Fn (84mm self) > Smut Selﬁz ( Mmut selﬂb )
"v (T a

Jet mut a V > U?

(Kmut EL

prlnthan)‘ >4)‘ ,4) m,‘ w) ‘ a X, =1 y, d ﬂy‘

3

***************Ending Page***************

***************Beginning Page***************
***************page number:155**************
g Speual Traits (Deref and DerefMut)
Let's see an example:
amp-n
From B: x=10, y=1, From A: a=0
Mill For‘ f
1W" * i
l
"A" type does "m have any or
ﬁelds. However, due m the Deref
implementation, you can automatically
awess fields and from ﬁeld of
type A
V
l

***************Ending Page***************

***************Beginning Page***************
***************page number:156**************
g Speual Tralts (Deref and DerefMut)
Let's see an example:
amp-n
From B: FIG, y=1, From A: a:0
Jmp] ‘or (
Fr‘ (Smut Self) > Mrmt Selﬁi ( Amt selﬂb )
’ Due m the 0“ng lmplementatlon,
you can automatically obtain a mutable
reference w ﬁeld ﬁeld oftypeA
a x 7 10, V

***************Ending Page***************

***************Beginning Page***************
***************page number:157**************
g Speual Tralts (Deref and DerefMut)
Let's see an example:

amp-n

From B: x=10, y=1, From A: a=0

m r» RM > 1 ~ y v v, ; Notice that increment_y expects a mutable reference

to an object of type a. However, it can be called with

a mutable reference oftype A that can he coerced

‘Mt a)‘ due re to a mutable reference of type BY

***************Ending Page***************

***************Beginning Page***************
***************page number:158**************
g; Spec1a| Traits (From and Into)
-and .traits are used to perform value-to-value conversion‘
It is recommended to avoid implemented Into but rather implement From. Implementing
From will trigger the creation of Into as well due to the blanket implementation in the
Standard library‘ -

***************Ending Page***************

***************Beginning Page***************
***************page number:159**************
. .
SpeCIal Tralts (From and Into)
Let's see an example:
M” ; M

***************Ending Page***************

***************Beginning Page***************
***************page number:160**************
Special Traits (From and Into)
Let's see an example:
Rust ‘ H 1 v _

***************Ending Page***************

***************Beginning Page***************
***************page number:161**************
g; Spec1a| Traits (From and Into)
-and .traits also have a try version (TryFrom and Trylntoj.
The difference from the From and Into forms is that these traits return a Result (allowing
someone to validate if something can be converted into another object or not).

***************Ending Page***************

***************Beginning Page***************
***************page number:162**************
a SpeCIal Tralts (AsRef and AsMut)
AsRef and AslVlut traits are used to perform cheap reference-to-reference conversion.
Keep in mind that similar result can be obtained if using From or Into traits (but
implemented over/for a reference or mutable reference).
Rust (AsRe/ trait deﬁnition) Rust (AsMut mm deﬁnition)
Rust also has two very similar traits (Borrow and BorrowMut) that resembles in terms of
definition with AsRef and AsMut.
Rust (Bormw mm deﬁnition) Rust (Borranut trait definition)

***************Ending Page***************

***************Beginning Page***************
***************page number:163**************
g SpeCIal Tralts (AsRef and AsMut)
Let's see an example:
/ ‘ ompm
mm “ \ i ~ Tesux 20 L20
Mal < v For i
‘n (Mm r, R <
>
i
mul < > For i
‘n (W W, V, W <
>
>
Fn (7 5
Int mut a ' (X m,"
m Um KnuL Z a. i)‘
let airef E 7 a. {)3
Pr)nt1n!(‘(17"n'\‘, a, a PEP,’
>

***************Ending Page***************

***************Beginning Page***************
***************page number:164**************
g SpeCIal Tralts (AsRef and AsMut)
Let's see an example (this time using borrow/borrowimut):
ompm
use stdztbormw :g , \,,
Test(x 20 L20
( )

mm <

X
>
m1 < > For (

Fr‘ \Qselﬁ > K4 ( \‘v‘m'r Séelﬁx, }
)
)np] Q > m <

Fn (Mut Sen) V> mt k mm» Emu! Semx; )
in 4: -'

m m a r <X w

M U.“ KnuL Z a. u‘

QJM Z 12,

let airef E 7 a. {)3

Pr)"t1ﬂ!<‘(l7"ﬂvr,a,a reFL
>

***************Ending Page***************

***************Beginning Page***************
***************page number:165**************
g; SpeCIal Tralts (AsRef and AsMut)
The main difference between — and — is that - and
— have several blanket implementations that allows one to used them directly
in a generic (e.g. in a where clause) without the need to actually implement them for a
specific type‘

Let's consider the following problem —) we want to write a generic function that
consumes an object but before it consumes it, it uses its reference to print it.

Let's see how we can implement such a function using both Borrow/BorrowMut and
AsRef/AsMut.

***************Ending Page***************

***************Beginning Page***************
***************page number:166**************
®/ SpeCIal Tralts (AsRef and AsMut)
Solution (using borrow/borrowimutj:
ompm

use (ore: m, .
use std IHJovrcw: , in ), Obl:FlW\\ omen :>1X:1U.V:ZUF
5mm i >< , y 1 Dbjzlo
m1 ‘or ‘

m [mm amt m <3», V> hm <

wmtew, ~ ‘H \ ‘7 WU‘ 4) , 5&1; x, 5&1; y‘;

i
»
‘n \ >\ WK‘ ~,
where

lEtX'n‘\"'. ‘)J

pr\n‘\rﬂl‘ r (} , x)‘
3
M i} '1

letp' (X 16, y: 20‘, (p1,

15¢ X r w, m,
>

***************Ending Page***************

***************Beginning Page***************
***************page number:167**************
g SpeCIal Tralts (AsRef and AsMut)
Solution (using borrow/borrowimutj:
Output
obl : Palm object :> (F10, y:zol

ebl = 10

Notice that we requlre Borrow to be implemented for
< > T but we haven’t actually implemented lt (this is
because blanket implementatiurl does it for us)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:168**************
g SpeCIal Tralts (AsRef and AsMut)
Let's try the same code with AsRef:
Notice that without the blanket implementation, we
can not use in a generic !
—

Fn \ >\ " H K‘ I‘ errluaﬂ/l m zmn bound Pow: Aswcﬂvowv 15 no: sausﬁcn
Mm WWW; 11 17
t \ 77777777777 ‘ ,n, ,,R" 4<n,;<»n‘n,> ‘< "A, ‘mpv,m,n,,¢ ,n, >n‘~'

mxrmw' ‘)J \ \

pmmyl V <3, v X)‘ 1 mum by a mm New“ by ‘M (an
3

***************Ending Page***************

***************Beginning Page***************
***************page number:169**************
Operators

***************Ending Page***************

***************Beginning Page***************
***************page number:170**************
g; Operators
When creating different types, it is often required to overwrite how some
mathematical operations work for them‘ In C++ this is accomplished by using the
keyword “operator” and being able to write specific methods that describe how
certain operation should behave.

In Rust, there are a set of traits that if implemented will result in a similar behavior,
Keep in mind that there has to be a resemblance on how an operator should
behave. Some operators like (I and I) use lazy evaluation and require bool
parameters and as such can not be overwritten.

***************Ending Page***************

***************Beginning Page***************
***************page number:171**************
Most of the arithmetic (binary) operators have two possible forms:

A) Expr 9 Expr (binary operation)
NOE/CE that the method receives a 5e!‘ This means that With OperatioﬂNathe (Humvee mi!) being
nwnersllig will be transferred if tmit is nut the name assigned for the Wrath)" Hand
implemented _1 npe-rahonname (Inwerensednne name ofthe

method that needs to be implemented to
_ _ overwrite that operation.
B) Varlable 9= Expr (asslgnment)

***************Ending Page***************

***************Beginning Page***************
***************page number:172**************
E; Operators
The next table contains a list of all binary operations that follow the previous
described template:

-—W -—|m:-
+ stduopszdwd add += stdeszMdAsslln addiasslgn

e sld::nps::5uh sub e: std::0ps::5||bAssign sub_assign

~ std::ups::Mul mul ~= std::ops::MulAssl(n muLassign

/ std::oDs::Div dlv I: stdwpsxuivnssixn divjssign

as stdmpsnkem rem %= std::ops::lhmAsslgn rem_assign
a stdnopssBitAnd bltand e: std::vps::BitAndAssign bitandiassign
| s!d::upst:BitOr hitor |= std::ops::BilﬂIAssign bitur_assign
A std::nps::BltXm mm A= stdzzopsxﬂltxnrﬂsslgn hltxnriassIgn
<< sld::ups::5|ll 5m <<: stdxopsxshlAssign shl_assign

>> std::ups':Shr shr >>= std::ops::S|\rAsslgn shr_assign

***************Ending Page***************

***************Beginning Page***************
***************page number:173**************
Let's see a ver simle exam Ile:
M M up~ ,
om ut

struct ' P

value! , 20
imp; < ~, (or \‘

type Z ,

Fry /5&1F, H“ 7 > Self: (

5m valur , ‘m

)
)
fn n (

let a V 1 value 16 L

1a x r a , m,

pr1n11n\{ (x) 7,
)

***************Ending Page***************

***************Beginning Page***************
***************page number:174**************
. Operators
Notice that. method receives a - (meaning that the ownership of the object
is transferred and as such, will no longer be available after the addition.

Rust
Std: CU; i
i value ;
EiiJ .Zr i: l l V : l
‘value - i»;
" errUrIElilil] va'ruu m Wave‘) “he .4
i.“ it i l
i-i-Wiai-t . 15 l MVP»,
, k. i ‘WWW H i‘
1‘ l uvlveruM “HM: mluvu
l v,1u, turruuaq haw, ,vi,r may,

***************Ending Page***************

***************Beginning Page***************
***************page number:175**************
You can, however, imp\ement Add for a reference (in this case for &Test) and avoid
transferring ownership.
Rust
mm M r 20
Wm 10
rm), Lg" 111 h» {Tut 1
m‘: frrruf V 1m
n ‘w. H v.» ~. U “mm;
“Hum _ w
a v'u'rw r
‘n 7 rw' .; “'1le w 1‘
\‘4 7 m ’ 1a‘
WWW , ‘_
pmtlﬂr 1‘; value‘;

***************Ending Page***************

***************Beginning Page***************
***************page number:176**************
®
Operators
You can, however, imp\ement Add for a reference (in this case for -) and avoid
transferring ownership.

M mm-

20

10

_

***************Ending Page***************

***************Beginning Page***************
***************page number:177**************
O pe rato rs
Notice that ifAdd is not implemented for se\f, adding an object with a number (for
our case) will fail.
Rust
“Maw mm .W MW‘ k. 1.‘
n | m 1 1 mu:
| ~ (Mum?)
l l
l lest

***************Ending Page***************

***************Beginning Page***************
***************page number:178**************
g Operators
You can however call the method - directly [this is different than the
o'emtor + as it wili try to match the parameters and since Add trait is impiemented
for the code wili comile!

Output
20
1o
)mul t > fur‘ s t
m X , a m,‘

***************Ending Page***************

***************Beginning Page***************
***************page number:179**************
You can im-Iement multi-Ie Add oerations:
strutt .‘ value l
)mpl < > For ( Output
type 1 ,
Frv vulf, ‘M l '> SDlF ( WIF valuc l M l 20'50
‘/
‘Wm; 7 "j" _ '~ In this case we havetwu forms qudd:
‘a (521;, w, ’ ; > 521; < 1) Test+i32 :>i31
l value wlF value 4 l l value > 2) Test+Test=>Test
l
l
fn n v’
let a V ~ value 18 l1
lrW h ' ~ VHlUL‘ 11* )-
1“ l 7 u value‘ 1a),
let X Z a u m»
let d 7 b u c,
arimla‘! ("\U v x, dwalus);

***************Ending Page***************

***************Beginning Page***************
***************page number:180**************
Operators

Let's see an example that uses an assignment.
Rust

value:

MU - PM , v ‘ ‘ a
.value > v
“WU; \* value 1&1}-
UvrntJNV‘ “, w:

***************Ending Page***************

***************Beginning Page***************
***************page number:181**************
®; Operators
Rust also altows overwriting two unary operators (- and I) that corresponds to
the operator — (minus) and operator l (exclamation mark) in front of an expression.
OBS: Keep in mind that this operator receives .(implyihg a transfer of ownership)‘
This means that ifyou implement this for a type that does not have the Copy trait,
that object will not be available after calling Neg or M operators.

***************Ending Page***************

***************Beginning Page***************
***************page number:182**************
Let's see an exam-Ie that uses unar oerators:
M ~n| up~ < v w,
‘ ‘/ o t z
stmct ' U pl]
value: 40,90
imp; {or <
type Z 1
fn (selfwseln \' 7521; value j
v
mp1 Fm‘ (
\pr r .
m {SE}H'>SEJ# 4 Iderselfmalue )
v
m m (
1M a ' ~ valub 1P ).
m X 7 Va,
Jet b Z 1 value 1a ),
let y 7 ‘b;
11mm‘! m (y) 7,

***************Ending Page***************

***************Beginning Page***************
***************page number:183**************
g; Operators
- and -traits are design to allow index operator overwriting in Rust, with
Index being a super-trait for lndexMut.

Keep in mind the indexing operation in Rust return a reference or a mutable reference.
This is a limitation as you can not create and return an object (except for the case
where that object is part of the type).

OBS: As a rule, in cases where index is our ofrange, you should panic J

OBSZ: containerlidx] is pretty much the syntax sugar for containenindexﬁdx)

***************Ending Page***************

***************Beginning Page***************
***************page number:184**************
g Operators
Let's see an exam-Ie that uses index o-erators:
use std ODS I( J L M LT
m m w value; Mm,
t \ WWW \ n n u n mum w ; w 1 a‘
, w u it,
5mm a V m \ M‘
values [ ,4 ,P ; Z
v w A V,
mp‘ < > Fm‘ < pm\\n~ \ 4} 0 n n mum w ; w 1 a‘
\pr , ‘ '
m (mm Mm 1 V> ESle q
n 1mm; ( retnvr wannvaluesLmaqx, j Outpuk
Dan1:!(“ w \~ , );
; \P:OO.D.O
> \P: 1927168701
)mpl < > m <
fn (Emut self, 1 ‘rev: 7 V> ﬁnut Self: (
w “M4 ( mm wut {selnvalum M'WL '
uamcH“ \ \ ‘ )v
>
)

***************Ending Page***************

***************Beginning Page***************
***************page number:185**************
You can a\so add multile indexes:
m 5m “=3 ,
mm
MN, r 4 ,H \w
‘w \ \ m , m 1p 1 mm; ‘JZQJLKJVJL ,,
(Wt Z ‘ ‘ prmﬂnW U (W U U ,lMVWJP‘ ‘Y’ l JUVV‘,
F, ‘Mfr ‘ “x , M”; ‘, DHrvUH‘! n ‘m \ z
\\\u<-l ( \M \ ' Mwl’ v5]ﬂ§>[ \ ~ ‘j DUMMM‘ U 'u‘ y’
pamcH' ~ \ ‘ ,,
1m J. , O ompm
w : ‘
F1 :55”; 1'1» a ~ > mu ‘ IP:192 1631.123
‘I ‘K M é)‘ wt n Mich mm e ,, 192
‘ ‘ Mm.‘ mm mm m» 153
‘ H size)‘ Wm, ; ‘ ~
M \ 1 A n Mm mm A ,,
71> jpmmw ‘ ‘p,

***************Ending Page***************

***************Beginning Page***************
***************page number:186**************
g; Operators
Finally, keep in mind that assignment (‘I’) can not be overwritten.
This is because assignment is used for ownership transfer or Copy semantics
(pending on what trait is present),
As such, this operator has to be handled by the compiler itself (as it is part ofthe
move/copy semantics logic that Rust uses internally),

***************Ending Page***************

 