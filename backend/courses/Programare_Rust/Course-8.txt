***************Beginning Page***************
***************page number:1**************
Rust programming
Course — 8
Gavnm Dragos

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
®; Agenda for today
1. Closures
2. lterators
3. Vectors
4. Sorting data sequences
5. HashMap
6. HashSet
7. BTreeMap
8. BTreeSet
9. Map comparation between C++ and Rust

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
7
Closures
L

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Closures (or lambda functions) are short functions that can be used in different
scenarios leg. when sorting, or filtering collection of elements).
Closures are widely used with iterators.
The general format of a closure is:

|PararnlzTypew ParamlzTypel,...Param‘:Type‘| .> Returniype l codeeblock)
With some observations:

' ReturnType can be omitted. In this case Rust will tr to infer it from the codeeblock return
value; -) IPar'amV Paraml... Paramnl {code-block}

- Typej, Type2___Type" can be ornltted as Well. Rust w||l trv to infer them from the usage.

' The brackets from the code-code block can be omitted (in particular if the code-block is just a
simple expression), In this case, the codeeblock contains 'ust the expression that evaluates
the return value; -) lPararm, Paramj,“ Paramnl returhevalue

~ If brackets are omitted, the ReturnType must be omitted as well.

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Let's see some examples (with a parameter types and return type specified):
RMA'!
it: ,1’: -' “1';
nmvdeUR; it‘; ‘I’, [ 11
1 Z 6
E Z a‘;
while ihg f
if gait 37w; :1 else q L'aQH'
renmn 5;
l:
printlnll" ",ﬂv_1a)',»;
pm'nrlnh'“ ",\;ru-n,:\n:,14),1;

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
®/ Closures
Let's see some examples (with any type specified):
f" maan ( 0mm
let f1 : ‘A (x+1);
let f2 : \x,y\ x+y; 11
let cmmdc e \X,y| { 3°
let mut g e X,‘ 5
let mut g e y;
while 5EIQ {
if PE i H; } else i b'jﬂ
)
i
)1
println!( n mum);
println!( {) ,fZ(1B,26));
println!( n ,cmmdc(18,24));
)

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Keep in mind that a closure is not a template [even if no type is s ecified . In the
next example, “x” and “y” from f1 are inferred to be of type
after the first call of printfl Macro.
As such, the usage of a float value will not be allowed.
RuSl‘
mainly l
t1 I l"-,;, l "w;
pr'ilitlnll" ",mm,zmi;
l WM WW. hm “mm W. W

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
A closure does not need to have parameters, it can just be a simple function that

prints something on the screen.

RUST

nvainLjv ‘1 -
, e H println! L'TMst"); °""‘“‘
pmnclm :31 like"); \llke
rt’); Rust
w‘intln‘k_"1 like“; \llke
n1}; Rust
‘\
OBS: This is in particular useful with captures.

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
A closure can capture local parameters. Let's analyze the following example:
Rust
mainll l
print -, : ll prilelHHH- hi):
prwrim;

l

Let's see what's ha pening in this mov Word PU‘ [X111

case (where closure capture

the value of "x") lea Fax‘ [X]

' mov qwnrd ptr‘ [printix],r~ax

lea m, [printix]
call main: :closuhew

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
A closure can capture local parameters. Let's analyze the following example:
Rqu
mainlr (
flint -, : ll prirler\l("x: ",i):
pnntgm:
l
Let's see what's ha pening in this WV Word PtP [X111
case (where closure capture
the value of "x") lea Fax‘ [X]
' mov qwnm ptr‘ [printix],r~ax
lea m? ént Xl

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
A closure can capture local parameters. Let's analyze the following example:
Rqu
mainlr (
flint -, : ll prirler\l("x: ",i):
l
Let's see what's ha pening in this WV Word PtP [X111
case (where closure capture
the value of "x") lea Fax‘ [ll]
' mov qwnm ptr‘ [printix],r~ax
x lea m, [printix]
call main: :closuhew

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
A closure can capture local parameters. Let's analyze the following example:
Rust c“ equivalent
maim'r r l
,- : 1; ' X;
flint -, : ll prirler\l("x: ",i): Run!) l
urwt ‘U: printﬂ">:: ‘wwxr;
r i r
Let's see what's ha pening in this mam‘) l
case (where closure capture '~ 1? V
the value of "x"). . 1M” "
lll'lllfijlyi 1 m;
pr'lHL ~<.Rum r;
l

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
.
Closures
A closure can capture local parameters. Let's analyze the following example:
Rust c“ Equivalentfwrrh [11155551
Irlaim'l l l
1 : 1; a x;
[lint -, : ll prjﬂllﬁunx: ",i): :
printinql; Tempilosurel a mum; Xrlmm-l r‘;
l operator'Q U l
Mina?» aux};
Let's see what's ha pening in this 1»
case (where iclosure capture 1‘: _ _
the value of "x"). mam‘) i
'1 m m;( '- I! ;
l

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
a Closures
So a closure captures references to variables that are being used in its evaluations
This also means that every rule that applies to borrowing variables apply here as well.
Rust
{l lllaiﬂl l l

1w print; : ll pr‘i|1tlnll“- 1;‘,m;
primjrr; x from main : 1
priminu" w-m law i i]“,><'>; X11
prrirrtixlj j];
l
In reality, both print_x and main use immutable references to “x” and as such this
code will workjust fine.

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Let's consider this code:
Rust
p mi.‘ : ll Dr‘llitlﬂll_'")l: ",1]; Kfrumrnzin:1

pi‘intlnll">l fem“ main : ‘35>; “1

iii-1H: Hi;
“x” is a mutable variable‘ This code works so the way printix capture "X" is by an
immutable reference (if it were to be a mutable reference, the println! macro would
not compile as it would imply the existence of both an immutable and a mutable
reference to the same variable).
OBS: In reality, Rust chases how i! borrows references based 0n haw those references me being used in
the closure,

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Let's consider this code:
FMS!
mainm <1
l : 1;
r’! int!‘ : ll i, println!("x: ".1,>;- 1;

pi‘intlnl(">: rm“ main : ‘35>;

til-1H: ‘All; r"; Wm “Writ
In this case, we have modiﬁed the closure l l u‘ “‘ ' ‘" J“ "
to increment the value of "x". For this to 4 l {WW ‘"2313; r M
happen, "x" must be borrowed as mutable, V l p m,‘ H ‘W"‘“"" m" “ “ ‘ "P
and as such the println!(...) macro can no l we“! "M ‘3"! “1"”
longer be used as it implies the existence of both immutable and mutable references
to the same variable.

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
a Closures
Let's consider this code:
Rust
ll in "U; *11
m: w;
Notice that - is mutablev This is required as in reality we change the value of one
of its data members (the mutable reference to "x")4

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Rust also has a special keyword (move) that can be used to move (asslgn) the value of
the captured elements into the lambda/closure.
Rm
v 'v l
"mm -‘ Z 1-
Tl ll n :|:|ll <1 pl intln! l "x: "-il ;£1; }; XII
ww' w); xfrom mam:1
p|‘int1nl("'-I from main 7 -, ",\; X12
“1,: .1); xhommalHII
p|‘int1nll_"x {Pam main : a "y;
l
Let's see what happens in this case.

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Rust also has a special keyword (move) that can be used to move (asslgn) the value of
the captured elements into the lambda/closure.
mm
"law l Im-
_ I 1;
Hill. : ll lj printlnnw: "Quit; }; X=1
1m" A); Xfrommam:1
p|‘int1nl("1 {mm main = "3; x12
1m: ,1); xlrummalHII
p|‘int1nll_"x from main : a "3;
l’ mov eax,dwor‘d pt!‘ [X]
mov dword ptr‘ [printix],eax
Let's see what happens in this case.
E

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
®/ Closures
Let's see a C++ equivalent for this:
class Temptlosure ( class TempClosure (
int& x; int x;
public: public:
Temleosure(jnt& Nye): X(VGLUE) n Tewvtlvw'ﬂint value): XKvalLﬁ) U
void nprratnro () { void operatoro () <
pmmﬂ" my); printﬂ" %d",x);
X+:1; ><+:1;
} )
); );
void main() ( void maln() {
intx:l; iﬂtXIl;
TempClnsure printjqx); Temptlosure print_x(x);
printixo; printixo;
) )

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
5/ Closures
Let's see a C++ equivalent for this:
class Temptlosure ( class TempClcsure (
int& x; int x;
publit: public:
\empuosureﬁinta ‘13118 : X(Value) U Tevwilvwvdint value): XNdlLﬁ) i)
void @1me { void operanm) § {
In this case a reference is captured. In this case the value is captured.
X+Ii§ “:1;
) )
); );
void "mm ( vold maan (
intx:l; intx:l;
TempClnsilre printjdx); Temptlosure print_x(x);
printixo; printixo;
) }

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
This means that the previous example that uses move keyword worked (but only
because Copy trait is present on I32 type)‘
Rm
maimgv -;
._ : urrumw'ubﬂw;
Hi‘ r :|:|\\ <1 println!\".\': ‘Zing. rush 5m_"1"\; 1-;
wrn" w);
p|‘int1n1("'-I from main 7 -, "A;
nlrt .1); Twin“ 7::rr'vi4ﬂnwn1nhn .
p|‘inf1n‘\_"x {Pam main : a "y; r "‘“ “‘" ‘ "
t ; r m m . “m5 m‘ m h
r WWW". :W m"

_ = r w m NM, Z u 4 w'mrlnw'-:<.>',-\_- pr|1=h§rr-\‘1‘\- ,>.
However, If we use a type that does not 1 ‘ LTZ‘Z§I‘1ZLL11“" "
have a COPY Era" (E-g- a 5mg) the code 1
Wl|| not compﬂe! 1‘ W's“

5r mm“ \nm M V 4n r,

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
This means that the previous example that uses move keyword worked [but only

because Copy trait is present on I32 type)‘

Rust

{n maim') r
15L mt 5 : String::ﬁ‘om(“¢L¢“\;
m Hm wint x : "we H t Dr‘1"tlﬂ!l“':l 1‘ v5i\:1~2“5h_5trt“1“J; t; M
grint “a; mm
wint x1}; Pam
grint XL‘); x:abc11

k

Now the code works, but the ownership of "x" has been moved into the print_x

closure.

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
.
Closu res
One solution to move back a value that was captured by a closure is to return it‘
RIIS!
mainl ‘v i
l : Hrmmwahcw;
ll ill. :|:|ll { pr irvtln! l "x: ".i) :l.gu5h 5cm "1" l wenwn 1? l;
l : wwr .~l_‘/;
l K:Bb(
x : abcl
In this example, first “X” is moved into print_><, then it is moved back.
OBS: In reality, these type of clusures can only be called once (for example in this case, the moment the
value of "X" is moved buck, the capture prlntix can no longer be used).

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
One solution to move back a value that was captured by a closure is to return it‘
RIIS!
mainl] l
l : IImel "abc“ ",l;
lVlFf = :[::::]ll ( printlnl(“x: ",il;l.gu$h 5trl"1"l;return i; h
i : lr'nt ‘ll:
V""‘H"l‘~nx Z “'L)‘ K [EM] us: w W" ‘m ‘We
l -\ l -» Z p-Wrm.
l 777777777 p ,nrr, m“ in n“; in rhlr >i11
'l unwhm“ :lwll
El pmkuh
l “slu, u,,Q h,-, svlu- mus,
l
nnru >1“ u F >=nnnr hF ,n nven m“ F than n~>F ~F>iurF ,, M“ Fr th a ,QM,F , n“r n, ,rr
nulwwnw
~ V.mm 71¢
l
1 1 ,ir m"? p_,nrrt Z mp i ll l pr,nrlnll ;:ll .tl,t Flthrtrrl 1 l,rirurn t. M
not: (his value tm»;.m.“1§ ‘“u“(= l nh1<h <aus2s A! (a be moved when <alled
W .smhvrlg
-\l #:p'urw an

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
g; Closures

Each closure implicitly implements at least one of the following 3 traits, The decision

on what to implement belongs to the compiler, based on the operation and how

capture is being used in the closures

1. - 9 closures that can be called only one time (usually a closure that moves
a value through the return type out of its context)

2, - 9 closures that don't move values out of their context but might change
the value of a mutable reference that they capture.

3, I 9 closures that don't move values out of their context and don't modify any
reference that they capture (they capture immutable references) /

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
g; Closures
So what if we want to create a function that returns a closure. Well the first thing
that we need to understand is how to define a pointer/reference to a function (similar
to how this is defined in C/C++)t
To do this, we will use the keyword fn in the following way:

n (Type ,Types, Type")->ReturnType
Some examples:
- — -) a function that receives a i32 value and returns another i32 value
- — -) a function that receives a &str and an usize value and returns an object
of type String
~ _-) creates a type that represents a pointerto a function that receives
a parameter of type char and returns an i32

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
® Closures
Let's see one example that returns a pointer to a function:
RUS!‘
tzw MyFunction : F!!(_i32,i:‘27')132; m
tn createiaddifunctiont't r= MyFunctinn 1
VELHWY \-,;132,\,\:132\<\132 ‘i vet“, y wt; t
I
F” main(\ t
let add : create_add_ﬂ|nctjcm_'\:
Lit sub: MyFunctiun : \- ,w"
pr“jntlr\!(“"\], 1'1“,addt_l,2t,sub(19,4));
l
In this example, MyFunction is a type that defines a pointer to a function that takes
two i32 parameters and returns an i32 value.

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
But what if we want to do something more complex (e.g. to return a closure that
captures some variables/parameters):
Rust
createiclosureg'mlue: w r ‘,r' » r
return \ 1: \-; -r return ~ r Mme; ‘r:
‘i
g U [111121 wrrwrt.»gd [rugr
maim' "1 r j "' 1 ‘1
r : createicloiurekllﬂ); 11"‘ . ‘W “r ‘““‘ “"‘" Tiffffiifff’ Y, , ., , .r r r V;
pr1nrinrr"res : “.rrsuVW: r iiééwg‘ “ ' " ""
_‘ 1 r MW r111» 121 1. MW ( mm,‘ .u
r
Z Hm 1 ‘.1 (ch m WW‘ mu‘ V H1
ruuwd .ru H g [.1U7Hrgrrr. mrr" r’ 1 11 1 1”]
nu‘! (resur.s I.“ nqrv n! (alrzlﬂ (a ‘n @v,.s 1‘ rnlv 1” "a! (.ptur! ,nv v.r,.n11s
1r {m "r “new r ‘(my “he r‘
r m.“ unuredhere

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
That is because a - is just a pointer while a closure is a struct and its size its
unknown (pending on what variables it has captured). The solution is to explain the
output based on what it implements: Fn, FnOnce or FnMut
Rust
createiclosurel r. :T m: yr’ , ‘r

return l-; l7» l return ,7 c value; l;

mnwmu'wﬂ Z "manly; - 1 11
The approach is 0k, but since value mi Mm h:rr:.enuaue1uaue1
is not copied, but only borrowed,
when function create_closure ends, "value" lifetime ends and as a result, it can not
exist in the returned closure.

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
The solution is to move the value that is being capture into the closure. In this case,
there is no concern related to lifetime as the result is copied‘
RUSK
treateiclosureijualue: 1r’ - _l M
recum|:|l ; l7,» r return - a unluv; l»;
r
mainl.) l
; createiclosurei'lﬁl:
pr‘1ntlnll_“r‘e5- : "ﬁtwilz
The code could be written with FnOnce (as we are using move and FnOnce is also
implemented).

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
But what happens when We use the - keyword ? To answer this, let's analyze the
following code:
RIASI
(rearujlmlrm .nw w V. l v
=
[reamilngumzl ‘we; l '_ l l» l
"lajnll l —
'1 7 createidosurellﬂg,
v; : Lhesteiclusurelllil;
,.< ,,- Z 1:11
‘.1 Z - we‘,
.: 7 @285,

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
But what actually happens when we use the - keyword P To answer this, let's
analyze the following code:
RUSK
muv EdX|29
lea rcX,[x1]
call first: :(Peateidosure: :(losuhelae (wwsmcsnsah)
muv dwurd pt!‘ [y1],eax
muv EdX|29
lea rcX,[x2]
call first: :createidusureZ: :dosurew genrsmmzzen)
muv dwurd pt!‘ [yZ],eax
muv EdX|29
lea rcX,[x3]
‘.v Z . mu, call ﬁrst: 1m": @05le (B7Was4cln7ﬂn)
_; 7 .3181, muv dwurd pt!‘ [yi],eax

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
®
Closures
But what actually happens when We use the - keyword ? To answer this, let's
analyze the following code:
RIASI
B7FF654C31156h
- mmmmm
‘.l : ,- l2l3l,.—| B7FF554€3137B||
.: e -1lZ€1,l,>—‘

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
This actually means that each closure is a separate type. From this point of view, two
identical closures (in terms of code, parameters, capture and return value) are
different from Rust point of view, This is similar to how C++ implements lambda
functions, and it also explains why the next code does not compile!
RMS!
(i'eateiclosureii 71w; i V; i_' i V; ij
ii ilil—-'1U >
l @155 i
return l-: l a: return - .Fl; u; i:
l mﬂlriii i “1'1”?!le $15213“ my)
l 5 l rm" “W i», mi V m .1 mil," i mm ii

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
. Closures
Since we can not have a function that returns two different type, the next code can
not be compHed.

RMSF
create-iclusurem m»: 1 V; r 1 V; 1,
1¥ ‘ 1‘\lf.1{< 4
1 else \‘
return r; \ 7' t; mm. v r; _
I mainn k
s o (FCZitCiL'lDSHFLWUJAI
But... what is the relation between "impl Fn(i32]e>i32” and those two closures ?

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Closures

Let's assume the following function: createiclosure

(i'EitEillDSUPEl Vluis’ l e‘ l' i r. l
When the compiler sees that the return type uses impl keyword, it search any return
type from the function code and assumes that the return type is what the function
returns. This means that the previous code will be translated by Rust as follows:

(reateirlns-urel tin,- ‘i V -;

return l>. l e l return > .qiir, i;

After this, Rust checks to see if ABCD implements the trait Fn (with one parameter of
type i321 and if it returns an i32 as well. lfthis is so, then the function is correct, and
its return type was inferred from the type of the closure. Furthermore:

***************Ending Page***************


***************Beginning Page***************
***************page number:38**************
Closures
The main advantage of this technique is that it allows static linkage of the closure
calling method. This means that since we know the type in the compiling phase, we
know the memory offset where the calling method ofthat type lies, and we can call it
directly.
However, let's analyze one of the previous errors and see what Rust suggest:

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
a Closures
So, what does Boxing means in this context ? Well its like the usage of virtual
methods from C++ !

mm
t '- 'teiclnsuml 71o; jEIi ~ Emu, l'HlJEZ'l ~ 132 l1
=
tn mainli t

1th ( 7 (Feateit'lnzuféllﬁii

ugtlm i‘ .LlSBi];
Notice the usage of the keyword dyn in the definition and the fact that We don't
return from the stack but rather allocate a space on heap (a box) from where we will
return an object.
We will talk more about dyn (short from dynamic © ) on another course.

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
With this change, we can now return two different closure [one that uses multiply,
and another one that uses division).
mm
r" (Peateiclnsurerhslut’ 12:‘ ». aunt,’ mum ~ in r m
n Hu- 1 :: a -(
rvﬂrn rm,‘ net-MM,- . In‘ ~ 111; retnr‘ - r pm»; n; 550,5
r mm: -;
FUUFH Pox: net/hurt: - jam ~12: r 1w” - ~ ﬁluw; w;
m malnw 1
w (1 : createiclnnlreﬂllr,
1r» (z 7 crlzatciclasumdm,
u;h<71uuj“::r: ,L1[:59'\,CZ\5EIM;

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
7
Iterators
L

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
g; Ite rato rs
lterators are object that can be used to iterate over an existing collection. They are
efficient for cases where index access requires a boundary check, or for collections
where index access is not possible (esg. a linked |ist— std::collections::LinkedList)
Collection that use iterators:

~ Arrays

~ Vectors

- Maps (BTreeMap, HashMap)

- Sets lBTreeSet, HashSet)
All collections that implement iterators use the trait - defined in
std::iter::lterator

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
®
Basic operation for iterators

“@ch 7 A \ :: ‘I Moves t0 the next e\ement rrorn the coHections.
rm .5 a vlrtua‘ method that must be Implemented
by collecnon that implements thrs mm.

(ountll 7 A \terates untrl the fine‘ e\ement and returns the
number or \lerauons.

lastr ; V; L z: 1 Hermes until the last Hement from the coHectlons
and returns it‘

mxr' j» 7;‘ , :: 1- Returns the maxrrnurn/minrmurn number Vrorn the

mink, > -> r r1 - current posmon

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Ite rato rs
Let's see how an iterator works:
RUE!
WW ME-
:1 Z [1.2,3,4.s,5,7,.a.“-]; 50mm
i : [LitEPUZ Somew
(“ " ~1‘ nexU ) ); Snme(51
(“ ELMO‘); 3
(" ‘Ui-mﬂn;
> ‘
Let's see how iterators work in this case: |i|

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
. Iterators
Let's see how an iterator works:
RUE!
mo < mm-
ﬂ Z [1.z,s,4.s,a,7,vaﬂ-]; 50mm
i : miter"); Somel2\
r" — 50mm]
(“ ‘.14&k. ,v; 3
K" ‘1-me
)
Reads the value from current
WSW”, and (hon advances
[D [NE HE)“ One

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
. Iterators
Let's see how an iterator works:
RUE!
m0 < ME-
.1 : [1,1,$,4,s,a,7,a,e4]; SDmEll]
i I [hitEPk'M 50mm
(“ "mnext ‘y ; 50mm]
)
Reads the value from the 2""
mm", and lhcn advances
[Olhe nEXl DHE

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
. Iterators
Let's see how an iterator works:
RUE!
mo < mm-
ﬂ Z [1.z,s,4.s,a,7,vaﬂ-]; 50mm
i : [LitEPUZ Somel2\
(“ " ~1‘ nexU ‘r ); Snme(51
(“ " Lnext! ‘1- 3
> ‘
.—.
Advances s posrllons and
reads the vame, than move
(O the next IOUUOHY

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
. Iterators
Let's see how an iterator works:
RUE!
mo < mm-
ﬂ Z [1.z,s,4.s,a,7,vaﬂ-]; 50mm
i : [LitEPUZ Somel2\
(“ " ~1‘ nexU ‘r ); Snme(51
(" ",l4nextk_')jv; 3
(" " Lnth 3 ‘
)
.—.
Counts how many eremems
are unche ﬁnal‘

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
Ite rato rs
Keep in mind that some methods (like count, last, min or max) consume
the iterator after usin it notice that count need self and not a reference
to self: ). This means that the iterator can
not be used anymore after calling these methods.
RUE!

majn() {
a : [1,2,5.-i,5,»5,7.5,s];
i : mitEH');
i

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
Ite rato rs
This behavior is different than next() method that does not consume the
iterator (even after it reaches the end of the sequence of elements).
Rust
mint) r
i : :1.th7"(); Sumelll
for‘ i in a. .1r-a ( SomelZ)
K" ",i-HEXUU; smnelil
} Nam:
\ None
J None
NONE
Nune
None
None

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
g; Ite rato rs
lterators are often used in a for loop, There are 3 forms of iterators that are
usually used in such a context:

Creates an \teratcr that return a reference m each element from a coileztion

s 1 m ii- t ' ' Stmllar to the prevtous one, but the relerence ts mutahie, and the value can be
mudlhed,
t-ht r t t I Nottce that thts iterator has a patameter of type self (and not (belt). This means

that [his iterStOt consumes the content Olthe collecliOn

OBS: Keep in mind that without any explicit specification, the far Ioap will use the

inta_iterform (e.g -). This means that the for laap will consume the

element, and "a" will not be available anymore after the fore/00p ends.

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
a Ite rato rs
Let's see some cases where .iter() , ,iter_mut() and .into_iter() are used.
Rust
+n mam) i

lei. a = [String :fromﬂkLriJ‘Liming: :framﬂqj )]; M

H >1“ mm!) r m

Jpn-mini“ Xi“),- -. j .1 ruin-mg WI

]_ ["abc", "xvz“]

m’1"ifin‘(“ijw‘l‘)§
i
In this case x is an immutable reference to every String element from array
a .

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
® Ite rato rs
Let's see some cases where .iter() , ,iter_mut() and .into_iter() are used.
Rust
in niainf) <
1w "m g : [String :f|‘i)m(_“ in ‘ ),Str‘1ng: #mm‘ -,~ ‘)1: M
m 5 ii ajter mum) ( m
w'iminW“ xi“); ~v 1-: .1 Rum wring m
5.gush 5mm»); ["abﬁ++">“xv1+++“i
m 1*171‘(“[B,>‘1‘ J;
)
Notice that since we have used iter_mut for this example, we can modify
each element from the array "a".

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
® Iterators

Let's see some cases where .iter() , ,iter_mut() and .into_iter() are used.
Rust
+11 mainll) (

let a : [swing#mmymw),smng;:mmwz >1,-

w >1 H a.intuiiter‘() (

LHintlH‘(“~:Xl“); -, 1g 1 ‘7-7,;va ‘111+; Jana-mm“

In thls case, each element from 1 1 mwgmyw my M ‘
array Ha" i5 moved, AS a result, \ ,1 mm 11- '1 m» mm nu
the last println!(...) can not 1 “Jill;
work, as “a” was moved.

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
® Ite rato rs
Let's see some cases where .iter() , ,iter_mut() and .into_iter() are used.
Rust
{ii mainij) (
M a : [1.231; MD
+1, >< ii aJ'ntaiitePL') i i
Jiliitlii‘(n~:Xin); -, J‘: a 13>‘ ia cup,‘ i: z
} 3
piiiioliiWWa'Ji‘); [11'51
i
Keep in mind that int0_iter tries uses assignment for each element in the
collection‘ If the element has the Copy trait, it will be copied, otherwise it
will be moved. This means that for these cases, the code will compile as
the element is not moved H!

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
Ite rato rs
If none of these forms are being used, a for-loop uses —!
RUSf
mainﬂ) (
n : [ ::Frnrvv("ab£"), :2fl‘0m("xyz")];
for‘ .- 1.. .. {
} H .I.
Because of this, elements from "a" l ' ‘.1. bi‘ 11L? ll? W‘ U mg‘ I] ‘ "m “ W m”
will be moved and will no longer be A l ..,._ m1 .1. > .1....w 1..
available when printlnl[...) macro i5 l p .......l.“;..
belng called. l “we Lvu'wueul he's my W19

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
a Ite rato rs
If none of these forms are being used, a for-loop uses ,into_iter() !
Rust
{it mainil) (
M a Z [Strlngz #mmi‘ mien-,stmg; mm >1,- mm-
w >< ll hi m
.1itiiiliii(“{xi“); -, r; L1 ELLJJLHE‘ m
} ["abc", “xvz“]
pi i viliii(“ia~'i‘ ‘,1;
l
One solution for this cases is to use the & operator to indicate the for loop
to use references instead of moving the entire value.

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
g; Iterato rs
Rust also support various adaptors over an existing iterator, that can allow
one to perform quick actions over a data set. Such a construct usually
translates into another iterator that can in turn be further used with a
different set of adaptors.

O O
r 1 — — r t
0+, 0*,
iterator iterator
ln this point‘ data from the original adaptor
can be "\odlfied skipped,illtered etc.

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
Ada ptors:

stepibw . L»; ‘J r ~ , ' Crezles a new \Keramr where every e\ements WIN he read
lmm (he unng use uslng a 5pr

hltew , rr' Fv v r‘ 1 7' : , : Fﬂters a" elemems from (he ongma‘ \(erator and returns
a new one where (WW the elemems (he! pass (he Me!
are present

"mp V , x w \ w J - >' . ‘ Maps 3H \tems from an exlsungiterawr {mo another one,
applying a wrwersmn over each demem.

impiwmleﬂ . ; 1-‘ in» "J 7- - 7 Sklps/Takes a number oi e\ements based an a predxcated

mama)?‘ w ‘ L‘ @113»: > ~ * , .-

IUDK , H \ V » ' 1- Sklps/(akes a number 01%” Hemems 1mm (he origmal

(wk-:1‘, , in , 7- . > \(erawr

mapcrtz' , J "I >' , ‘ Runsfuncuon "V'for each e\ement, and the" paswt on
Uselul €or debugging Duwosesv

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
I Iterators
Iterate over a list with step 2:
Rust m:
mainU
{ mainn Q
a Z [1,1,5,4,5.e,7,s,u]; ‘1 [1,1,34,15,155];
‘ . , ' », ' l: Lita-r1)
for 1 1n n.1ter‘().5tepihy(_) or ‘stepihyw
"' ‘. “ . .il\5pe:t4_\~\ --,~.y,;
( "U3 minim ‘
‘ v
I J
)
1
5
7
9

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
®
Ite rato rs
Rust also has a -adaptor that iterates over all elements. While it
has the same purpose as a regular I keyword, it can also be used in large
chains of adaptors as the final one to trigger the iteration.
Iterates over a collection and calls function "r" for each element‘
M ED
Eefurejlep 1
lvlai|l() i Afterstep 1
l e vccl[l 2 3 J 51- Between»!
diterll v l l l J Before HE!) 3
.inspeccljll- l prilltlrll l"BeF0|‘e step: ‘gull :llililinge
.stepible nereleszens
.Forieachi'lzl pmntlnl l“AftEV‘ step: “.‘nil: Aftelslep 5
l
l

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
®
Ite rato rs
Rust also has a -adaptor that iterates over all elements. While it
has the same purpose as a regular I keyword, it can also be used in large
chains of adaptors as the final one to trigger the iteration.
Iterates over a collection and calls function "r" for each element‘
Rust
"lei-l0 l M
I: [1,2,3,-J,5,5,7,S,9]; 1
a.iter() 3
.stepibyQ) 5
.inspect( :< '" H ‘ ‘ ‘ ’
.Forieach Lin); LIU
l

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
Ite rato rs
Let's see a more complex example that takes a vector, filters out all even
elements, multiply the rest of the elements by 2 and then sums them all
up.
Rust
l : [1,2,3,J,5,F3,7,S,9]; Flt d
: atiteN') "Ml
.ﬁltemlﬂl 1 :: m *1‘;de
imam l ->| Unhewﬂ " , ‘ ~ ‘n WWW
~vlavk'I-1l "1‘) Fllteredﬁ
.ir1spEtt(l , | {"Mappcd m ‘ ~.}) Mappcdm 12
‘5L1"l(); Flltered S
("sum is ",-:); Mapped m 15
\y Sumlhlﬂ

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
Ite rato rs
You can also use ,skip and .take to perform operations over a continuous
sub-set from a collection. The next example sums up the next four
elements from the 3"‘ element in a collection:
Rust‘
s = [1,2,3,4,5,E,7,8,5]; Valch
: 3.1mm) ValueS
.skipﬁi) News
AakeM) WW7
.inspectl l ,_| ("Value i-v-Ui) SMIYIiSZZ
.Sim >,-
("sum is ",E);
l

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
g; Iterato rs
Another wildly use adaptor is -. This adaptor allows transforming a
collection into another one.
mm——
— Iterates over a collection and converts it into another collection.

How to use .collect():
1t let varztype = miterators chain“ .collect();
2t let var = miterators chain“ ‘collect::<type>();
Usually, the first version is preferred as it avoids the turbo-fish format. i

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
a Iterators
Let's take the previous example and build a new vector instead of
computing a sum:

Rust Rust
w main() { w msiM'J 1
let a : ‘.‘efl[1,2,3,4,5,5,7,X,9]; Let a : ‘,‘Ewil[l,2,3,4|5,5:,-',8.9];
1» 5 : a.iter‘(') 1m 5; Veg; : 6.1mm
.skjp(2) ‘skip(Z)
.take<3> .take(3]
.collect: mm“): r_ ); .cullect();
L\7']Y'\tJV‘(‘V'tS\‘T w; ~1:7'ﬂ,s); Dvlrilﬂ‘(“95\|f\51,2?“‘,5);
) }

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
a Ite rato rs
This method is often used to convert an array into a vector:
Rust
l'i mini’) l
1r? a : [l,Z,3,A,5];
15-. b: v2“; : a.itev‘().collect(',1; M
py'iiitril(‘ﬂ: I"l“,8,l; v1:[l,23,4‘5]
iiiiiitliilf'l'i :v‘l“,b); b:l1 2,14,51
)
Notice the Vec<_> notation, The underline (_) tells Rust that the type of
the vector must be inferred from the result. We should also mention that
since .iterl) uses references, vector b will be of type Vec<&i32> !

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Ite rato rs
Another adaptor is partition. It has a similar purpose as collect , but in this
case, it tries to split an existing collection into two partitions. The closure
function serves this purpose (elements where it returns true will be added
to the first partition, and the rest of them to the second partition).
Rust
maiv\() i
7| : [l,£,5,4,5,6,7];
(owl): r‘ an <3) : c1.intoilteri).partition(l>,| ‘w >4);
("Partition 1 : ",pl);
("Partition 2 : “mil; m
i
Pammnquizsu]

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
g; Iterato rs
You may have noticed that for the previous example we have used
into_iter instead of the regular iter. So what is the difference.

1. - is an iterator that moves the element (meaning that after
you iterate over it, all elements from the sequence are no longer
available

2. -uses references (meaning that after you iterate over a sequence
of data, that sequence is still available).

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
. Ite rato rs
Let's consider the following example:
Rust
“\ainl') l
n : [ :1Fr0ml"ABC"), ::F|‘oml_'“123")];
my i in Lintoiitemi) (
f" ".1);
l
("a I ",a); IrrwrvafiY.‘lr WC“ 11 "m1 ml. 1
l .4 "Mu ,m u nu;- "mm Wu
;~ l Drlntlnll a :l v» .il.
wul nu:- mum‘ 1.0L:- .NHLVL-lup .w 1m munu ml , Mum mm:- .4
fl mmmmm V. my mm”.

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
a Ite rato rs
However, if we change the previous example from using iter() instead of
intoiiterO it works as we will no longer move the object when iterating but
use a reference instead.

Rust
in niain() (
iw a : [swing :Froml" w “),Sh‘ing::fl‘(lili(‘ .1“ )1; M
+1‘, i ll a.iter( ‘,1 { “ABC
mlrtln‘(“,:1‘i“.i); "115"
l 3:[“ABC“, “123"l
w J rumba j:"i“.a);
J

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
' Ite rato rs
Another useful adaptor is .find() that can be used to search for a specific
item that matches a criteria‘

+inu< .~<& , we Mr»: ) L == \ Findszn elememlhal .5 matched bythe
predicate e
FMS!
manﬂ) {
a : [1,2,1,4,5,6.*];
h e n.1ter().find(\&&e\ 71:4);
( .Lv);
}
OBS: .find(f) is equivalent m filter .nexr
OBS-find predicate is deﬁned as . This means that if an iterator uses
references the (laser w!!! have to use a daiib/e reference (a reference over rne reference pravrded by rne
uliginu/ iterator).

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
g; Other functionalities
All of the iterators and adaptors previously described solve some problems.
However, there are some cases that require a different type of functionality.

1. Peekable

2. enumerate

3. DoubleEndedlterator
4. ExactSizelterator

5. Infinite iterator loops

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
g; Iterators (Peekable)
One problem with iterators is that once - is called you can not go
back. This in fact is a roblem as you need the value that if you need the
value you get from h to decide if you want to iterate further or not.
To solve this, Rust added a new adaptor called Peekable (that allows one to
read the next value, but not move to the next position)‘

Let's analyze the following problem:
- We have a list of numbers: 1,2,3,..“
- We want to find number 3, but we don’t want to move next to it (to number 4),

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
Iterators (Peekable)
Let's analyze the following problem:
- We have a list of numbers: 1,2,3,..u
- We want to find number 3, but we don't want to move next to it (to number 4),
Rust
rualnf) l
4: [1,:,3,4,5,5,7]; M
i : ariteNLpeekableQ;
lﬁﬂp r
if i.geek().isfnon€() 1 mdk; }
x : ";.geek<),r|rwrap(l;
if Z a ( break; }
érnextl');
}
<" ",i.next().unwr*ap());
\
1

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
Iterators (enumerate)
There are situation where While during iteration an index is required. While
these sort of scenarios can easily be solved by creating an external index,
and incrementing it after each iteration, Rust also provides an adaptor
(called enumerate) that does the same thing.
Rust
a : ["John". "Mary", "Mike", "George"];
for 1‘ in J.itEi‘l_ '> .enuiliei‘at5\'l l l9‘ PM“)
pi'intlnll" ".ll; l1 "Mm"
i (2, MlkEll
r 1 raceway‘;
.»

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
® Iterators (Infinite loops)
Iterators can be used to create infinite loops via ,cycle() method. This
method creates an iterator that when it reaches the last element will reset
itself to point to the first one, thus creating an infinite cycle.
Rust
+1 mint’) t
‘9t a : [1,2,3,4,5];
it X iiE.itEF(l-CYC1€() i
j 113,451,114 5,1,23,45,11 3,4,5,1,Z,3,4,S,1 2,3,
} 4,5,1,Z,3,4,5,1,Z,3,4,5,1,Z,3,4,5,l,Z,3,4,5,1,2,3 J,5,1,
Z,3,4,5,l,2,3,d,5,1,2,3 4,5,1,Z,1,J,5,1,Z 3,451,134,
S,l,2,3,4,5,1,2,3,4 S 1,2,3,4,5,1,

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
g; lterators (DoubleEndedlterator)
There are cases where you might need to read elements from both ends of
a collection. For this cases, there is a special trait (called
DoubleEndedlterator) that if implemented allows one to also read
elements from the end of the collection via:
EEE—I@—

Moves to the previous element lrom the
collections starting from its end.
nt- hi' (.2 i n: 1i r: ‘ -: - Returnsthe prEVIOUS r\"’|temsfromthecurrem
position.
OBS: It is important to notice that back andforward iterator can not me
(one can not go beyond the other one).

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
lterators (DoubleEndedlterator)
Let's see some example:
Rust
nalnf) l

while (»;) : umext hach) {

i
\
l
Keep in mind that this is not an iterator but a trait (meaning that not all types that
implement Iteratortrait also implement DuubleEnded/terator trait). That depends on
how the data is store in that collection. For example, a single linked list can not
implement such a trait, while a vector, array or a double linked list can.

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
lterators (DoubleEndeollterator)
Let's see some example: Nenllrom Front Somell)
Previous from am : - Somali)
Rust
in main() ( Neulrom Fiont:\50mel2)
lrr a : [1,2,3A, 5,5]; Previous lrom am :\Somcl§l
m j H o. ‘5 ( Nexlfrom From:-Some[3)
fii'lnllli i (“ni- -t JFHH Flt n 1'; w“ aiming); rpfiffilljllfiqji? Snmelﬂ)
inhitliii(jjiweui;in limiH new, , {"‘l“,jit‘tnext beam‘); NculroniFrunthonc
"W HT l vi ‘l ); Previous lrom am :, None
t
} Ne" from Front :> None
Previous from am : - None
Notice that once back and front iteration reach the middle of the array, the result of
both .next and .next_bacl< methods is None ! This is because back and next iteration can
not go beyond the other one.

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
a lterators (ExactSizelterator)
Another interesting trait is ExactSizelterator. This trait provides a function
(len) that returns the number of steps until the end of the iteration (the
moment from when .next() method will start returning instead of
Some.

Rm mm-
l" "l2?! i i" i E E. HEN]; Elcmunt Aixmpstmmmd
l nil 1~t Saudi) Z iit-EO i klemem D:O~'-tepsuntiler\d
Lil‘1lllllll(“LA:lEl 11;‘ ,i trips unﬁt El l“, il.len());
J
1'

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
7
Vectors
L

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
g; Vectors
Vectors are sequences of elements of the same type that can increase or decrease
in size dynamically. Just like stdzzvector from C++ standard, a vector in Rust is a
template/generic object,

To create a vector, use one of the following forms:
a)
b)
cl
dl
at
fl or use the macro vec! for quick initialization of a vector. /

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
® Vectors
Let's see some examples on how to build a vector.
Rust
11+ 1m Q : Vcc::<132‘1::new(');
1-1L v2 : Vei::WED::with_capacity(106')¥ H
m v3 :1111;\[111s, :,s,4]; fyfu' 1: 1.111; 1:1.
1-» w = 1-1111[“1:5“,‘\-L-U,“ ;_“],- my’: 11 ‘1.1111 11m [1533-1le
1%: v5 : Vec::w‘r‘om([1,l,3]); we 11.191; 111 [1 23' a " “*1
prmﬂn‘r_“-;AWE); l‘ ' l
1-11111111!(“‘."';“,vz);
fr"nﬂr"(“-} 11-“,v3);
p111111n'(“-;~',‘»“,v47;
1.1 1r1c111:(“-::»'§-“,v5);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
®
Basic operations (insert/add/remove) for vectors

‘\ush (& . v JlLlL: :> Adds a new e\ements a\ the end 0f the vector

luseﬂifl , mm ,; , ‘1', H m: 11 Inserts an e\ementat a speciﬁc pos'mon m the
vector This lumen panics \f index is outside vector
buundanes

a ~ Yendﬂl , ‘:Lh ; a ) Append: the element m another vector ofthe same
type to (he current onev

m“ ) 7- : > Retums the last element m the vector (If any) or
None fur empty vectors

mum/ea. , 1w»: 7 7v Removes the e\ement from a speciﬁc mdex in \he

My rem/w , MW: > ~ vector Thlsfunclmn paVIICS \fmdexlsoutsldevscwr
boundaries

(learwlé'c ,\ Gears the content Of the vector \eaving the capamy
ofthe vectov un-aﬂeued.

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
.
Ve cto rs
Let's see some examples on how to build a vector.
RMA'!
maim') I’
m‘ \ in 14.10 { rcmovcﬁommdcxﬂZ :>3
l.w(i); Pop element: 9
j Pop element: 8
("Pcmuvc From inﬁrx #2 :> ",imeoveQD; Pop elememz7
while <1) : ‘3mm ( Popelementzﬁ
("Pop element: \ "y Pop clement‘ 5
‘, Pup element: 4
) Pop element: 2
Pop element: 1

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
®; Vectors
Vector has Z remove methods to remove an element from a specific position:
1) remove(i..)
2) swap_remove()
remove(...)
A B c E F
m
OW." I

* We want to remove element with index 5 (the 4"‘ element)

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
g; Vectors
Vector has Z remove methods to remove an element from a specific position:
1) remove(l..)

2) swap_remove()
remove(...) A n
-----

A B c E F
‘“"—‘>

we." I

* After we delete the element, we will move all of the existing elements after
index 3 one position to the left

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
g; Vectors
Vector has Z remove methods to remove an element from a specific position:
1) remove(i..)

2) swap_remove()
remove(...)
--------
A B c E F
mm
we." I

* Length is decreased by one, the capacity remains the same
* Operation cost: -

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
®; Vectors
Vector has Z remove methods to remove an element from a specific position:
1) remove(i..)
2) swap_remove()
swap_remove(...)
A B c E F
m
OW." I

* We want to remove element with index 5 (the 4"‘ element)

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
g; Vectors
Vector has Z remove methods to remove an element from a specific position:
1) remove(t..)
2) swap_remove()
swap_remove(...)
-----
A B c E F
m
OW." I

* After we delete the element, we swap the last element with the one that we
have just removed

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
g; Vectors
Vector has Z remove methods to remove an element from a specific position:
1) remove(i..)

2) swap_remove()
swap_remove(...)
--------
A B c F E
mm
we."

* Length is decreased by one, the capacity remains the same
* Operation cost: -; notice that the order has changed !

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
g; Ve cto rs
Vector has 2 remove methods to remove an element from a specific position:
1) remove(l..)
2) swapiremoveO
Overview:
1) Use swap_remove if you are not interested in the order of the elements from
the vector, otherwise use remove
2) swap_remove has a complexity of 0(1)
3) remove has a complexity of O[n) /

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
Generic al location/resize and infos for vectors
capacityL'E > -> Returns the capacity ofthe vector
Resevve addmona‘ e\emenls (on top of the emstmg one)
truncatem . 1w: '7 Truncaxes a vector to a specific len, dropping the extra
ElEmerllS.
m Few-ma , “AU'JMHAU y Tries m reserve some spaceM allocauon mm does m
Lu. > panic m reserve method does), instead, 1: returns Err.
Shrunk tiv fit“ ‘J Reduces the capaclly Of the VEClOr t0 match the EXEC!
number ofe\ements from (he vector.

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
®/ Vectors
Output
_ 4 “5:0, Ewan/:0, H]
Example usmg prevmus methods. s\ze:2,capacity:4,v:[1,2]
“9:3, czpzclty134, v:[1, z, 3, 4, 5, 5, 7, 3]
Fn add v‘ange(!:&mut Vec<1$2>,start:152, end:i32) ( MES’“mamaV:[l'z'3'4'5'6'7'8]
for‘ i in start.,end+l ( Mwm; } WEI" capa"“’:3' ":[1' 2' 3' "1
prinrlnm u (1* w} $1Mmidwnyolw;
)
frv mm) (
let mut y : Vec::<i$2>::new();
PrivtlﬂW U U {1?} .14WHOJLHPHfiWOJX);
dud \‘avvge(&mut g, 1, z);
gmeservew);
addimngvﬂmut y, 2, x),-
1.5hvunk Lo m0;
println!( n (} m} ,1,\vn(),!4rnparify(),!);
!.Lv'uvadLe(/l);
printlﬂﬂ U U (I?) .1‘ler\().1~<ana@ty(>,y);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
5/ Ve cto rs
Ompux
. . “2:0, capacityID, v:[]

Example usmg prevmus methods. m4, capacityj, v:[1, 2]
“9:3, czpzclty134, v:[1, z, 3, 4, 5, 5, 7, 3]
“Fa, capacity:8, v:[l, z, a, 4, s, e, 7, a]

ﬁn‘ i in Start..end+l ( v4pu§h(i); > “ZEIA'capac"v:3"’:[1'2'3"‘l
A close range can be enforced by uslng .1
for i in start. .:end {1.Qush(i); }

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
Vectors
Keep in mind that transferring a variable into a vector might imply
change of ownership (in this case after - is executed, variable
“t” lifetime has ended as a result of "t" being moved into the vector),
#[deriVEK i] q l it, i Z Min i 1,.1. ‘mi
'1; < .~ : ::new( ); i ' In“ mm mi;
t = “115,131.31 i3: ‘A‘ i; l; l pmmlllll Z l )llllllilillvn borrrwmﬂ herr a'kr mam"
laugmr); ' ' N '
("SiZQ: , capacity: , v: ",i.len('),l.capacityi),xi);
("r : ‘no;
l

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
a Vectors
However, if we implement the Copy trait, the code will compile.
Rust
#[derivefDebug,CODMCloneH
rtv'm't To“ ( v1: i32, V22 {32, V3: Chm‘ 1'
+1‘ maimj) (
\t-r nun y: Vac-Test’) : Vec::new(_);
let t : Te;t{v1:5,v2:1.3,v3:‘ w};
ygusmtt;
pm wtlntg'“ w»; 1, ' mtt'ttyil 1, 17}:11‘,1‘IEMLXVcaPacityLLXJ;
privtln‘(“t awn);
t
919:1, Capacttyﬂl, v:[Tes\(v1 s v2 13,v3 ‘A’ )1
t:Test(v1:5‘vZ:13,\/3 ‘A‘}

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
g Vectors
Let's compare how effluent vector push method IS for both C++ and Rust.
Extern ( mnclxda

m m7 "Womb?" [) V> m; mm“
> mm M (
m Edi-W» <> r> W t 1va v1‘
unsafe { ("VUJEMJrumO ) Host v2;
7 1mm; v3,
ﬂawmnebnmmwglmn] mm; “[716];
“PM m { v1, NJ v; W, v; » v4 [WM > ;,
m W0 Q vmd m0 <
m mut g \E(<'k>(7 Z \ELIIHMO, st.\:'vector‘<Test> v;
1n t 7 TEST(V115,VZ 1.2m: ,vA:[iEJS;Z§a-]); Test t,
let start : I!" MVIO; auto star-t : art’ rkfamtml);
W ) V w" W W, ( m (am 1 7 V, x < WWW, 1..) (
ELM» MM ‘Mm,
) >
let End = Q: @121), auto End 1 Gethmlourtmﬂ,
WWW n ,end'start); Wm xa , (mum V mm);
) )

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
E; Vectors
Both codes were teste in the same environment, for 10 times and the
average was recorded. All tests were run on x64 architecture (Debug and
Release). Times are measures in milliseconds‘

Keep in mind that GetTickCount function has an error margin of 16ms.
CH»

(Debug) 2552 2552 25m 257s 257a 251s 2552 257a 2562 2547 2568
RIISR

(Debug) 1922 1544 1550 1842 1812 1813 1797 17:1 ma 121a 1831
CH

(Release) 1szs 1751 1797 17:1 1781 1751 1797 1797 1:21 1797 1796
Rust

[Release] 175m 1750 1m 1719 1537 17u3 1712 1537 1703 1587 1709

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
g; Vectors
As a general conclusion, when it comes to vectors (and copying object not
moving them), Rust is fasterthan C/C++ (in both debug and release
modes).

We should point out that the build that was tested for C++ was compiled
with Microsoft compiler (cl.e><e) and it does not reflect results for gcc or
clang (that might optimize the C++ code in a different way).

However, the question still remains on what's different in Rust vs C++ in
terms of how vector works ?

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
Let's see how Rust allocates memory for the previous case.
Dutplll
WM “M
v1: 131, SiZEIUOODUDol,CzpzcityICIOOUUOOII
v2: m. SizeIOOOOOOOS,CapaciWIOOOOODOS
if E 1:: ‘i f 1 S\12:00000009,Czpz|:|ty:ClOODUOlD
} ‘ ' Sx1e100000011,Capacity:00000020
in who < S\12100000021,Capac|\v:00000040
1n m g .Emzm V .H mm, ,
let t : TFET(V]I§,VZIT.§,VZI ,vA:[’8J'<;7’>ﬁ]); v 7 v 7
m M U am V 1" ,W, “,0; S\1e700040001,Capacny700080000
M 1 H‘ HWJW < S\ze:DOOBU001,Czpz|:|ty:ClOlDUOOD
g. Mm. Sxze:00100001,Capacity:OOZUOOOO
1*} ‘ * ! fwd/U‘ Size100200001,CapacltyIOOADDOOU
1r (>(Epitlty (
me Mm (wa} 1w“), ()J S\19:00400001,CzpzcltyIClOSUUOOU
(awn! Z <, S\1e100800001,Capaci\y:01000000
\
\ ,

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
Let's see how Rust allocates memory for the previous case.
Output
Wm M < > >
v1: 131, Rust use; a" allucatorthat S\19100000001,CzpacltyIUOOUOOOll
v2: m, doubhsme capacity withthe SIZeIOOOOOOOS,CapacitVIOOOOODOB
: m; . ' i 7
ii ELK/""71 stancapaclty Df4e|emems_ S\M7000DUOOB,C2pa|:!thOODUOlD
} Sx1e100000011,Capac|ty:00000020
in W0 < S\ZeIUDOUUOZ1,Capac|tv:00000040
let mut g Ham 7 .E( :rsv.(), >
let t 1 r»;:(v1;s,vz:w 1,vz; ,vA:[’8J~‘;>’>ﬁ]); v 7 v 7
m M, U am , 1 t W mo, S\1e700040001,CapacnwOOOSOOOO
m t H MW)“, < S\ze:DOOBUOOl,Czpz|:|ty:UOlDOOOU
y. MU). Sx1e100100001,Capacity:00200000
1?‘ ‘ ’ K :“at'm” Size100200001,CapacltVIOOADDOOU
1~ (Kapwty ‘
mm“ {W} ( W} ,1 W0, ()J S\12:00400001,CzpzcltyIClOSUUOOU
(agauty Z <, S\ze:00800001,Capacity101000000
\
\ ,

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
, .
Let s see how C++ allocates memory for the prewous case.
Output
“W My 5112195688691, (auaoty:BHBHBBm
5mm Eat ( >11e Mammal, Lapacny ammmml
m v1; madman memwm
ﬂoat v1; inﬂame“ (aunnzweneﬂnem
Hm, ‘ V, WWW‘, WMHWW
7,. v ' k SlzcwHGBHBEL(aDa(1ty:BHBEBBEP
“‘ U “Mb sue nuaeuuuﬂ, [apaclty auuunmm
L. mezwmi, CWWWBW
vom Mimi) ( Slzc'BﬂGBEBl/h (aunnzweneraaeu
Sm ~/e<w-<TE;:> V; “WWW, WWWWW
W t, WWW. (auauty:BHBBBBBV
M, “WW Z , w, V
, W‘ sigma”, (WMQWM
v :wumm, mwzwmm, “pmmmmss
auto c 1 v.:nv1:1ty(), sunqamsnsﬂ, (apnoty:BHBS7QEJ
1m: > (Wanty) l
N HM zssx ‘max >(..H,U>v,~,m(>, (“mum
(Emmy Z t;
>
\

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
, .
Let s see how C++ allocates memory for the preVIous case.
Output
tn‘ hm“ Suewﬂwﬂeul. (Amati/195695981
mm mt ( >119 WWW, Lapacny 621%an
m v1; - “lemma, capazny:eaeewa$
no“ v1; C"ha"d'ﬁremm'eﬂvwhemhe mmmm WWMW
‘WU 7 V3 growth factor ls 1.5 (forthe cl.exe/MS mm:nazaam§, WMHWWE
v. ' t - - SJzQZBHBQHBEL (Amati/185895959
, w “W 1> 'mvlememaﬂﬂ") mm
h‘ Sueﬂwwﬂaai, (auecny:eaeaw813
vom \viJvL) ( sun'eanaamm (achIIV'BEBﬂBBJC
Sm wed/:PUPEU V; “,ﬂzmmw, WWZWWA
We t, WWW. (mmmmw
M, mm,” I , ‘m, V
v 7 ,t WWW, memm
v Jm$at<<t>¢ mwzawma, (dwmwzwmss
auto c 1 v.:ny1:1ty(), sunqamgnsw, (apaotyqsmxswz)
v‘ (c > canauty) l
,t HM zssx ‘max NHWUWWKO, (“mum
(Emmy Z t;
,\
\

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
E; Vectors
So the difference lies in how growth algorithm works for those two
cases (Rust and C++).

lawman
lumnnnn
14000000
mum
gmwnuuu
§ mnunn
u sounnnn
mm
2000mm
D =1:QQQQ=====qaa===nnaa======aaa
mm

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
®/ Vectors
So lets see the behaVIor If we reserve the memory from the start.
extern ( Mm imp
m 5w (\rfmmté" 0 V> m; mm m: (
) )rvt v1;
hr grli'uw () '> rm 4’ ‘luat v1,
unsafe { (Y'V\)~<[\,AY‘L114<) ) mm , W
7 “mug vAL/H'wj>
Wm\Q(webw,cwy,:1m)1 )2
“mfg Hr { v11 vwz v2 H), v3 An", v4 [my 4'] ) volﬂ trawl) (
r" Wu t , , 5U: vectur<Test> v;
m mut g \E(<'k>(7 Z \ELII.v)\t‘7LAP.ALA,y(197¥1t1@78ﬁ@), I,“ ‘I
1n t 7 TEST(V115,VZ 1.1m: ,qu'AAnx-j); W‘w,lemmm
let start I wt “"0; auto start 1 muttmwtm),
w 1 m w w" MW’ MW’, r {or (auto 1 7 a; 1 < woe-2002, 1+») r
bum‘ “my warm);
t >
let and = zev MEL), gun; eml Z m (kKnu'v ~10)
Pri"t1"‘( n twisterw: Wm m , (1Ht)<end V 5mm,
)

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
g; Vecto rs
Test were performed in a similar manner like the previous ones (Debug
and Release, 10 iterations and we compute the average).
C++

(Debug) 7122 755 751 vee 731 755 797 797 aza 731 784
RIJS!

(Debug) 924 1094 1063 1031 875 1032 101s aso sue 359 972
C00

[Release] 547 531 S31 515 500 515 516 500 531 531 521
RIISR

[Release] 532 sou 531 516 551 531 547 5A7 547 515 532

Keep in mind that there is an error margin of 16 ms for GetTickCount APlv

This means that the difference between C++ and Rust is insignificant (w

can consider both at the same level).

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
Vectors

To access an element from an index in the vector use the [..,] index
operator. if the index is out of range, the code will panic.
Rust
WWW‘. .‘i

lzl .

,1 . rnwiluswl: mm W m w 1m st ttmw
' limit i, l i I

“puihi, 4,1:1,1:4 :.,;:':u, 7 [15,::i;];v;t; i maes- W mmw m tam tmn
l Z m; l my- WWW WWW rm Lia}

In this particular case, the code will not compile because the assignment is
equivalent to moving an element from the vector.

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
. Vectors
There are two solution to the previous problem: m
1. borrow the value of the element from index 0 w, , v, 1‘ ,1 m. N
M.l1;,15,15,15,15,15,15,
RUSI 1;, \§,1<. \§,1<, \§,1<, \5v
a l: l "1"“ 12.15,“. 15,12 15,1215,
r 1‘ 1;.’ Twain]; [I .77] 151;
,.puiil, , = , >14 HM: .4 , 7 5,,» H;
l Z M‘
El

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
® Vectors
There are two solution to the previous problem: m
2‘ implement the Copy trait for structure Test w, , v, 1‘ ‘,1 m.
M. U5‘ 15, 15‘ 15‘ 15‘ 15, 15‘
a ""1 l“"-35;‘l 12.15,“. 15,13. 15,1215,
Jr Wli g 1w: .Teftvnnewl l; 1s! l
‘ r I L/lﬂl;
‘mull mm.

***************Ending Page***************


***************Beginning Page***************
***************page number:112**************
Vectors
A vector is iterable (for read and write]:
RIIS! Rust
Waim,‘ 1 WYEJHH 4'
w \ m‘ in. m 7 1n!) "L;
} ix: v‘ i*‘;,‘ H
1“ w; m m ;

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
A vector has a special function [cail retain) that can be used to keep only some
elements that have a speciﬁc characteristics:
Ream; e“ elements that ‘e, Wm e Melee
Rust

Wm‘ n .e L 1

Malwi 4

,e n,:,:.,4,s];
y-r-hnmurhiii

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
Vectors can be easily converted into slices (much like an array can). We can do this
via the range operator u or via asisiice[) / asimutisliceﬂ methods‘
Rust
in Sumrliiti Minn-43:;
r r 1 1m r 5W: 41
x“: “M Z r5. ,1. w]. Vim Z w
\‘etttir IL1>H‘3"4‘1'3,V2,~U
i
H'i malm) i
1m W 1 Z tifi:i[1,$,3,q,1g,5v4];
L ytlrrM'“: H 7 'i“.-;m"r1.a;;11m‘m;
tr r 5mg : alums];
r‘ mm“ ii‘ 1 ii i. ii 7i ,511:e,;un\r§11:e)§;
r""tir'i‘i“i.—i’rr' 7; i ‘y;
r‘

***************Ending Page***************

***************Beginning Page***************
***************page number:115**************
® Vectors
A vector can also be s lit off into two parts resulting two vectors‘ For this use the
method i-
Rust
mam) r
i“. r w'r. “,i,,;.rsaparsityii'i; i~:[a, .t, :1, ‘swing.
i
In this case, we split frorn the index Z (meaning that the first two elements will
remain in the original vector, and the rest ofthem will be transferred to another
vector).
The first vector capacity remains untouched (in this case 5).
Keep in mind that this method creates another vector (and allocates memory for it).

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
g; Ve cto rs
A vector also has a set of methods called drain that can be used to remove some
elements from the vector based on a specific logic or range.

i in“ ‘ i» "t r» Removes all elementsfroma vectorwithin a speciﬁc

I ) ' range
'i on Hit‘: ' Z , tilt»?! v l w Removes all element irom a vector that are filtered
~ 1 , l v byz glven function.

Note that drain methods return an iterator over the elements that need to be
removed —) and if used in conjunction with the - method from the iterator,
these methods can be used to split a vector in a different way.
’ drain Jilrer is considered an unstable feature ( we will not discuss about this method)

***************Ending Page***************

***************Beginning Page***************
***************page number:117**************
Let's see some examples:
Ru" Rust

1mm ,\ "111MB ‘I

: [1,:,;~,4,51; 1: [LAID-MS}:

“GPHJHLZHH y: ‘ _~, : gamma.4401mm:

g i’ K“ 1L‘);
}
[4- 5]

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
Vectors
Its also important to notice that drainiRange) method keeps a mutable reference to
the vector. This is more efficient as it does not allocate extra space for the elements
that are being drained‘ It also means that if you obtain this iterator, you can not
modify the existing vector until you consume the drain or you drop it.
Rust
mainll I‘
;: [1,1,3,4,5];
tr : ;.dr‘airr[:3..};
if e >1; i irrorllitﬁul 1 cannot: mm. l as )rimutat'li? may» 1t 15 at:
l V Mutable ticrvcn lam llﬁllﬂ new;

***************Ending Page***************

***************Beginning Page***************
***************page number:119**************
7
Sorting
L

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
g; Sorting

One of the most common problem when dealing with data sequences

(e.g. a vector, an array, a slice) is to be able to sort them.

Rust has several sort algorithms in place that take into consideration:
' lfthe sort is stable or not
' WOi'St C358
- Memory consumption
- Sort using a key /

***************Ending Page***************

***************Beginning Page***************
***************page number:121**************
Any mutable vector , array or slice have several sort related methods:
MethodWectnr/SllcelAmy) ma-
-l tls l Stable sort ll<eeps the order orthe equal
l l-l,‘ all; , Mll-am l elementslt
wt l‘.‘ l>tl1 l w. , g: l
t ll teal-‘ell le.< . Mt: l —'. l
-l tie“ .t lt, la l Unstable sort (may reorder equal elements).
alw‘l_llll'la1l' e_ll>,t we , lull-ale; ,l
eta-@m'tal' U2»; a_, , up: , :1 )
lam lLCl_St > Checks if elements are already sorted.
ll elm l‘,1 w , Ml .ll-t. jl >

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
Sort algorithms:
sort t Algorithm: iterative merge sort inspired by timsnrt
sort_by . Worst case: Oln‘log[n))
- Memory: for large vectors allocates extra memory (half the size of the vector]
- Stable: does not change the arder of equal elements
- seetter: nearly sorted sequences
sorl_by_kev srrnr'lur wr'th sun and son‘_by, except for complexity
t Worst case: Olm‘n + n‘logln]), 0(m) e thne needed to compute the key
sort_by_cached_key . Algorithm: pattern defeating quick sort
- Worst case: Olm‘n + n'logml), 0(m) = time needed to compute the key
- Memory: in worst case it allocates the size a! the vector/slice
- stable: does no! change the order of equal elements
' Guarantees: A key i5 computed at most one time

***************Ending Page***************

***************Beginning Page***************
***************page number:123**************
E; Sorting

Sort algorithms:
sort_unstable . Algorithm: pattern defeating quick sort
sort_unstable_by . Worst case: Oln‘log[n))

- Memory: Swap in done in-place (no extra allocation)

- Unstable: itmaychangethenrrierofequalelements
sortiunstableibvikey Similar with son and 5m, by, Except/a! complexity

- Worst case: Olm'rl + n‘log(r\]), 0(m) = tlme needed w compute the key
OBS: if elements order is not at issue, unstable sorts are generally faster
and require less memory than a regular sort. The only cases where stable
sort is recommended is if the sequence of data contains elements that a
already partially sorted.

***************Ending Page***************

***************Beginning Page***************
***************page number:124**************
g; Sorting
What is the difference between regular sort, - and — (or
the caching form of sort by key)?

***************Ending Page***************

***************Beginning Page***************
***************page number:125**************
g; Sorting
What is the difference between regular sort, - and — (or
the caching form of sort by key)?

Regular sort:

***************Ending Page***************

***************Beginning Page***************
***************page number:126**************
g; Sorting
What is the difference between regular sort, - and — (or
the caching form of sort by key)?

Sort by:
my \L\:‘U':‘H\ ,mwm 1
P E

***************Ending Page***************

***************Beginning Page***************
***************page number:127**************
g; Sortl ng
What is the difference between regular sort, - and — (or
the caching form of sort by key)?

Sort by KEY:
P E

Where KeyITI returns a VBWE mm IS
comparame {usually a number, a hash, etc)

***************Ending Page***************

***************Beginning Page***************
***************page number:128**************
s; Sortlng
What is the difference between regular sort, - and — (or
the caching form of sort by key)?

Sort by KEY (cached):
Where KeyfT) returns a value that \5
—---— Lomparahle [mueHy a number, a hash, etc)

***************Ending Page***************

***************Beginning Page***************
***************page number:129**************
Let's see some examples:
Rust
m maJnU -;
L #LlHWW H31);
‘1
and
RUSK‘
Fm absnluteivalueg'valueRUSH, r. 151 {
"
m maJnU \'
‘w ‘W x :,w‘[1,"),nrgﬂ‘7:‘,7'3,'3,3v,7r3,'1,j,*,8];
by)“ by Venabsolutejalue‘:
L :tlHHIW W31);
‘r

***************Ending Page***************

***************Beginning Page***************
***************page number:130**************
I
Sortl ng

Let's discuss an even more complex example‘ We will start by defining the structure
Student and a function that can be used to create such an object that WIN further
be used in our examples.
Rust
#[der'ner "1

u m: , ‘
‘ new: erJ-rLH'ul: A ,u'ihu Ari: . “71);, ‘r: 1 » -;

Mr ‘W n,

***************Ending Page***************

***************Beginning Page***************
***************page number:131**************
®
Let's try to sorta list of students:
Rust
main() {
:mew"Andre1",ln,x), WWW.” 11.‘
::new("m~dgos",s,19), H 1 MW‘
::new("80gdan",7,7), \ ~ (WW m W mka W 5mm
“"EWTlEPE'Vgﬂm W‘ W1 m, a W1 m m1 1W m
1; \
h _ 11: \ W md.
‘ :MO) \ ~ - "mum a, this mum 1n SJICEII'JWK‘) m~ 5m
|
m PammOrd
PartiEHEq

***************Ending Page***************

***************Beginning Page***************
***************page number:132**************
I
Sortlng
Let's see what imp\ementing this traits means‘
Rust
UHF!‘ ‘ \ 1‘ l "v l
_
}
‘ 4
}
mm , '\ a A‘ \ V ;
}
‘ m

***************Ending Page***************

***************Beginning Page***************
***************page number:133**************
After we implement these traits, the code compile.
Rust
main() (
IrHEW("AM1P6-i",l@v3>, My." t M" m. WM q, W W11 >
2:HBM"Dr‘agns",8,lw), 5mm 1 mi?" w mm» -, m! 50;an 1
,_ ,. H w Mm‘! ; my‘ a‘ me- m, Hm ‘Umtﬂ :1
--HEW( Bﬂgda" , 17)‘ 5mm 1M" s. enghgh m‘ M» n>>
::rvew("(lar‘a",9,l@)
1;
itsortg');
for 1 in 1 (
(H "15)
)
}

***************Ending Page***************

***************Beginning Page***************
***************page number:134**************
But what if we don't want to implement all of these traits for a simple sort 'r‘
W.“ “WW”
5mm awe‘: 4 math: Na‘ engllsh Ab, name: Sung )
m1 5mm q
F" mn~‘(studen€NamE QM, mathGrads ‘a, englishGr-ad: la) > Rmdmr ( l
l
m WRJY() l Output
15¢ mt y V ve(l[ mm ( lreth' 7, englnh v. me "mm" l
3mm =~~»< , m), 5mm < m" a. English‘ 1E, name. “Dr'zgu3‘ l
mm‘ ‘M mm, 5mm l "m g, cwghsh m, "m ‘(lal'a' l
Wm W,‘ >, sudwu < mm w, Wm“ g, "W mm,“ )
Smurl 1m.< mm
1W: J, ‘(w/(h mam; lnthis cases, using sort_by_lwycombined witha
m 1 T" g \, lambda function is ideal, especially "we want w sort
) wwww l w .17 basedan:fieldfmmthestructure
l

***************Ending Page***************

***************Beginning Page***************
***************page number:135**************
g; So rt| n g
Other methods related to sort methods:
Removes a" consecutive gamma‘ are was.
mun r, m: v "run" al'l 'r: ‘l Removes allconsecutlve elementsthat belong to the
same bucket (based on a functlon that determines ‘r
an element l5 pan of a bucket or not)
""1"" >1 "w v ‘W , L: r Removes all consecutive elementsthat have the same
key.
All ofthese methods imply that the element in the vector is comparable (has the
PartialEq trait),
Dedup methods are in particular useful when used after a - command.

***************Ending Page***************

***************Beginning Page***************
***************page number:136**************
® Sortl ng
Dedup methods (Vectors):
mm
"mm ,\
i.nemnl\:
(“17mm m» “.iv:
v
In this case, the following buckets were reduced:
‘ [.2,2,z,5,5,7,71-) [l2,5,7]
- l1, 1, -, 5, s, 7, 7] -) [1, I, s, 7]
- [1,1,2,2,2,.7,7]-)[1,2,l71
- [1,1,2,2,2,5,5,-1-)[1,1,5]1

***************Ending Page***************

***************Beginning Page***************
***************page number:137**************
Dedup methods (Vectors):
RUSK
Sortimndulniﬂ‘ﬁlm?It} H 1
dedupimnduluih'shwzk w -; Mum \edrr- [1, :1
1‘\.=.\Hv) ‘mi
» l
mainfj Q
,1 [1,1,*,1.5,1,:,5,*];
Lsort n» ksﬂsortimaduluilh Module; 1 1 1 1 z z 2 2 z
Wsmted vertm‘: “,g;
Mann b" keyfdedupjxodulnj);
(“02%an mm»; “,iy;
‘r

***************Ending Page***************

***************Beginning Page***************
***************page number:138**************
. Sortl ng

Dedup methods (Vectors):
Rust

;: [1,1‘.,1,‘l,1,_',‘=‘.];

(“Slilrtcd \mttm “.u: MUM mm‘ [1' '1
£119le m kewl lil (1i) ‘a 91;
(“Heduped “Elem-1 “,il; ‘
Module! 111111221

The same result can also be obtained via usage of lambda functions/closures [like
in the previous example).
We will talk more about closures in another course’

***************Ending Page***************

***************Beginning Page***************
***************page number:139**************
g; Sortl ng
Another interesting method (related to a sorted sequence of elements) is the
ability to use a binary search to quickly find an item (in O(|og[m) complexity). This
methods can be used for Vectors, Arrays or slices.

All ofthese methods should be used together with the similar sort functions (e.g.
use a binary_search_by with the sort_by or sort_unstable_by) and with the same
function as parameter.

***************Ending Page***************

***************Beginning Page***************
***************page number:140**************
So rt| n g
Let's see some examples on how to use binary searcht
Rust
hem t
t; , .blnsvyisearctvIISt-J)jt; em;
I“ ‘X,.binarwieearTMK-JUUJJ; :73;
t“ ‘y,.thhet-y;eehtht_h>\w>1 "
t‘
The binary search function returns:
- I (with the value the index vvhere the exact match was found)
' I (with the vame of the dosest index to the va\ue that was searchedl.
Obs: Natlte that. -t7! I In Rust, h Cunstant VU/IIE is not implicitly converted mtg h cunstant
reference I/ke in C++ (you have to exp/ic/t/y say you want to do this)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:141**************
a Sortl ng

Let's see some examples on how to use binary search‘
Rust
rm rriainii I‘

5.50m w kevllll rm 1i; [1,a,1_-\.7.1.§,'1]

r‘ mum We]; ‘PM’

,w 'tln‘l“l l“,i-tiiIiaWisEer'rhihyikeywﬂ,ljl ('1) s a)»; Ellf'l',‘

r ; tlnli“i Yi“,5.Lunaruiisearwhibvikevit}!,lil ('1) 13>); [Wl'w

r ,rlrrugw "l“,ginnaryiscarihibyikcyi'ﬁl.lll ('11 '12)};

r , will; i 'i ,5.r,mw;gay-Lirivyiiiayrm,iii W1) m;
Keep in mind that binary_search_by_key receives for the first parameter a key and
not a value‘ In this case, possible keys are 0,1 and 2 (everything that module 3 can
obtained). That is why, the first 3 searches will end up with 0k, while search no 4
(for the value 3) will return Err as any value module 3 will never result in 31!!

***************Ending Page***************

***************Beginning Page***************
***************page number:142**************
L
ash aps
H

***************Ending Page***************

***************Beginning Page***************
***************page number:143**************
g; Hash ma ps
Hash maps collection of elements, where every element can quickly (ideally 0(1)) be
access via a key‘ There are several implementation possible fora Hash maps; Rust
has a specific object called HashMap (like std::unordered_map) from C++ standard,
Rust implementation (a variation of httgsﬂabseil.i0[blog[20180927-swisstables)
To create a map, use one of the following forms:

a)

b) let mut a I HashMap::<kev,value>::new()

c) let mut a: HashlVIap<key,\/alue> : HashMap‘:WItchapacitylcapacity)
d) let mtit a: HashlVIap<key,value> : HashMap :frornl[(key,vector);c0unt])

***************Ending Page***************

***************Beginning Page***************
***************page number:144**************
Let's see some examples on how to build a hash map.
Rust
H, Caanh/IB, \terWZIO
m main!) .’ {LCaDamtwlwemwO
Emu : HashMap: x132 1323mm“), Hahn".lﬂ,“M\ke"er),"Gemge“ 30),Canac|w:3 MW;
m m2 : HashMap: :<&Str‘,i32>:Ivlithicapacitwilﬂﬂ');
1'» m3 = HashV-lapnfromﬂ
(‘ mw,1e), (‘ Me“,ZQ), (“we @9320)
1);
printlvl(“‘|*",‘, ijmuilv :5 11m H‘,mlmllmapacityU,leenU);
fr‘\nT\r"(“-} u, ‘1;'\.'w\",:-{ ‘ vival",m2,n13.capacity(),mZ.len(‘));
wmrlwu-plg», when, 1|" iL'H I,‘>",m3,m3.capacjty(),m3.len());
)
Obs: Notice the use ofstd::collections::HashMap (this is required tn use a hash
map).

***************Ending Page***************

***************Beginning Page***************
***************page number:145**************
H a s h m a ps
It is important to notice that the hashing algorithm use rely on a
randomized seed, This mean that consecutive execution of the same
code will result in a different order of elements in memory.
Ruil‘
mainil) (
for i in mil
m3 = :zfroml_[("]uhri“, 16), Fluke", 30), ("George", 35H);
l" , Capacity: , items: ", iii, l'iJuCHDatitylHly l'LulEViQYl;
) >
("Miw 20 HGCOVgC“,3U,llJOhH“.10),Cap3ti[v:3,illlm>:3
('6ng 30‘ Mum“ 1t» “Mlké” zai, (Austin/:3, time:
("Jnhrw“ w “George” 20 “Mlle” 20,‘,(aparity13, “my;
("Genlge“ 10, "Mike“ Zi'i, “John" 10}, (spam/:3, itémwi
("Gsolgs“ an, "Miw 20,“iolw”.10),C£|p:|u!y:3,item?!
("Jahn“ 10‘ “Miw 2n, “610mm so), Capaciws, items’!
("George“ 30 Warm“ 10 “MAE”ZOl,Capai:it\/:3,it2rn§:2

***************Ending Page***************

***************Beginning Page***************
***************page number:146**************
®
Basic operations for hash maps

weeme , \ : . ‘,1 > e,» ,_ = lnsertsa key/value pairintothe hash map. lithe key
emsts m ‘he map, None \s return. lflhs key emsts, It ls
updated, and the md vame is returned.

get (>1 - L: 54 ‘v "I 1& l Get a reference tolhe vame associated with a key

get mut (a , L: s J -: <5 ;>

mum/e (1 , \ : s. > e) < = Removes an elemem from the map an rewms its
vzme.

clam-(5‘ > Gears all key/value pairs (em keeps me allocated
memory for future usage].

***************Ending Page***************

***************Beginning Page***************
***************page number:147**************
Let's see an example:
RUE!
mam) .r
U : :zfmmﬂ
("30hn",l~3), ("Mike-“,ZLIV), (“Geol‘ge",59)
1);
("10m 15 in m; ",lxontainsikeﬂ"10hn"));
D.insert1_"vincent“, 20);
(“ ‘Hm:
(“Value +11,‘ ‘Nike’ is = ",U.get11"Mm"'m
‘wast mutL'"Gem*ge").um-n‘ap() = 58:
(" ".m;
> mm—
Juhn W m m‘ "us
“('th 10, “\"leCEMH 2D, “GGOVEG'Y 30, WING" ZU)
VaMJL' VOr ‘MMC' V, . SquZU!
Plum“ 10, “vlmenﬂ zu, “Gsurgs": so, “MUG”, 2m

***************Ending Page***************

***************Beginning Page***************
***************page number:148**************
®
One of the most used method for hash maps is .entry():
entr'Qk . ‘1w: > e> ~ . > Relurnsaslruc!ure(£ntryl that can be used w modlfylhe
value of a key.
Entry struct has the following methods:
erdinlmUryL . ' l V.‘ Changelhe value assuclated wltha speuflr key wlthavalue
returned from a funcllun F
urjnsentl l viral et: ‘l r: H Returns a mutable relerence m a value 01a speciﬁc kev If
that key l5 not present, l! Wlll be msened and sel up Wlm a
default value, and then the reference m that default value
Wlll be returned
allinserwiwithl , \‘ét'l it: ‘l ' -' f4 Slmllar to or_lns:r2, but uses a function deliult to Ielulrv a
er insert with re," -l , l PM’: ,l ~ 1: value

***************Ending Page***************


***************Beginning Page***************
***************page number:149**************
a Hash maps
Let's see some examples on how to use .entry() method:
Ru“ mm_
En main() ( .‘ H H ‘. ‘ h H ‘
1-:L m Z Haghmap;Momqpmu‘,w,» r‘ ‘E-
Eventr(“\rhn‘).andimodify(‘Q { g : -_ + w; J) (“we 3° "‘ "' “m ‘0'
w mtlr"("‘|m: w),-
gentry“whm“).andevodiFyUg‘ { g : ‘5 + 10; y);
;‘r‘1nflr"(_“}|u: "1“),-
}
Notice that if key is not present than .and_modify(..) has no effect!

***************Ending Page***************

***************Beginning Page***************
***************page number:150**************
a Hash maps
Let's see some examples on how to use .entry() method:
Rust
m mainU (
12L ml m = Hdihmap::fr"om[_'[(“]»hu‘,16), yummy), (“gm Amman);
let 30m value : Mantryf ‘ mm “Loriinserﬂlﬁllj;
;"r"1r'\flr"1_“jwhr ‘\jomuraluev);
1-:L alice value : m.er\n~( gnu“)‘or_insert(2ee>;
fr‘\nf\r"(“'\\\f\' : laliteivalue'f);
) mm: 10
BIHZEZZUU
("JDNH“ 1U‘ "6“:ng 30,“AMLE“ EDD “Nhke”. 10}

***************Ending Page***************

***************Beginning Page***************
***************page number:151**************
Hash ma ps
Keep in mind that the value returned by .0r_insert(...) method is a
mutable reference. This means that for example you can not use the
hashmap as an immutable reference while that reference still exists,
RUST
liming) i
1 : :zH~oni([i“lam\",1a), ("i\iii\e",2~3), ("Geor‘ge",3€i"i]);
Jilin mi if‘ : u.e|it|‘¥("]0hn",i.nriinse|‘t(29iii‘i;
i" ‘3111;
("john : 1mm will; ".i;
\
l iViHLJUlL‘ Uuiiuu until’ View:
ti BHviHviii i ‘i .mi,

***************Ending Page***************

***************Beginning Page***************
***************page number:152**************
Hash ma ps
Keep in mind that the value returned by .0r_insert(...) method is a
mutable reference. This means that for example you can not use the
hashmap as an immutable reference while that reference still exists,
RUSK
Iilﬂiﬂl_) i
1 : : :H~onv([i“1mm",1a), UMike'gzﬂ). ("Geor‘ge",3€i"i]);
Jam-i mi if‘ : u.entl‘¥("]0hn").nriinsel‘t(29iiii; M
("john a li'JWVLwt-‘ltl! ")z
L" ", l); |u|w:10
) i i“Geurge“: SD, “Mike“' le "Jnhn“ 10,‘
In this case we have reversed the order of calls (first we print
john_value and then m), This will work as the lifetime ofjohn_value
ends after println! Macro.

***************Ending Page***************

***************Beginning Page***************
***************page number:153**************
a Hash ma ps
Let's see some examples on how to use .entry() method:
Rust
n‘ mam) (
1M w: g : HashMap::¥rum([(“1 \hu‘,18), ("an \ “,20), (“w 1;; “,BBH');
gentriﬁlmn‘:1.or_inser‘t_with(|| we);
fr‘\nT\r"(“}nr My‘);
mentryﬂﬁliu ").m"in$er‘tiwith( |\ we);
w mtir I(“-:m:'>‘1'“);
gent'yrfv w‘ ).erinsertiwithikey(\keyI keyienn);
) Noun". 10, “MWQH ZU, "chrgu" 30)
gum“; 1n, “651"ng 30, "AIME": 100‘ mm“ 1m
y'“luhn"‘ 10, “George" 30, "Al\(e"* 100 "N1\ke“ ZO, “Llam" A)
OBS: .uriinserti withikeyﬂn) uses afunctiorl that receives the key name and returns
u value (in our case “Liam” has a size uf4 chars).

***************Ending Page***************

***************Beginning Page***************
***************page number:154**************
a Hash ma ps
One of the most common usage for .entry() is to count elements from a
vector / array. The solution is to use .entry(...).oriinsert(.t.) to first
insert and initialize a string in the map, and then increment the value.
m mm-

ltt mt m : Hashi'lapttnewt');
let v = ["35 l i“,“¥\1lt~“,‘ 10 l l ‘,‘i-‘ll "H,Hi"\llL"“,“]Jllil ‘,“Ll W];
w t Vii v i
‘m.entry(k).oriinseﬂzl'ahil;
i.
[JV'ii'it nii‘ im- W“);
l

***************Ending Page***************

***************Beginning Page***************
***************page number:155**************
® Hash ma ps
Hash maps are iterable:
Rust
rm main(w <
191 ‘m g = HashMap::ﬁ‘om[_'[(“JMHWJG'J, (“mrﬁzag (“\E:L\\“,;)>:“,ZB)]);
m i w E (
} (“GeorgeT 30]
) (“Juhn",1[!]
Mme" 20)
You can also use .keys() to enumerate directly through keys:
Rus!
F” majn() 4
l-Et rut m : HashMap: from[(“Lwhv\“,10). ("U1\e“,2€1), (“L-rt" ge“ ,38)]);
w'luLln‘L"1'."¢",i); “M|ke“
} "George"
)

***************Ending Page***************

***************Beginning Page***************
***************page number:156**************
Hash ma ps
Keep in mind that iterating through an object moves the key/value pair
instead of returning a reference:
Rust‘
mainrv (
m : ::+mm([
r ::f|‘om(_"key'1"), ::f|‘om("]uhn")),
[I ::f|‘0m("key'2"), ::F|‘0m("I‘-Uke")],
r :2fr‘om(“key-3"), “from "Marr‘y")),
1);
1" ",\ n r
L \ r 1M W V “My mm
(" ",nv); r W" W W MM.” rm W W,
r W Hm M .1 m. mm. L.“ .1 m mm
\ ' mm tw'r M1 mm mm- n m

***************Ending Page***************

***************Beginning Page***************
***************page number:157**************
® Hash ma ps
The solution is to iterate over a reference of that object instead of the
object.
Rust
+1‘ maim (
let m : HashMap: :+r‘om([
(String: :fl‘om(_“\ ~\,'1“),St|‘ing: :f|‘0|r\(“'\'hn“)),
(string: :froM “r; ) ,5U‘iv\g: :me “mt-“)1.
(String: 1mm“ .“),St|‘ing: mwmw v10 1).
1);
r w 1' it m r
wmﬂnw“ :>_;“,i'>; "\“ i: r~ ﬂpr \fﬂtr'w'rgﬁmtringb
2»
\ (“kw/'1“ Worm“)
I (“kw/'2“ "N'We“)
(“kw/'3“, "Marry"1
{“key’1":“luhn'\ "keyw-“Mrkeﬂ"keyaWMarer

***************Ending Page***************

***************Beginning Page***************
***************page number:158**************
® Hash maps
To get the map capaCIty and length use .|en() and .capauty() methods
RMSI
Fm mainU L
1‘: m : Ha;h¥‘¥ap:'ﬂ‘mvu_[
(SLvuvvg::Fv*uuu_'“\ 1 luSLriupiﬁmmy :1‘ ‘n, M
[Str'lngIIFr-nm(“\— _ ),str1ng;=+mm4 'm- n,
[Str‘1ng:.ﬁ‘0nv(“\Y'.'\ ),Str‘ing::¥mm( w, y),
(Strlng:‘ﬁ‘oml_“\ 'v.5mng;:ﬂ~mm hum»).
(SLPUYQHFPUHHIW luSLrirvgiﬁromy L‘ .w “>3,
[Str'lngIIFr-nm(“\— ),str1ng;=+mm4 ‘a! w “n,
v>wmg::me“\- V: ),srmng;;hwm( Mr “ij
[Strlngt.ﬁ‘onv(“\ ),Str‘ing::¥mm( w. n,
1'1:
‘muwg' ‘1. “J :1.‘ up}; ,vmr'apar'ityll), m.len()y;

***************Ending Page***************

***************Beginning Page***************
***************page number:159**************
® Hash maps
Use .remove(key) to remove a key from the hash map‘
Rust
m mam J
M W m: HaihMannFrwvvﬂ
(Striﬂgv :ﬁwuj“ \~>m“),1u\,,
(Str'mg :Fmvm_“¥‘\ Unzl,
(snungnfmm“1w 7m.
(SLr'mgt:H‘um(“L MIME),
($h‘1ng1:+r‘nm(“~2 m-w",,<),
1?;
LL'tanVm V m; r . v m“, :‘1“,m.|‘ervm\.'ef may»;
L 4&1ij r m urn” ‘uh J, ‘V -; P ,@.r*2m0ve( mm»: n;
‘, mm?‘ m 7 “"353;
Remuve Nhke » wnh value SumelE)
Remove Drags; V, VMUV vama Nuns
HashmapIPNIanv“ 4 “Andy” S,“luhn"'ll),"Andre|“ 5)

***************Ending Page***************

***************Beginning Page***************
***************page number:160**************
® Hash ma ps
You can also use ,retain(predicate) to keep in the map only the
elements that match a specific criteria.
Rust
t
ht mam t
1t L Wt m: >415hHJp::Frunu_'[
(Str'ivvq::+r"cm(“\wtvtt“;,1€!;,
(Stmng.:ﬁ‘0mk_'“¥'t w),a1‘
15'3’)th:t'r‘0rnk_“¥"w, ‘Mn,
(Strﬂngﬂﬁmnﬁt ‘13"1931,
(stwmgwirmtu L1 mm),
]);
mmetalmblggerlthanix‘);
t ;-r1n\<“; Wm);

***************Ending Page***************

***************Beginning Page***************
***************page number:161**************
® Hash rna ps
You can also use ,retain(predicate) to keep in the map only the
elements that match a specific criteria.
Rust
i» W m: HaﬁhiiiapHFrﬂiiiﬂ
(Sti'lngv malty ii'iiin“i,,lﬂi,
(Sti‘1iig':ﬁmii(“i‘i Jim,
(Shungﬂfroml iU r )JJ).
(3L!‘Hiq1:+i‘0m(“; ‘whey,
lswing.:ﬁomijW'i-iii- -i“‘y,=),
1i;
m.7|2taii\i_lk,l| gm;
L 4mm; i mm);
The same result can also be obtained via a closure/lambda
function.

***************Ending Page***************

***************Beginning Page***************
***************page number:162**************
7
HashSet
L

***************Ending Page***************

***************Beginning Page***************
***************page number:163**************
g; H a s h sets

HashSet type in Rust is implemented over a HashMap with a value of type I 9 a
ZST type thus making sure that there is no extra memory allocated for values,
To create a set, use one of the following forms:

a) let mut a: HashSet<type> : HashSet;:new()

b) let mut a : HashSet::<type>::newl)

c) let mut a: HashSet<type> = HashSetJWIthicapacitylcapacity)

d) let mut a: HashSet<type> : HashSet::froml[<type>;courit]l

***************Ending Page***************

***************Beginning Page***************
***************page number:164**************
a Hash sets
Let's see some examples on how to build a hash set,
mt
:1:\1,1 4,5,5)

m mainl') ( 52:4)

12L $1 = HasleeL::frOm([l,Z,3,»'1,5]‘!; 53:4" 1H‘

let 52 : HashSe-t::<i$l>::new0,;

1M 53 : HashSct: :fmm([1,1,2,2,3,3,3,A,5]):

Ll tritlt I(“‘;l 1.3351);

p-mriw'(“-z : 13" “,52);

w llitll'v(u‘ 2 ;;""‘,s3);
)
Obs: Natice the use of std::collectians::Hash$et (this is required ta use a hash set).
Keep in mind that the order of the elements is not guarantee ta be the insertion order
Alsa using several elements with the same value, will strip down equal elements

***************Ending Page***************

***************Beginning Page***************
***************page number:165**************
Basic operations for hash sets
“w tr!‘ , N11»: r Insertsavahleinaset.Returnsfabeifthevalue
already exists ‘m the set, true otherwlse,
Vi I‘ Hi [l1 , ,'1L|\JZ E A r ' If vame exists M the set, rEmDVES ‘\l and return truev
Otherwise returns fake.
tr .u 4'84 "7 Removes all elements from the set {but keeps the
aHocated memoryforfuture usage). /

***************Ending Page***************

***************Beginning Page***************
***************page number:166**************
®/ Hash sets
Let's see some examples on how to use a set:
use std::(cllcctluns::Hashict;
fn mam) (
let mut 5 = HashSet::fr'om([l,2,3,4,3]);
println!( {1?} ,5);
println|( () (n) ,§.ins0r‘t(3),§);
println!( {) {:P} ,§.lnsert(7))§); 5'"th
privtlﬂﬂ U (I?) JEVPLWNMLQ; (114,53)
println!( {} {9) ,§.v’emuve(&9),§); AddiV>fa\se:>§:(1,2,4,5,3)
println!( n ,§.<onta1ns(&/)); Addwnwvxm,1,4151)
Fun-nth“ (:P} ,s.gvr(&§)); Remove17>£rue:>5:[2,4,7,5,3)
' | s; i , Remove 9 '> fake :> 5 : (Z, 4, 7, 5, 3)
pr)ntln.( ( } J§’EEL(&8)), \sﬂmlhcsmvlruc
) cu 5 from m V> sums)
Get 3 from set e> None

***************Ending Page***************

***************Beginning Page***************
***************page number:167**************
' Hash sets
There are however, some methods specific to sets:
Methods for union, intersection, difference and symmetric difference
return an iterator.

***************Ending Page***************

***************Beginning Page***************
***************page number:168**************
® Hash sets

Let's see some examples on how set specific methods:

FF‘ '“EiﬂU I’ Umun:M,3‘E,7,5,1‘Z\
l-JL 51 : HHSNSEKIIFFON([1,Z,3,4,5]); \ntersacuun:(5,4,3)
m 52 : HashSet::F|‘omk_'[3¥,4,5,6,7]); Sde\ff:(7 (‘in
12L deshsen; = 51.unjon(&52).collectli); EI'SZIKLI} 5151:45 7)
let imaghSEt-z; : slimersectionmsz).colleao;
1M Samashku) : 51.symmetrignjﬁerence(s62).(Qllecto;
1-:L d1:HashSet<_7 : sl.djfference(&52).collecﬂ);
m d2:Ha5hSEtcg : 52.diffe|‘enc9(&sl).collect();
wumlv'ﬂmu» l HEM;
[.‘lHIlJ1(“\V‘\T9V'5:'N'\V : -;;7§‘ ,j);
p-imlmﬂm. i+'+' :=‘:“,sd);
w milviﬁmrs; 1.2; semi 1.";‘,d1,n2);

)

***************Ending Page***************

***************Beginning Page***************
***************page number:169**************
L
Bt

***************Ending Page***************

***************Beginning Page***************
***************page number:170**************
E; Btree M a p
A Btree map is an ordered map based on a binary tree algorithm (more on binary
trees z https:[(en.wikipediaorglwikMB-tree )s The closest equivalence from C++
space is std::map (even though they use different algorithms under the hood).
Keep in mind that current Rust implementation is slightly different than the
classical one as it tries to optimize search for small sets of data and use as much of
the processor cache as possible.

To create a betree map, use one ofthe following forms:
a) let mut a: BTreeMap<key,value> : BTreeIVlap ::newll
b) let mut a = BTreeMap::<key,value>::new()
c) let mut a: BTreeMap<ke\/,value> : BTreeIVlap ::wllhicapacltykapaclty)
d) let mut a: BTreeMap <key,va|ue> I BTreeMap ::from([(kev,vector):count])

***************Ending Page***************

***************Beginning Page***************
***************page number:171**************
Let's see some examples:
RUE!
mam ) (
m‘ J in 9.2.4
u : :1fr“om([("]0hn",l€"y,(I"Ana",2>3),(“F-‘like",5:1,(“Bugsy”,1>3)]);
}
m‘ J in e..z{
u : : :fmmlj[("Jmm",wj1, CAM", :6) ,("F-‘\ike",5), ( "Buggy", 19H);
} Im-
) MM" m ‘augsw w “\nhﬂ“ mnwvw s;
UMxke“ 5' “1mm” 10‘ ‘BHF.>‘|“ 10 Um‘ BU,‘
Urn-27y“ m Wm“ 2W “Mm? ENQMH" 10]
(‘whw ﬁ,“h)hn" m,-‘W“ mwmvy m‘,

***************Ending Page***************

***************Beginning Page***************
***************page number:172**************
®
Bt re e |\/| a p
Let's see some examples on how set specific methods:
RUE!
mam ) (
fur‘ ,1 in n..z(
H : ::¥r‘om([("]ohn",l€v),("Ana"129),("V-‘like",5),("Bugsy",1>3)]);
}
m‘ ,1 in n1\..1{
u : z:fmmq[("1mm“.10),("Ana",29).("r-11kg“.5),("Bugsy",1e)]);
um“ 20“B\1gsv“ w “\uhn" 1n,"M\v@“ s;
(“W 1.1, “SW 1mm" mm?“ {.1
\ Firm“ 2U,"Bugsv“ 111 Hahn" lb,“M\>.e“ 5)
NHL-37y“ m "Ayn" 1/1 “Nuke” E,“\uhr\" 10}
(“Ix/MW“ S “mhrﬂ' 1C1, "Ans“' 10‘ “BUE'IYH ID‘;

***************Ending Page***************

***************Beginning Page***************
***************page number:173**************
g; Bt ree M a p
Btree map has the same methods as Hash maps (e.g. insert, get, entry,
contains, etc). However, since the keys in a btree map are sorted, there
are other methods available only on BTreeMap objects:
{Vt-m‘; , ll w: A "l Appends all elementsfromaspeclﬁc Btree
map into another one.
‘ L‘ v l " possibleiorthese methodsto be available,
"gm now they not pan Om Sable /

***************Ending Page***************

***************Beginning Page***************
***************page number:174**************
Btree M a p
Let's see an example that uses ‘append(...) method:
RUE!
mm l
Q = ::fmm([<"1@hn",1»3),("Amr',19),<"i-iike",5j1,("Bugsy",1>3)]j1;
g : ::Froml[("Amra",la),("Aiia",wl,(_"Loyd",15),("kr1lt“,1:l]);
gaggemigs g),-

l Mﬂ_
Notice that if a key already exists, its value is updated with after the
append method is called (key “Ana” had initially value 20, after update it
has a value of 10).

***************Ending Page***************

***************Beginning Page***************
***************page number:175**************
a Btree M a p
Btree map is a well»suited choice for problems Where a priority queue is
required. The most common usage in this case is by using iterators and
their method .nextl) to advance to the next element. The result is that you
can extract / iterate over each elements in their order.

Rust

m mainO t
m m : Kirceblap::frum([(“i w ‘,16),r_“wtn t“,za),(“nti “,5),(“=,t; t ‘ ,19>]);
let mt 1 : midterm M
mil let SQ'WKX) I IMHO t’ EnraetAnawidthv'zluv 1n
) Eynattlolwwirlrhwlue m

} [martMllewiarhtralut s

OBS: We will discuss mare about iterators in another course.

***************Ending Page***************

***************Beginning Page***************
***************page number:176**************
7
BTreeSet
L

***************Ending Page***************

***************Beginning Page***************
***************page number:177**************
g; BTreeSet
BTreeSet type in Rust is implemented over a BTreeMap with a value of type I 9 a
ZST type thus making sure that there is no extra memory allocated for values,
To create a set, use one of the following forms:
a) let mut a: BTreeSet<lype> : BTreeSel::newl)
b) let mut a : BTreeSet: <type>I newl)
c) let mut a: BTreeSet-itypv = BTreeSet::Wlthicapacitykapaclty)
d) let mut a: BTleeSet<type> : BTreeSet;:fmm([<type>;cutlm]l
The logic and methods are similar to the ones from HashSet.
The similar class from C++ is std::set /

***************Ending Page***************

***************Beginning Page***************
***************page number:178**************
® Btree Set
Let's see an example on how to use a BTreeSet:
Rust
w 5 : BTPeeSet: :From’[1e,2,7,4,9,11,3,s,7]i; P 3 4 6 i q m 11
)
Similar to BTreeMap, there is an ‘append(.i.) method:
Rust
19¢’ HAT Q : BTPPOSCt::fi‘um([18,1,7,LL9,11,3,6,7]);
19L iut g : BTr"eeSeL::fi‘0m([l,3,3,6,5]); ‘ ' '
Q4HEEQHG(&FHT 3);
i-i-mtln'ﬂinzii“);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:179**************
Map comparation between C++
and Rust

***************Ending Page***************

***************Beginning Page***************
***************page number:180**************
g; C++ vs Rust (on maps)

Let’s compare how various types of maps work on Rust and C++l

For this we will use:
- std::map (C++)
- std::unurdered_map(C++)
~ HashMap [Rust]
- BTreeMap [Rust]
The same algorithm will be written in both Rust and C++ and tested in Debug and Release
mode. We will use GetTickCount API to measure time. Each variation of the build will be
executed for 10 times and the average will be compute. /

***************Ending Page***************

***************Beginning Page***************
***************page number:181**************
g C++ vs Rust (on maps)
So lets see the testlng algorlthm:
Extern ( m C21T11<£34rt340 .> m4; ) :mlme
M W Um] .> M < unsafe 1 1w m~um1t> ) » .mlm
“mg... Mg Mg v1;
I?[dev1ve(;ebng, (:1), new] Host v2,
Struzt 'est ( v1 .164, vZ F32, v3: bro] ) bun! v3;
)1
m W0 Q m. “(H
m mut m H.“ mwaz, my» 1 HMWMQUHMO; =th mmnle"alinauumslgnéd )nt, Team m;
1n start 7 get mm); autu 5mm 7 GetT1:\< 11mm),
m1 1n 9.. nae 06@( ﬁvv (auto i Z a; 1 < mamas, i“) g
1M l * Y'W' \' v1 1 as m4, vZ 1 ~,v3 15;“"U, M1‘ ' hum [unngrwd 1mg lawn),
) >
let End = 9r. (.1121), “m end 1 Gsticktomiuil);
WWW n J end . Start); wwm am , mmm . 5mm,
) )

***************Ending Page***************

***************Beginning Page***************
***************page number:182**************
So lets see the testing algorithm:
RUSf C++
“swww 1 aemcmmmmm ~ ; 1 mnclei- v.\-|1n\.1m~ys.h>
get nmeﬂl 'I ‘I ‘I GetTlckamHAU 1' } #wtluds (Hir-
I?[der
.‘v
mm‘ t MM, ,
1t; t 7 getitme‘ v: :1» 7 Kieth‘: (Mwm ‘v
'7 4.;1 , \r, ‘av/w, M1’ 1x H,
1 m1 1 getitimew, a H- 1 GEtTiUEmth-NH
L" {P17 :r'wy; py‘iy\tf[“ 1“, t mm V ;r-r¢',‘»v
1' |‘

***************Ending Page***************

***************Beginning Page***************
***************page number:183**************
So lets see the testing algorithm:

cvthug)

1111:1111“me 935 1255 1390 1323 1250 1297 1250 1344 1435 1437 1298
(“pulls”)

“mm-<1“,- 297 234 235 251 266 266 234 235 234 234 251

(mum-g)

ﬁdumip 1312 1765 1953 157s 157s 1859 1513 1512 1797 1528 1733
cmmem)

s\d"mag 156 141 172 157 141 171 171 155 171 156 159 ‘
Rust(Dehug)

mm, 1141 1197 1255 12511 1251 1312 1355 1297 1143 1297 1284
Rust (Release)

mm“, 7s 7B 53 75 7x 9A 93 94 94 94 84

Rusunebug)

MmMap 2703 3155 307a 2905 2755 2375 2937 21m 2350 1731 2890
Rust (Release)

BYmMap 93 93 109 110 125 110 125 141 125 125 115

***************Ending Page***************

***************Beginning Page***************
***************page number:184**************
g; C++ vs Rust (on maps)

The general conclusion after these tests is:

' Rust is slower the C++ when it comes to debug mode (due to many checks)

- In terms of Release mode, Rust is faster (however, it should be noted that we are
not comparing the same algorithms and as such these tests might NOT be
correct). However, since we've compared the standard algorithms from each
(Rust and C++) libraries, the results are however relevant.

' The tests were performed on Windows 11 (using Microsoft compiler). To produce
accurate results, other C++ compilers (such as clang and gcc) should be tested as
well. /

***************Ending Page***************

 