***************Beginning Page***************
***************page number:1**************
Rust programming
Course — 1
Gavnm Dragos

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
®; Agenda for today
1. Administrative
2. Intro
3. First rust program
4. Basic Types
5. Variables
6. Operators
7. Functions & Expression Statements
8. Basic statements (if, while, loop, ....) /

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
Administrative

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
®; Admlnlstratlve
Overvlaw:
- Course web page: hugs:[1gdt050579 guhub \oZrusl course fuj
' Grading: Gauss'like system (check out our Admlmslralwe page my more dexans)
Eksmlnatlon mg:
' A \ab project +50 pmms
~ Course examinauon 930 poms
' Lab aotiwty —>1O points
~ Lab (actwity + project! —>20 pomts
- Course exammauon —>1O pomts

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
L

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
g; What Is Rust
Rust is an openesourcefgeneral programming language that focuses on performance
and safety (memory sa ety / type safety). It |s grimanly used for building command
line tools, web app ications, server apps or to e used in embedded systems,
Resource:

- Linux & Mac/05X: run

' GitHub repo: httgs:1[github.c0m[rustrlang[rust

- Windows install link: httgs://WWW.rust-langsorg/tools/install
- Documentation: httgs:[[doctrust-lang.org[book[

' Quick install: htth:[[rustug.rs[

' Official site: https:[wawrustelangorgl

Rust latest version: 1.72.1 (194$ep.2023)

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
g; Rust History

- 2006 9 started as a project develop in Mozilla by Graydon Hoare
~ 2010 9 officially announced as a project
' 2015 9 Rust 1.0 (first stable released announce)
' 2021 9 Rust Foundation is formed, and the project is no longer
maintained solely by Mozilla. Companies that are part of Rust

Foundations are: AWS, Google, Huawei, Microsoft and Mozilla
' 2022 9 Linus Torvalds announce that Rust is probably going to be

used in Linux Kernel in the near future /

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
g; Rust History
' 2022/Sep —) Rust for Linux Kernel is announced to be released in
Linux kernel 6.1 , ¢
e “Mn.” “'2an .1 5
0555 u
Linux luminaries discuss efforts lo bring Rust to
the kernel
Aﬂev 31 years. a second pmgvarnmmg \anguage le be aHowed H1
WEN WM MM" M. was W“ m 5m“ WW.‘ Wm

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
ﬁi Rust History
' 2022/Sep —) Azure announce its support for Rust programming
a managing: Q E
In Rust We Trust: Microsoft Azure CTO shuns C
and C++
Mark Russmowch goes hardcore agamsl um \anguages
UPWED memm cro Mam KW" has m u w. c m 0. W ma
pmgrammmg ‘Wages mm“ m w m awhcams mil mu mg" Momma

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
g; Rust History
- Close after that event, Microsoft started to change some of its
internal code to Rust.
- t
a WNW, ‘I'lwﬁlhsiﬂnr q g
cscl E
Microsoft is busy rewriting core Windows code in
memory-safe Rust
Now that's a C change we can bank

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
g; Rust History
. Immuu Q
cqnference from 2023’ Firs! Rust Code Shows Up in [he Windows 11 Kernel
Mlcrosoft announces Its an
first kernel components
wrltten |n Rust as part of WSW: m "1.; ( hi’; m, Si!‘
‘ Mm. 5"“. M" .3 “mm
the" ecosystem. MM", M c mm.§\5ymm
nuns/1m} w 55 p" mm mm M
Bunsﬂzuzi as us PI Lumzss
suns/‘2&2; 99 w M new nnllkhase,“ :ys
Imus/1n)! w ‘a p" Hm“
nuns/2n: M w pl was mum,“ 5,5
amasﬁnn sq “q M 5v m
“mum as “9 DH vamw "mm m
'1 nun) .Mjsﬁ hm
e 011(5) 116 New“ by", m.

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
E; Rust History
- Finally, it is worth mention that Discord uses Rust on several backend
projects that require memory safety and increase performance:
httgs:[[discord.comlbloglsearch?guery=rust
- 1‘? I 1‘? I’ at; -=-
'1 il fr! i ‘r! i f. i .,
4x‘ 1r- ¥~e 1k $9 1 1e
‘l 1t ‘v! it a"! it a ‘ “— ,
o t
“mama
gargggggggfsgmwmm ‘15.213785232322255'3'523” M M i i. it, , ,

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
g; Rust History

Other memorable notions:

' 2022 9 CloudFlare announced Pingore [their proxy that connects Cloudflare to
Internet i written in Rust): m2; [[biog (ioudﬂare (omihowVwthuilt'gingora'theVgroxy'thatrumnecty
Cioudﬂale'tthhe'mternetL

' 2022 9 Facebook announced their support for Rust for server side components:
hugs iiwww mm corniavticie[tnerrust'grograrnrnmg'ianguage ust'gm'a'hig'boost'tmrn'memi

- 2022 9 Google announced that they started to use Rust for Android to mitigate
risks: MES iiwwwmmmmpmﬂgigngmnap-mg”Mm‘amWemammwaraywl“manna;

' 2023 9 Github switch to a new search engine (BlackBird) written completely in
Rust: httpszﬂwwwldnet comlarticlelgitnub'buiids'a'search'engine'ior'code'from'scratch'in'rustj /

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
' Visual Studio Code:
hngs:[[marketglacem5ualsmdi0.mm[ilemsmemName:rusl-|ang.msl»ana|yzer
' lntelliJﬁRnstOver):
m s: b0 .‘ethramsmm rust 2023 us 13 introducln 'rustrover'a'standalone'rust'ide'h r
ﬁgJ—LLLL;g—La rams
' Eclipse:
htth:[[www.ecligsemrgzdownloadslgackageslreleaseZZOlQ-OQZrZecllgse-ide-mst-develogers»
ll'lCU eS-ll'lCLl atmg-comgonents
~ Online lDE(Rust play round):
htt s: la ,rust'lan ,or
' Other online compilers:
htts: www.1utorialsolm.c0m comile rust onllne,h-
nszmmrust
nm-szonlne rust com-iler
"51 W

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
®; Rust Characteristics
' Strong-typed & statically typed language
' LLVM backend (native compiler) —gcc backend also a possibility in the future
~ Ownership and lifetimes for variables
' Memory safety (allocation / access)
' No garbage collector
- Zero cost abstraction
' Move semantics
' Traits (for polymorphism)
- Package manager and build mechanisms

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
First rust program

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
®; First RUST Program
{
‘( );
}
- C-Iike syntax

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
g; First RUST Program
mini’) warm)
i i
‘i ); ( i;
} }
' C-Iike syntax
' However, there are some differences:
- A function in C is defined by writing the return type first, while in Rust a
function is defined using a special keyword I
' "printf" is a function in C/C++, while "print!" is a macro in Rust /

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
a First RUST Program
Rust C/c++
helloworldO-t» helloworldt')
f f
w l:l,i, My lil i“); (‘ lelli, 11 1“);
wrw a; new a;
l ‘i
- C-like syntax
' However, there are some differences:
- A function in C is defined by writing the return type first, while in Rust a
function is defined using a special keyword I
' "printf" is a function in C/C++, while "print!" is a macro in Rust
' To s ecif the return value of a function, use the following syntax:
“H,

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
g; Create your very ﬁrst RUSTprogram
1. Using rustc [rust compiler) command line:
- Make sure that rust is installed
' Create a file in a folder named "first.rs" and insert into it the "hello
world example (the one with a main function)
' Run the following command from command line:
- An executable file (e.g. firsttexe if you run this command in Windows)
should appear in the first.rs file
' Run the executable file created on the precedent step (eag. run
first.exe if you are on Windows)

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
g; Create your very first RUSTprogram
2. Using cargo {rust gackage manager! from command line:
- Make sure that rust is installed
' Run the following command from command line:
' You should see a new folder (named first) that was created in the
current folder with the following structure:

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
.
Create your very first RUSTprogram
2. Using cargo {rust Qackage manager! from command line:
- Make sure that rust is installed
' Run the following command from command line:
' You should see a new folder (named first) that was created in the
current folder with the following structure:
: 8.1.6
\first\.gitignore
\first\Cargo,toml
\5'c [dependencies]

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
g; Create your very ﬁrst RUSTprogram

2. Using cargo {rust Qackage manager! from command line:

- Make sure that rust is installed

' Run the following command from command line:

' You should see a new folder (named first) that was created in the
current folder.

- Modify the ”\src\main.rs” to contain the hello world example

' In folder "\first" execute the following command:
i

1-7. [initial-‘zit: ~ ‘Jirlilgt'ilul tj'igu'ii in v :17

***************Ending Page***************


***************Beginning Page***************
***************page number:24**************
g; Create your very ﬁrst RUSTprogram
3. Try it using rust Elayground:
- Open a browser and go to
httgszﬂglay.rust-lang.org[ ‘
' Write the hello world code -m“ I
' Hit the button from > W“ l N M
the top-left side of the
web—page Em m

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
g; Create your very ﬁrst RUSTprogram
4. Use different features from sgecialized lDEs:
- Use features such as create new project (Intellii) or various
command/prompts from Visual Studio Code
' In the backend the cargo utility is usually used

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Basic Types

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
®; Basic types
Rust has several basic types, including:
1. Integers
2. Float values
3s Boolean
4. Character type

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
E; Basic types
Rust integer types:
i:———_
a bit [unsigned] us uint8it unsigned char
a bit (signed) is iniagi char
16 bit (unsigned) u16 uint16_t unsigned short
1s bit (signed) i15 inl16_t ShOﬂ
az bit (unsigned) U32 uint32_t unsigned int
32 bit (signed) |32 iniazgi int
s4 bit (unsigned) u64 uint64_t unsigned long long
64 bit (signed) i64 int64_t long long
128 bit (unsigned) u128 N/A‘ N/A
123 bit (signed) i128 N/A' N/A

* gel: and c-lang provide a -tvpe (but ii is ndi part dime standard)

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
g; Basic types

Rust integer types:
' General format is ”—” for signed integer or ’—”
for unsigned integers
' Signed integers (just like in C) are based on C2 complement format
- Besides this, there are two more integers types that have variable
length (depending on the architecture (32 or 64 bit). These types are
used as indexes in an array or as a representation of an offset or size
of a structure in memory.
"Mn

Unsigned (32/54 bit) usile size_t

Signed (31/54 bit] isize ptrdiffit

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
g; Basic types

Rust integer types:
- Rust supports the following notations for integer values:

' 0x => for hexadecimal values

' 00 => for octal values

' 0b => for binary values

' b'char' => for u8 values
- In addition, rust supports the use of character I as a digit delimitator
' The type of the integer value (u8,u16,i8,i16,u32 ..,) can also be
specified as a suffix for a number to specify its type

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
® Basm types
Rust integer types:
Rust
123; iEZ
9X12L|E~i ME
BbllﬂellﬁBlHJ; HWJ mlm'
123’45b3’78‘3; iPl ‘.‘jlw: 0+’ 11315173‘)
QXFFijFjF; ‘j.’ mm mm nwhrmmrm‘?
b1’; a!‘ nil “it? ‘111le >1? Hmii thlh‘ Fm eraLtvv' ‘12"
9011_33_77L154; L154 value ‘mitt?! 1H [vital mud? mt'v déllvntatiwi
106u'152'i; unhw 1m 7|’ fny' u"~w,

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
g; Basic types
Rust float types:
- General format is ”—” where number of bits is either 32 or
64
- Format IEEE-754 (similar to C/C++) F'WHWS ‘31 "m
Float 64 bits f64 double
' ”f32” and “f64” can also be used as
suffixes when creating a float constant
11m;
1251 I
LL’: ;
agenjﬁ;

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
g; Basic types
Rust boolean type:
' Identical to C/C++ (bool)
"M
Boolean bool bool
- Size of bool type is l byte (just like in C/C++) with 1 indicating a true
value and 0 a false value
~ Same constants just like in C/C++: - and - I

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
s; Basic types

Rust character type:

' Identical to C/C++ (char)
—_—m
Character char char char32_t

' However, while the size of one character (for type char) in C/C++ is
one byte, in Rust the size of one character is 4 bytes (so that it can
represent any Unicode character value). The equivalent type in C++ is
char32_t

' Character constants can be written using single quotes I

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
Variables & constants

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
E; Variable & Constants

Rust supports both local and global variables.

A local variable in Rust is declared using the special keywork I.

let <vuriable_rlnme> 1 <type> = <irrirializariari_vaive>;

let <vnriable_nnme> = <illl'tl'uliznti0rl_vulue>; Variable wpe is inferred from the
initialization_value

in <varibblaJame> = (type); Uninitialized variable. Its value must be setup
before using it,

let <vuriable_rinme> Uninitiatllze variable without a type
speciﬁcatinn. Its value must be set up before
using it. When its value is going to be setup, its
type is going t0 be inferred at that time‘

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
g Var/able & Constants
A simple example of local variables in Rust.
Fn malll() (
let a: “32 :17};
let b = 122,-
let c : emu“;
let a: bool;
let e;
d : tvue;
e : 4Y3;
Wintl'vK l) (l U {l l} Jammdle); /
} Output
a:1Z3,b:123,c:155,d:true,e:113

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Variable & Constants

Rust does not allow the usage of uninitialized variables:
RUSf

mainﬂ) (
}
ei‘|‘or‘[EE!381]: borrow 0+‘ possibly-uninitialized variable: x’
"a Sr‘c\main.r‘525121

i
a i pr‘int1n!(">\':i)“,x');

i " use of possibly'uniujtialized x‘

i

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
g Var/able & Constants
However, the following code will work:
m main() (
let x: m;
printlnH );
>< : we;
printlrv!( {) ,X);
) ompuz
In the second case thet ue of "x" is inferred to i32. Sfig§“si"“‘a“zed!
m mum) (
let ><;
printlrv1( );
x : we;
println!( n ,X);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
I
Var/able & Constants
Be default, any variable declared in Rust is immutable. The following
code will not compile because variable “x” can not be modified.
Rust error‘[EVJSE-1]: cannot ESSlgri my» m “mum? virlzbl: ,1
--: >rcima1ri.r::‘:5
mainil ( l
i. : m; sl 15¢ i : 1v;
("x is m); l -
u = 188; l l V V
H ,, l ﬁrst afalgnmerit m i
(~ "OW X 15 P); l help: <Ion51der mamng m; mmmg mutable. mut ,1
l a l prlntlrili“.x 1; mum;
7 l , : m;
l - cannot 8551;“ (NIKE m 1mniutable val-Jable
The usage of an in-mutable variable can be optimized when compiling
(e.g inline-ing variable value).

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
I
Var/able & Constants
In contrast, any C/C++ variables are by default mutable and can be
changed. As such, declaring a variable in Rust is similar to the following
code in C/C++;
mm c/c“ (uxlng cons! speciﬁer]
mam) t nlain(_) {
-, = 1a; -, = 19;
(3-K 15 ",->,- ("x15 ",~.>;
} }
c/cu [using constexpr span/IE!)
"mm r
.- = 10;
("X is w»;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
a Variable & Constants
To declare a mutable variable, use the keyword mut in the following
way: let mut <variab|e_name>
Rust
w mam) l

15L inuL X: 19;
mam-m“-wily-,1);
>1 : 196;
w a'vtleHL-i. 4 1;‘ 1,“,xl;
l
Now the previous code compiles and produces the following output:
mm-
XlS 10
nowxls 100

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
.
Variable & Constants
Once a variable has a type defined (via initialization or through type
inference) its type CAN NOT be changed (similar to how C/C++ works).
RuSl‘
mam i ,Wmm; unmatched tape:-
5 5r‘; main MHZ 1e
i : 1a; : i ‘
In this case the second assignment tries to set the value of variable "x"
that is of type “i32” to bool (via constant -)

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
.
Var/able & Constants
Keep in mind that the same code in C/C++ works (due to the rules of
promotion, any Boolean value can be converted into an int).
Rust C/Cn
mm,» < maim) {
i 7 Z'Www 1 is “,l); l 7 ("how x is ",l);
J 1'
mm-
X510

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
. Variable & Constants
As a general observation, once a variable is declared with a specific
type, it can not be assigned with a value of a different type, even if an
implicit conversion is possible.

Rust

i I 16 5 i

i : 1 ; 5 i 1-?‘ mur ~ : mm:

(“X is “ill; i 'zq-ivrti'd m“ r1: nip. vdliu‘
In this case “X” is of type with values between 0 and 231-1) and
the assigned value is of type . Even if every possible value for an I
(values between O and 232-1) can be stored in an - value, Rust will
still provide a compiler error.

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
E Var/able & Constants
In contrast, the same C/C++ code compiles (rules of conversion will
automatically convert a u8 value to u32).

Rust C/c++
mm l mam“; l
i : 10 z i 1o;
g Z 1 ; l I ( )li
(“- l ‘Nil: l‘ l Hi);
l 1-
W

***************Ending Page***************


***************Beginning Page***************
***************page number:47**************
a Variable & Constants
To cast from a type to another type in Rust there is a ke word called I
that can be used. The general format is —:

For the previous case t0 work we need to rewrite it like this:
Rust
mam) l
._ Z 1' 5

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
a Var/able & Constants
Let's see some examples:
Rust Rust
m niaini") i ‘ri mam) r
1w "m 3 : :55 u us; 1w vi: 5 : 255 .i uB;
let mt y : 1 a 132; 12L it; 1 : 1 Hi 1'8;
1:5.v13'2; x:inii8;
pliiitlim“, 4 Why): v ,L :55 pimtlu'(‘; iJ 1&1); y i: '1
1‘ )
First case is a simple one (as all possible values from u8) can be stored
in an i32. The second case (i8 to u8) keeps the value as it is (in terms of
bits) and just interprets the value in a different way.

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
.
Variable & Constants

Not all casts are possible (for example a cast between a number and a
bool is not allowed). The following code will not compile:
RilSt
—

1 = 1 ,- WWW“; mm.» .1“ as m1

e l ' . ’ l
L*i 1 7i v=xafim0h

("y is "-‘Jl l " " help: (umpire with 15m )HECEEvJ: .t i: a
}
C/C++ has a different logic (any value that is O can be implicitly seen as
false and any value different than 0 can implicitly be seen as true),

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
.
Var/able & Constants
Let's see some examples:
Rust
limo (
L _ ("y is ML):
l
In this case, a truncation to the first 8-bits happens for the value of 258
(keep in mind that an u8 cand only store values between 0 and 255).
258 = 0000 0000 0000 0001 0000 0010
= the code will truncate to the last 8bits (least significant one)
= as such the result of the cast will be 1

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
I
Var/able & Constants
In case of integer to float conversions, the program attempts to obtain
the closest float value to the integer one (that can be represented in
the float format).
Rust Rust
nvain() l nlain() t
~ = 198 ; - = cotFFFFjFFF ;
1 : u ; 1 I l’ i
L Z l ("y 115 "-11; L Z l ("y l5 "1):
l l
YIS 100 yls 294967300
XlS 100 XIS 294967295

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
a Variable & Constants
In case of float to float conversion (every f32 can be converted into an
f64, while an f64 is approximated to the closest f32).

Rust RI!!!

in maim) ( ii inajnti i
lit x : 1.9123356789 .‘i. {Ev-4,‘ ‘tit X : 1.7976931348823157E+368 11- f64,‘
let nut X : o a; HZ; Let lillJl. 1 : e :1‘: F32;
y:xcil;32; 1:><n-:.t32;
piLiLli“(“,‘ i, Why): Vii-inning“ i $31),-
w-mcii it" i: WA); Siliitliil[“ i; if»);

l i

‘(l5 l 0123A57 yislnf

x i5 10123456789 x is 1797593134S523157OOU...,UOO

If the f64 value is outside maximum value possible in f32, the

conversion will enforce inf as the value of f32.

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
® Variable & Constants

To declare multiple variables at the same time use the following format:
, let (varl, varz, varn)=(value1, valuez, value")
The types for varl, varz, var,‘ are inferred from the associated values‘
Rust
tn mam) l

lei. (NHL 5, ll uL L "rut g) = (1,2,3):

pri itlnl(“l:< , yl, lz', al . lb H'); 1,2,31 23true

3 : 19; 1010301124“

v : 20;

A = 38:

pm'wttnl(“~i>:l , ‘ylw-lL , ,alw-lbfl;
l
The number of values provided must be the same as the number of
variables.

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
.
Var/able & Constants
Rust also allows shadowing 9 meaning that a variable with the same
name and possible different type cand be declared with an inner block
and possible be initialized with the initial variable.
RuSl‘
mainﬂ) (
7.: : 10;
l m 10
"i Z f H innerxismie

v < WW" l5 P’); outterxile

I ("nutter X is "1");
)

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
® Variable & Constants
Shadowing is often used to change the mutability state of one variable
for a limited period of time by using a copy if that variable‘
Rust
+1‘ mainll) (
lit X: 132 : 19;
mini-ix“- 1“ Wyn:
‘ m!-
wr mm 5 : x;
5 = za; -, i; My, ‘mime and a, L“: Liisi'ged “51°
niliitlniiihiiei ~ 15 ii ‘,5); mnerXISZO
} cutter x i5 10
wi'vtlii‘(“vuuri - ‘L HHX);
J

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
a Variable & Constants
For global variables, use the keyword static instead of let (let is design
for stack/local variables).

Rust
Sisalsiu X1132 : 18;
let HUI X : P) r51; ‘U510
until ‘(W is HUI);
ﬁr""ifli‘l(“- v ll“,X:l;
i
A static variable implies a possible mutable variable (if mut keyword is
being used) and guarantees an allocated space in the binary data.

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
® Variable & Constants

Rust also allows the usage of the special keyword const to define a
constant‘ The main difference between a const value and a static value
is that a const value is always immutable and will be replaced with its
value upon compiling phase.
Rust
Lumi X1132 : 13;

X:xr,¥32; mm

w ; illmﬂw i7 HUI);

ni""itlnl(“'- v ll“,X:l}
i

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
a Variable & Constants

Both static and const keywords can be used in a local function:

Rust Rust

in mam‘; i +11 mini) (
hLdLiL XIiBZ : 18; LU'ibl X1132 : 16,‘ m
ior iiiiT X : r1 F31; icr iiiiT y : 0 (.7 F31; visiO
y=xs> {32; y=xe> {32; M510
Lil‘l"ililil(“, i: ii“,1); Lil‘]"ililiil(“, i: $13!);
willy-w“- i». i'i“,x); prawn-m“- i». 15y);

i i

OBS: a mutable static value requires unsafe code (more about this on a

different course)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
I
Var/able & Constants
Another difference between - and I is that type has to be
provided in case of- and keywords and can not be inferred.
RUST
(">1 is ); 4 r must .- Z 1a,
) r ' help mum a type rm' w turrftint: X= 15:
Rust
‘ z 16; ‘ fr't‘nain m4 u
("x 15 3; 1 r mm >, r 1»,
\, r help mu“ a mp- m or- imp. ma'ﬂalvlv 151

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
.
Variable & Constants
The same logic applies for initialization value (if in case of let, one can
define a variable and assigned its value after this), in case of const and
static this is not possible‘
RUS!
man“) l Grimm-tyiiifxli:ital villihllllt lJCCli
l l mlp: pmm; n namimrm Fm- m; “am: : e'pr' v

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
g; Variable & Constants
Observations:
1. There is no such thing as 0 initialization in Rust (for global
variables).
From this point of view, Rust tries to make everything clear and
make sure that there is no unknown behavior due to this case.
2. In case of constants, Rust recommend using upper cases (this is
considered a warning and will not affect the compilation phase).
Warning
l
\l 1W1. in; , 1“,
l My Law: L'iv iii-“tiny r». up? my MM u» “Mondrian;
l write: Wll'lii‘i'liiiii'l iti-iv' {5:2 Ilinalii' ‘J'l l3)‘ Herzl 1t

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
g; Variable & Constants
Comparation with C/C++ similar forms:
-D—
In let mut x; i31 : 1o; int x : 1o;

m mut XI i32; int X;
let mut X = 10; auto X = 10;
\et mut x; N/A
X = 10;
calls! const X: BZ = 10; const intX = 10;
conslexpr im x = 10;
“define X 10
static static x: i32 : 10; const intx : 10; // as a global variable
static const mu: 1o; // as a lucal definitinn

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
Operators

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
E; Operators
Rust supports the following operators:
—m—
Amnmenc (I | II I) Yes Yes
Comparauun l II I II I) Yes Yes
mgical on ,AND ur NOT I III) Yes Yes
an operators‘ bitwise 0R, bnwise AND, shiﬂs ( III I It Yes Yes
Assignmems1llll-IIII-I) Yes Yes
Increment] Decremem uperamrs 4 II) N/A Yes
Negale Overawr ( I) N/A (“sell Yes
CondmnnaHy operatar1I]-) mmﬂllnn .> Value formle = Value a» false N/A Yes
Member access operated II] Pam'al lenlyl) Yes
Error propagamn ( I) Yes N/A
Range llterals 1 III) Yes N/A
Functional updale ( I) Yes Panial 1pm»; clor)

%

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
Operators
Rust has a very comprehensive compiling error system that besides
clearly explaining an error, it also provides some directions/ideas on
how to fix that error. In particular for operators, Rust can identify some
of the widely used operators that are not supported (such as increment
or decrement) and provide guidance on how to fix some errors.
Rust
mainU ( emf:riuiltfigngIpiisthx Mm,“ gum-atm-
i : 10; i
3+; ‘I i s _ s
("X 7 His); l nut a Mia puztr11,uperatur
l help: “Se t: 1 )nstead
i
5i i; m (mp Z ., i o: 1, mp i,
i “WWW N- WW
5 V W;

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Operators
Rust has a very comprehensive compiling error system that besides
clearly explaining an error, it also provides some directions/ideas on
how to fix that error. In particular for operators, Rust can identify some
of the widely used operators that are not supported (such as increment
or decrement) and provide guidance on how to fix some errors.
Rust
mainLi l w,» grim is, Mn as a W,» Bus-m-
i: : 1m or: 5,»; rnainms 5:13
g Z u; i
1

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
g; Operators

Operators order:

' /% left m right

+ - left w right

<< >> leh tn right

& left to right

A left to right

l left m right

== |= < > <= >= Require parentheses
m left to right

| | left m right

.. ..= Require parentheses
= += _= -= /= 95: &= |= A= <<= >>= right to left

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Functions &
Expression Statements

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
E; Functions
Function in Rust are defined using the keywork. in the following way:
m_—
fn <name> ll i---l void <name> (l (...)
fn <name> (parameters) (...) void <name> (parameters) (...)

m <name> l) -> <return_type> l...) <retum_lype> <name> 0 (m)
m <name> (parameters) -> <return_type> (m) <re!urn_type> <name> (pammetersl (...)
Where parameters are defined in the following way:

* <param_name>:<type> [, < param_name >:<type>, ]

* - < param_name >:<type> [, ....]
Where <purum_name> is the name of a parameter, and <type> is the
type of that variable.

***************Ending Page***************


***************Beginning Page***************
***************page number:70**************
Examples:
sump; ,yi ,> -> \' xmo
return " + w,‘ Xls 30
‘I
priﬂtjﬁai ‘) {
}
mam) 1
:l: : 16;
priﬂtjdl);
l = 511ml:lEl,ZB:VZ
pmntixkl);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
Examples:
FMS!
compute“: , 3,‘: y 7;‘ {
-, : ' ~;
return :43‘; e\'r":r'[E»I~ZE-1]: tinmit ;::1;n m )nvmutable lr'gurvsnt ~.
J . \
("X is ",w); \ V Mm: (mums! rriklug Hus Landing HMKEUJE m ,,
} 4 \ < 1 n '
nlain(‘) { \ v - v - v mm 33:1,," m 1,"th MWW
5 : 1E1;
mmxw;
»_ : conwutﬂlégla);
printixlil];
3

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
® Functions
Examples:
Rust RIIS!
{'1 CONDUCMKZUBZ, yzuSZ) "1 U32 { {H comput9( MAT £3132, yuﬂl) "I “32 {
X I X ' y; 1 : § * y:
‘WW 1 My; ‘m m 5+y;
) }
m print_x(x:u$2) i m print_><(x:u;1) -[
prww'n‘(‘.-1'1}‘,X); _ PMFTM'UKHY 1' ~1 “,X);
} 1’
w nlain() < m main() {
1w um 5m}: : la,- L-t um 5:“31 : 1e;
mnmw; mwm;
5 : computéﬂﬁﬂﬂ); 5 : c0mpute(19,20);
mmﬂg; printiﬂi);
3 v

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
.
Functions

Rust has a keyword ( return )that can be used to return a value from a
function (similar to C-like languages). At the same time, Rust allows a
different format of returning a value by writing the value that you want
to return directly.
The following two Rust programs are equivalent.
Rust Rust

valuei3() r> valuei3() r>
;- .- ;-

limo l View) l

w : valuejo; w : valtiejo;

l l

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
.
Functions

Rust has a keyword ( return )that can be used to return a value from a
function (similar cu Celike languages). At the same time, Rust allows a
different format of returning a value by writing the value that you want
to return directly.
The following two Rust pro
RuSl‘

valUEi3(') r> t trey) r>
l <- ;

niainf) r new) l

w : valuejﬂ); w : valuego;
(“>1 1'5 '3»); (“X 1'5 '3»);

l l

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
iii EXPFQSSIOH statements
Rust also allows an expression statement where something gets
computed based within a statement l...)

RU“
mainU l
i
Notice that the same return format (with a value) is being used in this
case (without the I character at the end)

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
’
EXPFGSSIOH statements
In this format, some even more complex operations can be performed:
Rust‘
mam) <
= 1&1,-
h
("X Z =~ ");
1
In this case, the value of “x” will be "a+y+5"

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
’
EXPFGSSIOH statements
In this format, some even more complex operations can be performed:
Rust‘
mam) l
= 1&1,-
Sum( .: , ‘,‘I ) 7> g i-ﬂ,‘ } out“
\.
l,
("X Z =~ ");

l
It is also possible to create nested functions within an expression
statements and use them to compute the return value‘

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
E EXPFGSSIOH statements
Nested functions can be added Within an existing function:
Rust
{n mainU i
Hi sum(x:izz, y:132) r> 132 {
X+y
, MD
iii diﬂXIlBZ, yIiBZ) -> 131%
Key
1.
w y : sumumzn);
1m x = diﬂ'zege);
Lir‘]'itiri‘i:“- : ,xiv , : iyi“);
i
i

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
Basic statements

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
g; BGSIC statements
Most of basic statements that exists in C/C++ can be found in Rust as well:
——lﬂ—

If statement Yes Yes
While Statement Yes Yes
For statement (classic) N/A Yes
For each Yes Yes
Loop Yes N/A
Do...While statement N/A Yes
GoTo N/A (partial SLIppOR) Yes
switch Yes Yes
Patterns: Yes N/A
if..let, whilenlet, let.,else

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
If statement format:

- I condition <then statement>

~ I condition <then statement> - <e|se statement>

Obs:

1. Notice that condition does not requires parentheses (...)

2. Because of this, <then statement> and <else statement> can not be
simple instructions (they have to be embedded in a block). /

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
' If
Example:
Rust C/C++ (v1) Us“ (V2)
mam’) ( 1_ Him i. "who ‘,
'_~ : . _ V ._ : . '1 1 1,-
if l>8 { 1+ (1'9) x‘ if (19)
“:1; “:1: i -
} i I i :1‘ H
(, : _H); ("x I "- i); x (x J l)‘
J } i

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
If

Example (ifm else):
Rust C/C++ 1V1) 6/5“ (v2)

mam ( -. 7 1‘ mainQ i maim) A.

‘+ LIX-i‘ ‘* ‘12$ iF (9m

‘yelse i )else i QISEL

('A' I A "Iv; (“At I "'1); ) ‘ ' i"

\, )

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
If

Parentheses land I around the condition are allowed, the code
compiles but triggers a warning:
Rust

mainm { wavrnng, imﬂitejfiiy pavinthbfe; around 1+’ awning”

' )1 : l; "r s": rilan'i 5:5
) l
_ _ : nub! ~[iwnninusedjwn;ii m m risFault
‘ l X : " )1 help: rem/we these parenmeses
- l
l z V 1; way t
5 t 1+ t» (
—

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
E If
If statement can also be used as an expression statement:
Rust Cee
maini_) r mini) i
i Z 31; ,; : 31;
i, : s was i wl } 51,‘: i ~. ' 2 }; it : 0N > -.,/z : -, ' z;
i 1'
Notice the fact the return value is specified just like in the case of
expression statements for both then and else parts.

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
’
while
While statement is similar to the one from C/C++:
- while <condition> { do block }
Just like in if statement case, notice that the <condition> does not
need to be surrounded by parentheses.
RUST E/C+#
mam) r mam) r
while ~52, i while (g) i x :0
("X1 - "Ii; ("1 I ll; X :1
i = 31; :1: X :2
1‘ i

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
’
while
Similar to if statement , the condition MUST be followed by a block
(and can not be a simple instruction like in the case of C/C++)‘
RUSK
while 53 Q z i mm;
l = i+1; i rm; Mule mndltwn silwésifullp tar-zed
(w: » "u: i i
i l in»): pal-)3"; m: m, uf mt Hm! “plum
C/C+‘ l ‘Qwetteﬂ l
majn() q hglp: "y glazing this code mm a mm
,~, : 1; i
‘,ng (g) “l f‘ ’ “"1
} ("X Z 1); The C/C++ code will compile

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
.
while
Both break and continue keywords can be used in an while statement,
with the same logic as the one from C/C++ (break or continue the
loop).
Ruxt
mainK) i
1 Z 1;

while 510. {

i
i

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
g; while
Let's consider the following problem:
— Let there be a number of formm, where I, I and I are digits
between 1 and 9
- Can we find the smallest number of this form that has the following
relation between I, I and I
1) a = b x 2
2) b = c x 2
The answer is simple _> there are two numbers that respect this
condition: 421 and 842, and as we are searching for the smallest one
the final answer will be 421.

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
®
while

Let’s how the previous problem can be solved in Rust:
Rust

menu") t

Mule > ‘\I‘ (

mm)! J1»? {
mu.“ 4,2,1

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
®
while
Let's how the previous problem can be solved in Rust:
Rust
mm 41
V v ‘,, :\ :U,1,1‘/:
A Z 1;
MM W H WW,‘
.ﬁli

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
g; while
Rust has a way of providing a name (a label) for every loop statement
(for, while or loop).

This is done via the following format:
- '<name>: <for|while|loop>
Example: 'first_while: while
This allows keywords like break or continue to explicitly say if we want
to break the current loop or if we want to break a specific loop based
on the loop name / label.

, break

, break'first_while

***************Ending Page***************


***************Beginning Page***************
***************page number:93**************
®
while

Let's how the Previous problem can be solved in Rust:
RMSI

‘ LI A. J 1 \1,1,1\.

‘ , mule .m -;
‘ “1701-27:an -
1' a» == ,‘11 m 1, 1: 1'1‘
ii‘;

\‘

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
® loop
Rust also has a special loop called loop statement
, loop {... do block ..}
In a nutshell a loop statement is nothing but a while true (m)
statement.
Rust c/C++
"n malnl) ' lam mainl) '
i l "Mi: (w) l 0
[Wlﬁflv'lllw ><l“); "Plntt'(“* : M1“, 1'»; 1
5 5;-=1{ w l z) 5(5>=1>>l ll; 2
8:1; 8:1; s
l }
} }

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
® loop
The main advantage of the loop statement stays in the fact that it can
be transformed in an execution statement where the return of the loop
can be obtained via a break <value> statement.
Format: let <variable>z<type> = loop ( break <value> };
RuSt
tn maimj) (
let (mt 5,"an 1) 1 (24,18);
1w (nlmdc:i32 : m (
@1th t V ‘gel ,5}
l;
w i lrlnw“ lcmmdﬁr“);
l

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
® loop

Type can be omitted and will be inferred from the value returned via
break statement.
Format: let <variab|e> = loop { break <va|ue> };
Rust
+1 mm) t

let "L'C sum : 8;

1M’ wt counter : 9;

let first_10_sum : -;

counter ~ 10 4 sum; ; m
sum +* counter‘;

priintln x v ‘-{first_10_snml ‘>;

t

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
g; If let
“if let” tries to match an expression with a specified pattern. If the
expression matches the pattern, the assignment is being performed and
the code from the <then block> is being executed, Otherwise, the <e|se>
block, if present is executed.

' if let <pattern> = <expression> { then block j

or

' if let <pattern> = <expression> { then block )e/se { else block }
This statement is NOT to be confused with the if var=<expression>
statement from C/C++, as they serve a different scope.

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
g; If let
The assignment (in case of iflet <puttern> = <expression> {...) usually
translates in a match of:

' An enum variant

' A structure with parameters

- Numericalconstants

- Tuples
We will discuss more about this type of statement when we talk about
enums, errors and variants (as this is where this statement is mostly use .

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
If let statement (example):
M M—
rHalHV') q
v : 1Q. x510
if 5 - { pr‘irvtlnl\"x is 5 "u; 1 Ammdlandz
1Q m Z I pr‘)ntln!\'">< is 16"); } Cuvrentmumelinot\n(hefurm1x,l)
huph Z (1,2);
if 1_-,2> : 17%,: q printlnH"A touple of - and 2w}
if \‘-,1‘y: *iu" w 1
pr‘1nt1n‘¥_"currznt tuuple is not in the form mun;

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
if let
If let statement (example):
RMSF

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
If let
If let statement (example):
RMSF
w-iy-tlnh'm touple M and :‘m

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
If let
Let's discuss another example:
1r .:a{ 1i 1F1etw:n-;
pmnrinii“ t "ji; l " "
‘ J‘ 1 not: rm; patterll N111 31W“; match, :o m! n let l5 time“
.l 7 help <IﬂnfiiJEF iéplailr'ig the if let with a 15¢
Z "Uta; ~riiariii1ryrart.tahle 19¢ [mttetnii' t-i default
In this example, ”-” will always be true (in reality there is no
pattern to match here —just a simple assignment . The code Will
compile, but this no different than just writing ’ ”.

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
® If let
Let's discuss another example:
Rust
gt v : a l 20
prinrimi“ vl“j\;
£1!‘1ntlnll“lvj“i;
This is a similar logic 9 however, notice that the “v” variable from
the if let statement has a limited lifetime to the <then> block and
will not affect the outer “v” variable. As a result, the second println
will print the value 20.

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
l
If let
Let's discuss another example:
M mm- C"
. , alltlutle <5tdjo.h>
_ . : :0: outerIZO W Z 19;
“c ."ZM. it'l:8ll
p"l"tl"1‘i"1""e" Z ' H“ ivimrwinner : l ‘l-
1 i
pr'intlnli'buter = "3; érmtnwuter Z 1 W;
Keep in mind that these two code are . In case 0f
C++ example, variable v is first instantiated with value O and then
evaluated (and since O = false) the <then block> is not executed.
Furthermore, it’s the same variable “v” and as such the second
printf will print value 0.

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
g; while let
The q form can be used in a loop with a similar logic (pattern
must matc in order for the loop to run).

Hm u) l
1 : >1 l On the first glance, we would expect this
~Z+ l i l while to run for 3 iterations , print values
L L t‘ 1» i; from lto 3 and exit.
l
l
This is not to be confused with while var=expression statement
from C/C++.

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
while let
The ‘form can be used in a loop with a similar logic (pattern
must matc in orderfor the loop to run).
Rust
mairil'l r
“in-12ml
i Paw FQE ; l
L’ = L‘ + 1;
(" 1» ");
l
l
This is not to be confused wit
from C/C++.

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
®
while let
The -form can be used in a loop with a similar logic (pattern
must match in orderfor the loop to run).
RUSI
mnem{ "r “Hump; +11
j 1):; "ea ; } 4 \ wmle 12¢ wvut 1 r B Y
L=E*1= ‘ .
(" 1» "); \
\ Z MIL‘; li[v|.ﬂ1H1v‘!efutzbleilrtipattrvﬁi'q] U” m damn]!
J 1 Hm m; path?!" mu mm; matih, >1» m mm‘ ml) HEuL'V‘ rut
} 7 help consider‘ 1mm usiﬁg a 1m ( .. ; mm a m )nnde 1t

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
.
while let
The q form can be used in a loop with a similar logic (pattern
must matc in orderfor the loop to run).
Rust Rust
. 0 , mam) l
,“jlllem4 while (U Z e-
i 3:1 time t — 1+ 1):? t? Wék; }
‘ ("t"); ‘LILWM _
) ' ‘I (" y "l;
} t
This is not to be confused with while var=expression statement
from C/C++.

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
g; while let
The assignment (in case of while let <pattern> = <expressi0n> {...} usually
translates in a match of:

' An enum variant

' A structure with parameters

- Numericalconstants

- Tuples
We will discuss more about this type of statement when we talk about
enums, errors and variants (as this is where this statement is mostly use .

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
g; let else
“let else” tries to match an expression with a specified pattern. If the
expression matches the pattern, the assignment is being. Otherwise, an
error (that will be discuss in the next courses) will be thrown:

let <pattern> = <expressi0n> else { error )
This is mostly used with enurn , variants or structs and we will further
discuss this type of behavior at that point.

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
Some examples of “let else”:
RIIS! RMSF
VHEUHU q "151111) ~1
T'm' U Z (1,13; mm‘ : 41,3};
‘9,2; : 17%;: Else -; [3,2'1 : Luupl: 91>: -;
pan)(H"Fai1 to assign 1") panic!("Fail m assign m
1' ‘.
h .,
prlﬂtlnh'" "7: princlm" "1;
5r‘: main m; 31

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
®
let else
Some examples of “let else”:
RIIS! RMSF
/
We

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
g; other statements

There are other more complex statement in Rust, such as:

' for (equivalent for classical for from C/C++ and a foreach)

' match (an equivalent for switch in C/C++ but more oriented to

pattern matching)

As all these statements are either more complex or require

understanding of different concepts in Rust, we will discuss them

during the next courses. /

***************Ending Page***************

 