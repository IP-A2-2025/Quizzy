***************Beginning Page***************
***************page number:1**************
Rust programming
Course — 1
Gavrilut Dragos

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
Agenda for today
1. Administrative
2. Intro
3. First rust program
4. Basic Types
5. Variables
6. Operators
7. Functions & Expression Statements
8. Basic statements (if, while, loop, ....) /

***************Ending Page***************


***************Beginning Page***************
***************page number:3**************
Administrative

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Administrative
Overview:
' Course web page: https:[[gdt050579.github.io[rust course fiiZ
~ Grading: Gauss-like system (check out our Administrative page for more details)
Examination type:
~ A lab project +50 points
~ Course examination +30 points
~ Lab activity +10 points
Minimal requirements:
- Lab (activity + project) +20 points

***************Ending Page***************


***************Beginning Page***************
***************page number:5**************
Intro

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
,’ What IS R US t
I Rust is an open-source general programming language that focuses on performance
and safety (memory safety / type safety). It is Brimarily used for building command
line tools, web app ications, server apps or to e used in embedded systems.
Resource:
- Linux & IVIac/OSX: run
' GitHub repo: httpszﬂgithub.com[rust-lang[rust
- Windows install link: https://vvvvw.rust-|ang.org/too|s/insta|I
' Documentation: httpszﬂdoc.rust-lang.org[book[
' Quick install: https:[[rustup.rs[
' Official site: httpszﬂwww.rust-lang.org[

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
' 2006 9 started as a project develop in |\/|ozilla by Graydon Hoare
' 2010 9 officially announced as a project
' 2015 9 Rust 1.0 (first stable released announce)
' 2021 9 Rust Foundation is formed, and the project is no longer
maintained solely by |\/|ozilla. Companies that are part of Rust
Foundations are: AWS, Google, Huawei, |\/|icrosoft and IVlozilla
' 2022 9 Linus Torvalds announce that Rust is probably going to be
used in Linux Kernel in the near future I

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
' 2022/Sep 9 Rust for Linux Kernel is a nnounced to be released in
Li n u X ke rn e I 6 . 1 Rust is coming to the Linux l<er| X +

(- O i tberegistercom . i = . - -- lli l- - -- if“ i} _=J' I] G l:::l..l|>=.l.ne it)
g SIGN IN I UP Thea/Register“ Q E
OSES 64 l2]
Linux luminaries discuss efforts to bring Rust to
the kernel
After 31 years, a second programming language will be allowed in
a w Fri 15 Sep 2022 15:30 UTC
OPEN SOURCE SUMMIT Both Linus Torvalds‘ Open Source Summit keynote and Jonathan
Corbet's "Kernel Report" discussed efforts to allow Rust modules in Linux.

***************Ending Page***************


***************Beginning Page***************
***************page number:9**************
Rust History
' 2022/Sep 9 Azure announce its support for Rust programming
e c a theregister.com - ~|i ~ - g» a’ Er I] e (I)
2. SIGNINIUP Thea/Registeri’ Q E
In Rust We Trust: Microsoft Azure CTO shuns C
and C++
Mark Russinovich goes hardcore against old languages __

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
' Close after that event, Microsoft started to change some of its
internal code to Rust.
Microsoft is rewriting core Win: X +

6 C in theregister.com.'= i ‘ -i-~ ' .i' || ‘51> i} _=.[ I] G (Update E’:
.8 SIGN lNi'UP Thea/Register” Q E
CSO 115D
Microsoft is busy rewriting core Windows code in
memory-safe Rust
Now that's a C change we can back
A Thomas Claburn Thu 27Apr 2023 20:45 UTC
Microsoft is rewriting core Windows libraries in the Rust programming language, and the more

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
R r H' t
551:‘. . Thurrott (<1
' And after Mlcrosoft Bulld
Home Windows 11 Mobile Cloud + Al Microsoft 365 Home Tech Xbox

Conference from 2023' First Rust Code Shows Up in the Windows 11 Kernel

Mlcrosoft announces Its »- ~ ~ 1 mm

flrst kernel components

. . C:\Windows\System32>dir win32k*
wrltten In Rust as pa rt of Volume in drive C has no label.
h _ Volume Serial Number is E698-9A9E

t Elr ecosystem‘ Directory of C:\Hindows\System32
04/15/2923 69:50 PH ‘768,608 win32k.sys
04/15/2023 09 49 PM 3,424,256 0411100.,2 'y'
04/15/2023 99:49 PM 110,592 win32kbase_rs.sys
04/15/2923 99:50 PM ll,19‘-l,30ll vnni/lu-ul l .qu
04/15/2023 09:49 PM 40,960 win32l<¥ull_rs.sys
04/15/2023 09:49 PH 69,632 “1.02.6.9”,
04/15/2023 09:49 PH 90,304 win32ksgd.sys

7 516(5) 0,646,656 bytes
0 Dir(s) 116,366,049,280 bytes Free

Recently me learned that lwlwmmlt null lPWllYF' pm": cll the \Mmlox-m kernel lmngmenew/1:1, (“ale

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
' Finally, it is worth mention that Discord uses Rust on several backend
prOjECtS that req Uire memory Safety a nd increase performa nCEI
httgszﬂdiscord.comZblongearch?guery=rust

9 ‘ ,

' 7*“ 4" ‘he. n’ a J I h HOW mscono STORES TRILLIONS “5;;

:Ll-gfullaggggnmllssiwwcnme “saws-12:32.21:ﬁghiﬁzlﬁlslllllgn Rust! We'd used it for a few projects
- - reviousl , and it lived u to the h e for us.

but we also hoped that Rust would fix these “COUld we use RUSt to go faster?-”. RUSt is

latency spikes.... not a functional language, an Will happily

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
"® Rust History
Other memorable notions:
' 2022 9 CIoudFlare announced Pingore (their proxy that connects Cloudflare to
Internet — written in RUSt)I https:[Zblog.c|oudf|are.comZhow-we-built-pingora-the-proxy-that-connects-
cloudflare-to-the-internetZ
' 2022 9 Facebook announced their support for Rust for server side components:
httpszﬂwwwzdnet.com[articleZthe-rust-programming-language-iust-got-a-big-boost-from-metaZ
' 2022 9 Google announced that they started to use Rust for Android to mitigate
riSkSI https:[[www.zdnet.com[articleigoogle-after-using-rust-we-slashed-android-memory-safety-vulnerabilitiesz
' 2023 9 Github switch to a new search engine (BIackBird) written completely in
RUStI https:Z[www.zdnet.com[artic|e[github-builds-a-search-engine-for-code-from-scratch-in-rustZ 'l

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
' Visual Studio Code:
httgsﬂmarketglace.visua|studi0.c0m[items?itemName=rust-|ang.rust-analyzer
' lntelliJ ﬁRostOver):
httgsz€ €b 0g.'|etbrains.c0m[rust[2023[09[131introducing-rustrover-a-standalone-rust-ide-by-
et rams
' Eclipse:
htth:[[www.ec|iQse.0rg[downloadsﬂgackageszreleaseZZOl9-OQZrZecliQse-ide-rust-develogers-
incu es-incu ating-comgonents
' Online IDE (Rust play round):
httgszﬂglayxust-langnrgg
' Other online compiler5=
ttSII_-Il-0n ine FUSt COm iler

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
Va Rust Characteristics
' Strong-typed & statically typed language
' LLVIVI backend (native compiler) — gcc backend also a possibility in the future
' Ownership and lifetimes for variables
' IVIemory safety (allocation / access)
' No garbage collector
' Zero cost abstraction
' IVlove semantics

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
First rust program

***************Ending Page***************


***************Beginning Page***************
***************page number:17**************
First RUST Program
{
!( )s
}
' C-like syntax

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
"® Flrst RUST Program
main() mainO
{ {
!( ); ( )3
} }
' C-like syntax
' However, there are some differences:
' A function in C is defined by writing the return type first, while in Rust a
function is defined using a special keyword I
' ”printf” is a function in C/C++, while "print!" is a macro in Rust 'i

***************Ending Page***************


***************Beginning Page***************
***************page number:19**************
g»? l-
’ Flrst RUST Program
Rust C7C4+
helloWorld()-> helloWor1d()
{ {
!("Hello world l"); ("Hello world l");
return 6; return 9;
} }
' C-like syntax
' However, there are some differences:
' A function in C is defined by writing the return type first, while in Rust a
function is defined using a special keyword I
' ”printf” is a function in C/C++, while "print!" is a macro in Rust
' To siecifi the return value of a function, use the following syntax:

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
"§ Create your very first RUST program
1. Using rustc (rust compiler) command line:
' Make sure that rust is installed
' Create a file in a folder named "first.rs" and insert into it the "hello
world example (the one with a main function)
' Run the following command from command line:
' An executable file (e.g. first.exe if you run this command in Windows)
should appear in the first.rs file _
' Run the executable file created on the precedent step (e.g. run

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
',® Create your very first RUST program
2. Using cargo (rust package manager) from command line:
' Make sure that rust is installed
' Run the following command from command line: cargo new first
' You should see a new folder (named first) that was created in the
current folder with the following structure:

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
xxx
Create your very first RUST program

2. Using cargo (rust Qackage manager) from command line:
' Make sure that rust is installed
' Run the following command from command line:
' You should see a new folder (named first) that was created in the

current folder with the following structure:

= 9.1.9

\first\.gitignore

\first\Cargo.toml

\src [dependencies]

***************Ending Page***************


***************Beginning Page***************
***************page number:23**************
'5: Create your very first RUST program

2. Using cargo (rust Qackage manager) from command line:

' Make sure that rust is installed

' Run the following command from command line:

' You should see a new folder (named first) that was created in the

current folder.

' Modify the ”\src\main.rs” to contain the hello world example

' In folder "\first" execute the following command:

\fihst>cahg0 Pun iﬁé;
first v6.1.6 (E:\Lucru\Rust\temp2\fiPst) iﬁﬁﬁﬁﬁ
dev [unoptimized + debuginfo] target(s) in 6.815 gﬁﬁﬁﬁﬁﬁﬁ

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
V? Create your very first RUST program

3. Try it using rust playground:

' Open a browser and go to <5 >< +

https:[[play.rust-lang.org[ é c ' p'ay'r““"a"g'°rg L9 ‘k D G ’

' Write the hello world code I “ﬁnial-W

. rint!("Hello world");

' H|t the button from _ 1 p

the top-left side of the

we b_page Execution Close
Compiling playground v0.6.1 (/playground)
Finished dev [unoptimized + debuginfo] target(s) in 0.585
Running ta rget/debug/ playground

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
"E ' Create your very first RUST program
I 4. Use different features from sgecialized lDEs:
' Use features such as create new project (lntelliJ) or various
command/prompts from Visual Studio Code
' In the backend the cargo utility is usually used

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Basic Types

***************Ending Page***************


***************Beginning Page***************
***************page number:27**************
Basic types
Rust has several basic types, including:
1. Integers
2. Float values
3. Boolean
4. Character type

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Basic types
Rust integer types:
u——_
8 bit (unsigned) u8 uint8_t unsigned char
8 bit (signed) i8 int8_t char
16 bit (unsigned) u16 uint16_t unsigned short
16 bit (signed) i16 int16_t short
32 bit (unsigned) u32 uint32_t unsigned int
32 bit (signed) I32 int32_t int
64 bit (unsigned) u64 uint64_t unsigned long long
64 bit (signed) i64 int64_t long long
* gcc and c-lang provide a - type (but it is not part of the standard)

***************Ending Page***************


***************Beginning Page***************
***************page number:29**************
"E; BUS/C types
Rust integer types:
' General format is ”—” for signed integer or ”—”
for unsigned integers
' Signed integers (just like in C) are based on C2 complement format
' Besides this, there are two more integers types that have variable
length (depending on the architecture (32 or 64 bit). These types are
used as indexes in an array or as a representation of an offset or size
of a structure in memory.

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
,’ I B as, C types
Rust integer types:
' Rust supports the following notations for integer values:
' Ox => for hexadecimal values
' Oo => for octal values
' Ob => for binary values
' b'char' => for u8 values
' In addition, rust supports the use of character I as a digit delimitator
' The type of the integer value (u8,u16,i8,i16,u32 ...) can also be
specified as a suffix for a number to specify its type

***************Ending Page***************


***************Beginning Page***************
***************page number:31**************
f. -- 8051c types
Rust integer types:
Rust
123; // 132
9x12u8; // u8
01911991199164; // 164 value
123_456_789; // 132 value of 123456789
@xFF_FF_FF_FF; // 132 value with delimitators
b'A'; // an u8 with value 65 (ascii code for character 'A')
@011_33_77u643 // u64 value written in octal mode with delimitators
199usize; // value 166 as type usize;

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
,’ I B as, C types
Rust float types:
' General format is ”—" Where number of bits is either 32 or
64
' Format lEEE-754 (similar to C/C++) F'Oat 32 bits f32 ﬂoat
Float 64 bits f64 double
' "f32" and "f64" can also be used as
suffixes when creating a float constant
123.9;

***************Ending Page***************


***************Beginning Page***************
***************page number:33**************
"E B 051' C types
Rust boolean type:
' Identical to C/C++ (bool)
Boolean bool bool
' Size of bool type is 1 byte (just like in C/C++) with 1 indicating a true
value and O a false value
' Same constants just like in C/C++: - and - ||

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Basic types
Rust character type:
' Identical to C/C++ (char)
Character char char char32_t
' However, While the size of one character (for type char) in C/C++ is
one byte, in Rust the size of one character is 4 bytes (so that it can
represent any Unicode character value). The equivalent type in C++ is
' Character constants can be written using single quotes I

***************Ending Page***************


***************Beginning Page***************
***************page number:35**************
Variables & constants

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Rust supports both local and global variables.
A local variable in Rust is declared using the special keywork I.
let <variable_name> : <type> = <initialization_value>;
let <variable_name> = <initialization_va/ue>; Variable type is inferred from the
initializati0n_ value
let <variable_name> : <type>; Uninitialized variable. Its value must be set up
before using it.
let <variable_name> Uninitiatlize variable without a type
specification. Its value must be set up before
using it. When its value is going to be set up, its

***************Ending Page***************


***************Beginning Page***************
***************page number:37**************
VUFI able & Constants
A simple example of local variables in Rust.
fn main() {
let a: u32 = 123;
let b = 123;
let c = @xFFu64;
let d: bool;
let e;
printlnl< {} {} {} {} {} ,a,b,c,d,e>; ﬂﬁﬁggg
} Output
a=123,b=123,c=255,d=Uue,e=4£3 3;;

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
é?“
Var/able & (Jonstants

Rust does not allow the usage of uninitialized variables:
Rust

main() {

x: 3
(liX: IIJX);

}
ePPOP[E9381]: borrow of possibly-uninitialized variable: ‘x‘
——> src\main.rs:6:21

|
6 | println!("x={}",x);

| A use of possibly-uninitialized ‘x‘

|

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
However, the following code will work:
fn main() {
let X: 132;
println!( )3
x = 166;
println!( {} ,x);
} Output
In the second case the t oe of "x" is inferred to i32. 53%?“ initia'ized!
{n main() { .eﬁ
X = 199$

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
i?‘
Var/able & (Jonstants
Be default, any variable declared in Rust is immutable. The following
code will not compile because variable "x" can not be modified.
Rust error[E6384]: cannot assign twice to immutable variable ‘x‘
—-> src\main.rs:7:5
main() { |
X = 19; 5| let x = 19;
("x is ",x); l '
x = 199; I I. . c \
u . ,, _ | first a551gnment to x
( nOMl)( 15 ’X)’ | help: consider making this binding mutable: ‘mut x‘
} 6 | println!("x is {}",x);
7 | x = 100;
| AAAAAAA cannot assign twice to immutable variable
The usage of an in-mutable variable can be optimized when compiling
(e.g inline-ing variable value).

***************Ending Page***************


***************Beginning Page***************
***************page number:41**************
4*. ,. Var/able & Constants
In contrast, any C/C++ variables are by default mutable and can be
changed. As such, declaring a variable in Rust is similar to the following
code in C/C++;

Rust C/C++ (using const specifier)
in main() { void main() {
let x = 16; const int x = 16;
phintln!("x is {}",x); phintf("x is %d",x);
} }
C/C++ (using constexpr specifier)
void main() {
constexpn int x = 19;
pnint¥("x is %d",x);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
f. Var/able & (Jonstants
To declare a mutable variable, use the keyword mut in the following
way: let mut <variable_name>
Rust
Fn main() {

let mut x= 19;
println!("x is {}",x);
x = loo;
println!("now x is {}",x);
}
Now the previous code compiles and produces the following output:
xile
nowxis 100

***************Ending Page***************


***************Beginning Page***************
***************page number:43**************
@-
Var/able & (Jonstants
Once a variable has a type defined (via initialization or through type
inference) its type CAN NUT be changed (similar to how C/C++ works).
Rust
main() { EPPOP[E@398]I mismatched types
5; --> snc\main.rs:8:10
é = 19; 5 i let mut x'
("X iS ‘"5)’. | —————’expected due to the type of this binding
5 = 3
("now x is ",5); 8 | X = true;
} | MA" expected integer, Found ‘bool‘
In this case the second assignment tries to set the value of variable "x"
that is of type "i32" to bool (via constant.)

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
a
Var/able & (Jonstants
Keep in mind that the same code in C/C++ works (due to the rules of
promotion, any Boolean value can be converted into an int).
Rust C/C++
main() { mainO {
£3 £3
z = 16; z = 19;
("X is ",z); ("X iS ",z);
z = s z = ;
("now x is ",5); ("now x is ",5);
} }
xis 10
nowxisl

***************Ending Page***************


***************Beginning Page***************
***************page number:45**************
g
Var/able & (Jonstants

As a general observation, once a variable is declared with a specific
type, it can not be assigned with a value of a different type, even if an
implicit conversion is possible.
Rust

z = 19 3 |

é = 1 3 5 | let mut x = 19u32;
("X iS ",X); | ————— expected due to this value
_ 6 | x = 1u8;

} | MA expected ‘u32‘, found ‘u8‘
In this case "X" is of type with values between O and 232-1) and
the assigned value is of type . Even if every possible value for an I
(values between 0 and 232-1) can be stored in an - value, Rust will
still provide a compiler error.

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Var/able & (Jonstants
In contrast, the same C/C++ code compiles (rules of conversion will
automatically convert a u8 value to u32).

Rust C/C++
main() { main() {
5 = 19 3 x = 16;
5 = 1 ; z = ( )1;
("X is '35); ("X is ",z);
} }

***************Ending Page***************


***************Beginning Page***************
***************page number:47**************
Var/able & (Jonstants
To cast from a type to another type in Rust there is a ke word called I
that can be used. The general format is —:

For the previous case to work we need to rewrite it like this:
Rust
main() {
x = 16 3
}

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Var/able & (Jonstants

Let's see some examples:
Rust Rust
Fn main() { Fn main() {

let mut g = 255 as u8; let mut g = 255 as u8;

let mut y = 1 as 132; let mut y = 1 as 18;

y = g as 132; y = 5 as 18;

pnintln!("y is {}",y); // y is 255 pnintln!("y is {}",y); // y is —1
} }
First case is a simple one (as all possible values from u8) can be stored
in an i32. The second case (i8 to u8) keeps the value as it is (in terms of
bits) and just interprets the value in a different way.

***************Ending Page***************


***************Beginning Page***************
***************page number:49**************
its
Var/able & (Jonstants
Not all casts are possible (for example a cast between a number and a
bool is not allowed). The following code will not compile:
Rust
main() {

X = 1 ; ennor[E@954]: cannot cast as ‘bool‘

i = 3 ——> sr~c\main.|"s:7:1@

("y iS ",1); | MAMA/‘M help: compare with zer~o instead: ‘x != 9‘
}
C/C++ has a different logic (any value that is O can be implicitly seen as
false and any value different than O can implicitly be seen as true).

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
Var/able & (Jonstants
Let's see some examples:
Rust
main() {
1 = 9 ’
1 = z ;
("y is ",x);
}
In this case, a truncation to the first 8-bits happens for the value of 258
(keep in mind that an u8 cand only store values between 0 and 255).
258 = 0000 0000 0000 0001 0000 0010
= the code will truncate to the last 8bits (least significant one)
= as such the result of the cast will be 1

***************Ending Page***************


***************Beginning Page***************
***************page number:51**************
its
Var/able & (Jonstants
In case of integer to float conversions, the program attempts to obtain
the closest float value to the integer one (that can be represented in
the float format).
Rust Rust
main() { main() {
X = 199 3 x = 6XFFFF_FFFF ;
x = Q ; y = 8 ;
x = X ; y = X ;

("y is ",x); ("y is ",x);

("X is ",X); ("X is ",X);
} }
y is 100 y is 294967300
xis 100 xis

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
aﬁﬁi@q
Var/able & (Jonstants
In case of float to float conversion (every f32 can be converted into an
f64, while an f64 is approximated to the closest f32).
Rust Rust
Fn main() { Fn main() {
let X = 1.9123456789 as ‘F64,’ let X = 1.7976931348623157E+368 as ‘F64;
let mut v = 6 as {32; let mut v = 6 as {32;
1 = X as 1c32; v = X as {32;
phintln!("y is {}",v); phintln!("y is {}",v);
println!("x is {}",X); println!("x is {}",x);
y is 1.0123457 y is inf
x is 1.0123456789 X is 17976931348623157000....OOO
If the f64 value is outside maximum value possible in f32, the
conversion will enforce inf as the value of f32.

***************Ending Page***************


***************Beginning Page***************
***************page number:53**************
_,. Var/able & Constants
To declare multiple variables at the same time use the following format:
- let (varl, varz, varn) = (valuel, valuez, valuen)

The types for varl, varz, varn are inferred from the associated values.
Rust
Fn main() {
let (mut 5, mut v, mut g) = (1,2,3);
let (a,b) = (1.23,tr‘ue); M
phintln! ("{x}, {y}, {z}, {a}, {b}"); 1,2,3,1.23,true
K = 193 10,20,30,1.23,true
1 = 29;
z = 36;
Println! ("{X},{y},{Z},{a},{b}");
}
The number of values provided must be the same as the number of
variables.

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
*- -- Var/able & (Jonstants
Rust also allows shadowing 9 meaning that a variable with the same
name and possible different type cand be declared with an inner block
and possible be initialized with the initial variable.

Rust
Fn main() {
let x: i32 = 19;
phintln!("x is {}",x); M
{ xis 10
let x: bool = true; innerxis true
pnintln!("inner‘ x is {}",x),'
}
phintln!("outteh x is {}",x);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
_,. Var/able & Constants
Shadowing is often used to change the mutability state of one variable
for a limited period of time by using a copy if that variable.

Rust
Fn main() {
let x: i32 = 16;
println!("x is {}",x);
{ M
let mut g = x; _
5 = 29; // x is now mutable and can be changed 8'510_
println!("inneh x is {}",5); innerXIsZO
} ouﬁerx510
println!("outteh X is {}",x);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
f. Var/able & (Jonstants
For global variables, use the keyword static instead of let (let is design
for stack/local variables).

Rust
static x:132 = 19;
tn maino { m
v = X as t32; xile
println!("y is {}",v);
pnintln!("x is {}",x);
}
A static variable implies a possible mutable variable (if mut keyword is
being used) and guarantees an allocated space in the binary data.

***************Ending Page***************


***************Beginning Page***************
***************page number:57**************
*- -- Var/able & (Jonstants
Rust also allows the usage of the special keyword const to define a
constant. The main difference between a const value and a static value
is that a const value is always immutable and will be replaced with its
value upon compiling phase.

Rust

const xziBZ = 19;

fn main() {
let mut y = 6 as f32;
y=xas f32; X'510
Println!("y is {}",x);
pnintln!("x is {}",x);

}

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
» Var/able & (Jonstants
Both static and const keywords can be used in a local function:
Rust Rust
fn main() { fn main() {
static x:i32 = 19; const x:i32 = 16; m
let mut y = 9 as f32; let mut y = 9 as f32; yile
y = x as f32; y = x as f32; xis10
println!("y is {}",y); println!("y is {}",1);
println!("x is {}",x); println!("x is {}",x);
} }
OBS: a mutable static value requires unsafe code (more about this on a
different course).

***************Ending Page***************


***************Beginning Page***************
***************page number:59**************
a?‘
Var/able & (Jonstants
Another difference between - and I is that type has to be
provided in case of- and keywords and can not be inferred.
Rust
main() { error: missing type For ‘const‘ item
= 19; -I> src\main.rs:4:12
("X iS "J )3 4 | const x = 19;
} | A help: provide a type for the constant: ‘x: i32‘
Rust
main() { error: missing type for ‘const‘ item
= 193 —I> src\main.rs:4:12
("X i5 H: )3 4 | const x = 19;
} | A help: provide a type for the static variable: ‘x: i32‘

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
i?‘
Var/able & (Jonstants
The same logic applies for initialization value (if in case of let, one can
define a variable and assigned its value after this), in case of const and
static this is not possible.
Rust
main<> { ETTZPQKEZiZliZlZitem Wm“ my
XI 3 |
X = 19; 4 | static x: i32;
( "X: || , X); i /\/\/\/\/\/\/\/\/\/\/\/\/\_|
} | help: provide a definition For the static: ‘= <exph>;‘

***************Ending Page***************


***************Beginning Page***************
***************page number:61**************
£5 -
" Var/able & Constants
Observations:
1. There is no such thing as O initialization in Rust (for global
variables).
From this point of view, Rust tries to make everything clear and
make sure that there is no unknown behavior due to this case.
2. In case of constants, Rust recommend using upper cases (this is
considered a warning and will not affect the compilation phase).
warning: constant ‘x‘ should have an upper case name
——> src\main.rs:4:12
|
4 | const x: i32 = 19;
| A help: convert the identifier to upper case (notice the capitalization): ‘X‘
|
= note: ‘#[warn(non_upper_case_globals)]‘ on by default

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Variable & Constants
Com pa ration with C/C++ similar forms:
-D—
let let mut x: i32 = 10; int x = 10;
let mut x: i32; int x;
let mut x = 10; auto x = 10;
let mut x; N/A
x=1Q
const const x: i32 = 10; const int x = 10;
constexpr int x = 10; __
static static x: i32 = 10; const int x = 10; // as a global variable

***************Ending Page***************


***************Beginning Page***************
***************page number:63**************
Operators

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
"® Operators
Rust supports the following operators:
—m—
Arithmetic (I I I I I) Yes Yes
Comparation (III...) Yes Yes
Logical OR , AND or NOT ( I .I) Yes Yes
Bit operators: bitwise OR, bitwise AND, shifts ( I I I I I) Yes Yes
Assignments(l...-.-..--) Yes Yes
Increment / Decrement operators (I I) N/A Yes
Negate operator ( I ) N/A (use I) Yes
Conditionally operator (I) 9 condition ? Value for true : Value for false N/A Yes
Member access operator ( I.) Partial (only I) Yes

***************Ending Page***************


***************Beginning Page***************
***************page number:65**************
t?‘
Operators
Rust has a very comprehensive compiling error system that besides
clearly explaining an error, it also provides some directions/ideas on
how to fix that error. In particular for operators, Rust can identify some
of the Widely used operators that are not supported (such as increment
or decrement) and provide guidance on how to fix some errors.
Rust
_ error: Rust has no postfix increment operator
Inalll() { --> src\main.rs:5:7
x = 16; |
X++j 5 i x++; f
_' n _ H _ AA not a valid post ix operator
} help: use ‘+= 1‘ instead
|
5 | { let tmp = x; x += 1; tmp };
| +++++++++++ ~~~~~~~~~~~~~~~
5 - x++;
5 + x += 1;

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
t?‘
Operators
Rust has a very comprehensive compiling error system that besides
clearly explaining an error, it also provides some directions/ideas on
how to fix that error. In particular for operators, Rust can identify some
of the Widely used operators that are not supported (such as increment
or decrement) and provide guidance on how to fix some errors.
Rust
main() { error‘: ‘~‘ cannot be used as a unar~y operator‘
X: = 193 --> src\main.r‘s:5:19
x = ~53 |
("X = ax); 5| X = ~X;
} _ | A help: use ‘ !‘ to perform bitwise not

***************Ending Page***************


***************Beginning Page***************
***************page number:67**************
Operators

Operators order:

* / % left to right

+ - left to right

<< >> left to right

& left to right

A left to right

| left to right

== != < > <= >= Require parentheses

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Functions &
Expression Statements

***************Ending Page***************


***************Beginning Page***************
***************page number:69**************
v5 Fun ct/ons
Function in Rust are defined using the keywork I in the following way:
——
fn <name> () {...} void <name> () {...}
fn <name> (parameters) {...} void <name> (parameters) {...}
fn <name> () -> <return_type> {...} <return_type> <name> () {...}
fn <name> (parameters) -> <return_type> {...} <return_type> <name> (parameters) {...}
Where parameters are defined in the following way:
* <param_name>:<type> [, < param_name >:<type>, ]

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
Exa m p I es:
Rust m
fn sum(x:u32, yzu32) —> u32 { Xile
return X + y; Xi530
}
fn print_x(x:u32) {
println!("X is {}",x);
}
fn main() {
let mut gzu32 = 19;
print_x(§);
5 = sum(1@,29);
pPint_X(z);
}

***************Ending Page***************


***************Beginning Page***************
***************page number:71**************
i?‘
Examples:
Rust
c0mpute(x: , y: ) —> {
X = X * y;
return X+y; error‘[E9384]: cannot assign to immutable argument ‘x‘
} --> snc\main.r‘s:4:5
. . l
pr1nt_x(x. ) { 3 | Fn c0mpute(xzu32, yzu32) -> u32 {
("X iS ",X); | - help: consider‘ making this binding mutable: ‘mut x‘
} 4 l X =X *y;
main() { | AMA/‘MM cannot assign t0 immutable argument
5: = 19;
pnint_x(§);
g = c0mpute(19,29);
pPint_X(X);
}

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
-~' FUncUons
Examples:
Rust Rust
tn c0mpute(x:u32, yzu32) —> u32 { tn compute( mut 52u32, yzu32) -> u32 {
X = X * y; z = z * y;
return x+y; return 5+y;
} }
tn print_x(x:u32) { tn print_x(x:u32) {
println!("X is {}",x); _ println!("X is {}",x);
} }
tn main() { tn main() {
let mut §:u32 = 19; let mut gzu32 = 10;
print_x(§); print_x(§);
5 = c0mpute(19,29); 5 = c0mpute(19,26);
print_x(§); print_x(§);
} }

***************Ending Page***************


***************Beginning Page***************
***************page number:73**************
la
.
FUncUons
Rust has a keyword ( return ) that can be used to return a value from a
function (similar to C-like languages). At the same time, Rust allows a
different format of returning a value by writing the value that you want
to return directly.
The following two Rust programs are equivalent.
Rust Rust
va1ue_3() —> va1ue_3() —>
{ {
. <-> .-
main() { main<> {
x = va1ue_3(); x = va1ue_3();
("X is ",X); ("X is ",X);
} }

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
é?‘
.
FUncUons
Rust has a keyword ( return ) that can be used to return a value from a
function (similar cu C-like languages). At the same time, Rust allows a
different format of returning a value by writing the value that you want
to return directly.
The following two Rust pro
Rust
va1ue_3() —> \ .ue_3() —>
{ {
} <-> 1,-
main() { main<> {
x = va1ue_3(); x = va1ue_3();
("X is ",X); ("X is ",X);
} }

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
Express/on statements
Rust also allows an expression statement where something gets
computed based within a statement {...}

Rust
main() {
v = 19; m
<"X = X ">;
}
Notice that the same return format (with a value) is being used in this
case (without the I character at the end)

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
e
EXPIPSSIOH statements
In this format, some even more complex operations can be performed:
Rust
main() {
y = 19;
};
("X = X ")3
}
In this case, the value of "x" Will be ”a+y+5”

***************Ending Page***************


***************Beginning Page***************
***************page number:77**************
g
EXPIPSSIOH statements
In this format, some even more complex operations can be performed:
Rust
main() {
y = 19;
sum(2,5)+dif(7,3)
};
("X = X ")3
}
It is also possible to create nested functions within an expression
statements and use them to compute the return value.

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
*- -- Express/0n statements
Nested functions can be added Within an existing function:
Rust
Fn main() {
Fn sum(x:i32, yziBZ) —> i32 {
“y M
} -
Fn tummy, Wm) -> 132 {
X-y
}
let y = sum(16,29);
let x = dif(26,19);
pPintln!("X = {X}, y = {y}");
}

***************Ending Page***************


***************Beginning Page***************
***************page number:79**************
Basic statements

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
BUS/C statements
|\/lost of basic statements that exists in C/C++ can be found in Rust as well:
——D
If statement Yes Yes
While statement Yes Yes
For statement (classic) N/A Yes
For each Yes Yes
Loop Yes N/A
D0...While statement N/A Yes
GoTo N/A (partial support) Yes

***************Ending Page***************


***************Beginning Page***************
***************page number:81**************
'® If

If statement format:

' Icondition <then statement>

' I condition <then statement> - <e|se statement>

Obs:

1. Notice that condition does not requires parentheses (...)

2. Because of this, <then statement> and <else statement> can not be
simple instructions (they have to be embedded in a block). i

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
Example:
Rust C/C++ (v1) C/C++ (v2)
Fn main() { void main() { . .

let mut 5 = 1; int 5 = 1; V01d12i1;(2 i.

if x>9 if x>9 . — _ ’

_x+=i' (;+=i'{ 1f (5)9)

println!("x = {x}"); printf("x = %d", 5); } pr1ntf( X = Ad ’ 5);

} }

***************Ending Page***************


***************Beginning Page***************
***************page number:83**************
é»- .-_
}J,,v ‘if
Example (if else) :
Rust C/C++ (v1) C/C++ (v2)
Fn main() { void main() { . .
let mut g = 1; int 5 = 1; V01d12i1;(l i_
1* xiii. “C ‘iii? if <i>9>
— ’ — ’ E13
} else-i. } els?_i. else
println!("x = {x}"); printf("x = %d", K); } pPlntf( x = Ad , Z);
} }

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
Parentheses land I around the condition are allowed, the code
compiles but triggers a warning:
Rust
maj11() -{ warning: unnecessary parentheses around ‘if‘ condition
_ , ——> src\main.rs:5:8
. 5 ‘ 1’ |
11c (P9) { 5 | if (X>o) {
} H _ ,, _ = note: ‘#[warn(unused_parens)]‘ on by default
} ( )( _ X )) help: remove these parentheses
|
5 - if (x>9) {
5 + if x>9 {
—

***************Ending Page***************


***************Beginning Page***************
***************page number:85**************
If statement can also be used as an expression statement:
Rust C++
main() { main() {
x = 31; x = 31;
y = if x>29 { x/2 } else { x * 2 }; y = x>29 P x/2 : x * 2;
("y = y ")s ("y = %d", y);
} }
Notice the fact the return value is specified just like in the case of
expression statements for both then and else parts.

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
a
while
While statement is similar to the one from C/C++:
- while <conditi0n> { do block }
Just like in if statement case , notice that the <conditi0n> does not
need to be surrounded by parentheses.
Rust C/C++
main() { main() {
Z = a; 5 = 1; M
while §<3 { while (g) { X =0
<"x= X ">; ("X = z); >< =1
Z = 5+1; gigl; X =2
} }
} }

***************Ending Page***************


***************Beginning Page***************
***************page number:87**************
i?“
while
Similar to if statement , the condition MUST be followed by a block
(and can not be a simple instruction like in the case of C/C++).
Rust
main() { error: expected ‘{‘, found ‘x‘
X = 9, ——> src\main.rs:6:9
. — ’ |
while x<3 » 5 | while x<3
Z = 5+1; | ————— ——— this ‘while‘ condition successfully parsed
-- = -- - | |
( X X )’ | while parsing the body of this ‘while‘ expression
} 6 | x = x+1;
C/C++ i expected {
main() { help: try placing this code inside a block
x = 1; |
while (E) 6 | {x = x+13 }
| + +
X_+=1;
} ("X = K); The C/C++ code will compile

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
é?‘
while
Both break and continue keywords can be used in an While statement,
with the same logic as the one from C/C++ (break or continue the
loop).
Rust
main() {
5 = 1;
while §<16 {
if§%3==9{br‘eak;} M
}
(" X ")s
}

***************Ending Page***************


***************Beginning Page***************
***************page number:89**************
Let's consider the following problem:
- Let there be a number of form E, where I, I and I are digits
between 1 and 9
- Can we find the smallest number of this form that has the following
relation between I, I and I
1) a = b x 2
2) b = c x 2
The answer is simple -> there are two numbers that respect this
condition: 421 and 842, and as we are searching for the smallest one

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
. while
Let's how the preVIous problem can be solved In Rust:
Rust

main() {
while §<19 {
M = 1;
while y<19 {
Z = 13
while g<19 {
(H X J y J Z ")3
break; 4, 2, 1
} 8, 4, 2
E13
}
yjl;
1»
E13
1»
}

***************Ending Page***************


***************Beginning Page***************
***************page number:91**************
Let's how the previous problem can be solved in Rust:
Rust
main() {
( z, x, z) = (1,1,1);
M = s
while (g<16) && (lgggg) {
1 = 1;
while (y<16) && (lggge) {
z = 1;
while (;<19) && (lggge) {
it (z == y*2) && (y == ;*2)
{
("X, y, Z");
M = s
} M
yjl;
}
E13
}

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Rust has a way of providing a name (a label) for every loop statement
(for, while or loop).

This is done via the following format:

- '<name>: <for|while|loop>

Example: 'first_while: while

This allows keywords like break or continue to explicitly say if we want
to break the current loop or if we want to break a specific loop based

***************Ending Page***************


***************Beginning Page***************
***************page number:93**************
Let's how the previous problem can be solved in Rust:
Rust
main() {
( z; x; z) = (1,1,1);
' : while g<16 {
y = 1;
' : while y<19 { -
z = 1;
While ;<1e {
if (z == y*2) && (y == ;*2)
{
}
E13
}
3/513
} BEE-
E13
;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
,ﬁ? loop
Rust also has a special loop called loop statement
- loop {... do block ...}
In a nutshell a loop statement is nothing but a while true {...}
statement.
Rust C/C++
Fn main() { VOid main() {
let mut 5 = 9; int 5 = 1; M
loop { while (E222) { O
pnintln!("{x}"); pnintf("x = %d", 5); 1
if 5>=3 { break;} if (g>=3) break; 2
x+=1; x+=1; 3
} }
} }

***************Ending Page***************


***************Beginning Page***************
***************page number:95**************
The main advantage of the loop statement stays in the fact that it can
be transformed in an execution statement where the return of the loop
can be obtained via a break <va|ue> statement.
Format: let <variab|e>:<type> = loop { break <va|ue> };
Rust
fn main() {
let (mut §,mut y) = (24,18);
let cmmdc:132 = loop {
else if y<§ { y —= g}
else { break 5 } —
};
pnintln!("{cmmdc}");
}

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
Type can be omitted and will be inferred from the value returned via
break statement.
Format: let <variab|e> = loop { break <value> };
Rust
main() {
sum = 6;
counter = 9;
first_1@_sum = loop {
if counter > 19 { break sum; } m
sum += counter;
counter += 1;
};
println!(" first_1@_sum ")3
}

***************Ending Page***************


***************Beginning Page***************
***************page number:97**************
"if let" tries to match an expression with a specified pattern. If the

expression matches the pattern, the assignment is being performed and

the code from the <then block> is being executed. Otherwise, the <e|se>
block, if present is executed.

' if let <pattern> = <expression> { then block }

or

' if let <pattern> = <expression> { then block } else { else block }

This statement is NOT to be confused with the if va r=<expression>

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
"® If let
The assignment (in case of if let <pattern> = <expression> {...} usually
translates in a match of:
' An enum variant
' A structure with parameters
' Numerical constants
' Tuples
We will discuss more about this type of statement when we talk about
enums, errors and variants (as this is where this statement is mostly use

***************Ending Page***************


***************Beginning Page***************
***************page number:99**************
i?‘
If let statement (example):
Rm M
ma1n(i i 19_ xile
if 5 = X { pr'intln!("x is 5 ")3 } gutriejstigjglsrildnzotin the form (x 1)
if 19 = x { println!("x is 19"); } '
touple = (1,2);
if (x,2) = touple { println!("A touple of x and 2");}
if (x,1) = touple {
} else {
println!("current touple is not in the form (x,1)");
}
}

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
.
If let
If let statement (example):
Rust
— }

***************Ending Page***************


***************Beginning Page***************
***************page number:101**************
. If let
If let statement (example):
Rust
if (x,2) = touple { println!("A touple of x and 2");}
if touple.1 == 2 {
x = touple.9;
println!("A touple of x and 2");
}

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
. If let
Let's discuss another example:
Rust
% warning: irrefutable ‘ii: let‘ pattern
. ——> src\main.rs:2:8
m§1n() { |
1‘F v=6{ 2| iFletv=9{
println! (ll V II); i AAA/\AAAAA
} = note: this pattern will always match, so the ‘if let‘ is useless
} = help: consider replacing the ‘if let‘ with a ‘let‘
= note: ‘#[warn(irreiutable_let_patterns)]‘ on by default
In this example, ”-" will always be true (in reality there is no
pattern to match here —just a simple assignment . The code will
compile, but this no different than just writing ” ”.

***************Ending Page***************


***************Beginning Page***************
***************page number:103**************
Let's discuss another example:

Rust

Fn main() { m
let v = 29;

let v = o { 20
println!("{v}");

}
pnintln!("{v}");

}

This is a similar logic 9 however, notice that the "v" variable from

the if let statement has a limited lifetime to the <then> block and

will not affect the outer "v" variable. As a result, the second println

will print the value 20.

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
a
If let
Let's discuss another example:
Rust C++
_ m #include <stdio.h> m
ma1n() { |nner=0 int main() {
. V = 293 outer=20 int = 29;
1* .V=@l. .. ir<=@>{
pn1ntln!( 1nneP = v )3 pnintf("inner = %d" ),
} ) )
pnintln!("outer = v ")3 grintF("outeP = %d" )_
} ) J
}
Keep in mind that these two code are . In case of
C++ example, variable v is first instantiated with value O and then
evaluated (and since O = false) the <then block> is not executed.
Furthermore, it's the same variable "v" and as such the second
printf will print value 0.

***************Ending Page***************


***************Beginning Page***************
***************page number:105**************
,’ While let
The - form can be used in a loop with a similar logic (pattern
must match in order for the loop to run).

main() {
1 = o { On the first glance, we would expect this
¥>=3 { 3 } while to run for 3 iterations , print values
y = y + 1; .
. from 1 to 3 and eXIt.
( y ),
}
This is not to be confused with while va r=expression statement

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
.
while let
The - form can be used in a loop with a similar logic (pattern
must match in order for the loop to run).
Rust
main()
i 1>= .Pea 3 }
x = x + 1;
(" y ")3
}
}
This is not to be confused wit
from C/C++.

***************Ending Page***************


***************Beginning Page***************
***************page number:107**************
The - form can be used in a loop with a similar logic (pattern
must match in order for the loop to run).
Rust
main() warning: irrefutable ‘while let‘ pattern
while { —i> src\main.rs:4:11
1 >0: 1 Pea 3 } 4 | while let mut y = @{
M = X + 3 l /\/\/\/\/\/\/\/\/\/\/\/\/\
<" y ">; | \ _ \
} = note: #[warn(1rrefutable_let_patterns)] on by default
= note: this pattern will always match, so the loop will never exit
} = help: consider instead using a ‘loop { ... }‘ with a ‘let‘ inside it

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
t?‘
while let

The - form can be used in a loop with a similar logic (pattern
must match in order for the loop to run).
Rust Rust

main() main() {

whilem{ whlle {y = 6.

i =1; 1‘.Pea 3 } — 1+ W3 { break; }
(flyn). ¥=¥+13

} ’ (" y ");

} }
}

This is not to be confused with While var=expression statement
from C/C++.

***************Ending Page***************


***************Beginning Page***************
***************page number:109**************
The assignment (in case of while let <pattern> = <expression> {...} usually
translates in a match of:

' An enum variant

' A structure with parameters

' Numerical constants

' Tuples
We will discuss more about this type of statement when we talk about
enums, errors and variants (as this is where this statement is mostly use

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
"let else" tries to match an expression with a specified pattern. If the
expression matches the pattern, the assignment is being. Otherwise, an
error (that will be discuss in the next courses) will be thrown:

let <pattern> = <expression> else { error }
This is mostly used with enum , variants or structs and we will further
discuss this type of behavior at that point.

***************Ending Page***************


***************Beginning Page***************
***************page number:111**************
é?
Some examples of "let else”:
Rust Rust
main() { main() {
touple = (1,2); touple = (1,3);
(x,2) = touple else { (x,2) = touple else {
panic!("Fail to assign !") panic!("Fail to assign !")
}; };
println!(" x ")3 println!(" x ");
} }
src\main.rs:3:31
stack backtrace:
9: std::panicking::begin_panic_hand1er

***************Ending Page***************


***************Beginning Page***************
***************page number:112**************
let else
Some examples of "let else”:
Rust Rust
touple
(<number>,2)

***************Ending Page***************


***************Beginning Page***************
***************page number:113**************
," I 0 th er S ta te m en t5
There are other more complex statement in Rust, such as:
' for (equivalent for classical for from C/C++ and a foreach)
' match (an equivalent for switch in C/C++ but more oriented to
pattern matching)
As all these statements are either more complex or require
understanding of different concepts in Rust, we will discuss them
during the next courses. l'

***************Ending Page***************


***************Beginning Page***************
***************page number:114**************
- @@

***************Ending Page***************


