***************Beginning Page***************
***************page number:1**************
Rust programming
Course — 5
Gavnm Dragos

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
®; Agenda for today
1. Tuples
2. Arrays
3. Structures
4. Newtype idiom
5. Type alias
6. B0x(heapa|location)

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
L

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
E; Tu pies
Tuples are un-named structures that can be used to quickly transfer
multiple values. Similar to other languages (eg. Python), a tuple is
defined via the .2

t,» i
rlil' , ,i:i_l, ~i;
LL : t1, 2, 2.5);
In this example we have two tuples (one with its type specified (i32,char) and
another one with its type inferred from the value (i32, i32, f64).
Tuple members in Rust can be access via an index (.0, .1, ...)

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
g; Tuples
Let's see an example and look how the assembly code looks like:
4y» l muv dwurd ptr‘ [rsp+40h],1
n: l . jv : v1, w l; mov dwnrd ptr‘ [r5p+44h],ll1h
ME! : .ll
l.l 7 ‘E ,- Output mov dword ptr‘ [rsp+40h],2
printlnll" ‘_ U; ‘ ‘
; l2 Bl muv dwurd ptr‘ [rsp+44h],42h

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
® Tu ples

Let's see an example and look how the assembly code looks like:
Rust C++
n-i manly» l , , v H , ‘hut mun,

let iii’ t. (he, dim} : l1, i), 1m m a;

- e 1 \.

pr‘intln!l“-l"l"- n; H "i. .
‘ n.‘ i1 nia)n() l
‘ tempt:(1, };

“Le : z;

The same code in C++ will look like the tun; : ‘+9:
following. A tuple can be considered in 7 Prlﬂﬂ Md‘ r Ute’ t-"Llli
this case a syntax sugar, as you don't need ’
to define the actual structure l

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Tuples
Tuples also support destructuring (or structure bindings in C++) 9
allowing one to assign the values from a tuple to a set of variables.
Rust Rust
mini; i iiB]lil,l i
7:1 ) Z i1. ‘A'i: r:' i: i1, 'A'i;
printlnlii" . , L, .l. 2L“); ii : 100;
l M pi‘iritlﬂl(" i 1 i, -li ‘1i;
i mm-
ii-

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
. Tu ples
Be carefull when destructuring a tuple that contains object that don't
have the Copy trait.

RIIS!
"mm; 1|
V: 1 ‘Y : V10, ::H\Im‘("ABC"ﬁ);
printlnlll" - , L, .1, ‘15;;
L
err-WHPBBZJ. born-w m wrtzuly maxed mm! t
\
\ V Mu’ w l 41L ‘rm-‘u my»
-\\ WWHVH 1 mum mm.»
\ “rm mnmm ML “m Alftlll Wm»

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
E; Tu ples
Be carefull when destructuring a tuple that contains object that don't
have the Copy trait.

i,‘ i
I 1, I‘) Z r; v ill‘ i’ l ,1) Output
winning“ , i ‘. LB ,1, 4); 10,10,ABC
i.
This only applies for the members of the tuple that have been moved. In this
example, the first member is an i32 and has the Copy trait, meaning that after the
destructuring it will still be available‘

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
. Tu ples
Tuples (and in particular small tuples) are often use to easily return
multiple values from a function.

RIIS!

gutinviniwmjwﬂl: , ‘11: ) r.» L , l l

l £1»: 1
2»

mmntl l

whit-1w, ll \hidl'm") 7 gwtituniwuvl'le, 2m;

printlnll"ma:< : l15> .‘Lua . min: mu ,Jliua "\i

l

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
V
Arrays L

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
E; A rrays
Arrays in Rust are (just like in C/C++) sequences of data ofthe same type.
Arrays have a ﬁx size (that can not be change dynamically) and has to be know at
compile time‘ This allows rusr to easily check if an index is outside the array
boundary‘
To create an array, use one of the following forms:
a)
b)
c) — With v1 n ofrvpe <wpe>
d) _Wilhv1“0flvpe<tvne>
e) —,where v1 will decide the <type>, and with v2 n must be convertible to
the wpe or v,
n _where v, will decide the <type>, and With v2 n must be
convertible to the type of v1

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Arrays
Let's see some examples on how to build an array.
RUS!
Haim'i [
51; i ;s[ : [2; si;

.1»; [ ; 3] : [20; a];

4:‘ [1, 2, 3];

"a : [1.5, 2.0, 3,0]:

f :[106u8, z, a];

a‘; : ["abc". "we", “ng"];

.-i 1 [a ;3] : ["123"; a];
Keep in mind that an array must be initialized!

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
. Arrays
Let's see some examples on how NOT to build an array.
RMSI
a; [ ; 5] 7 [0; a]; ':> x - . New an m, hm a H.“ sue m 5
I \ \
RUE!
H3117‘) v, 1 e a 132.‘. : ,2.3.
‘1: [ ; 5] Z [1,2,1]; -:> 1 " ‘Ll 9. 3,JWMM,-,Wumm,f
|\ 1 ‘ < Mh-mPHV", hmml \‘m- “th 1 Mum-uh

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
. Arrays
Let's see some examples on how NOT to build an array.
Rust
17[1, 2.5, a]; ':> \
, 1‘ 1M WM;
1 \ - Y mama Wm" 44mm‘ rjnwnmyprlﬂt "my
RUE!
mm vK “T”£i33::1".:§f§a§éh“d "w
\ : [ , 2's, s]; ‘I’ x

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
g; Arrays
Let's see an example and look how the assembly code looks Ilke:
lea rax,[rsp+1Ch]
(‘v lea rcx,[rsp+1£h]
\v add rcX,14h T‘ \ \ ' “ ‘
a: [ ; 5] Z [ﬁg]; mov qwurd ptr‘ [temp_ptr_e|ld],rcx
‘[8] 7 1- mov qword ptl" [tempiptricurrent],rax
1 v if WHILEiLDOP:
‘ ‘[J] Z 9' muv rcx,qwor~d ptr‘ [temp_ptr_em1]
\ mov raX,qwurd pt!‘ [temp_ptr'_cur'r'er|t]
mov qword ptr‘ [r5p],r‘ax
(mp rax,rcx
je ENDJMHILE
muv rax,qwor~d ptr‘ [Pip]
mov dword ptr' [rax],7 w , ~
add rax,A
mov qword pn- [tempiptricurrent],rax
jmp MHILEiLOOF
Enn_wuns;

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
®
Arrays
Let's see an example and look how the assembly code looks like:
RIM’! C4‘
"lalm'j
l alfv];
d1 l ; 5} : [7:5], - rmmrmgwmw : .-,;
* Leup w em : aphid;
while (Té'lvlpil'trifMPH?'W-(Tempiph'iend) (
‘tvaiptrisuv'r'l'lnt : 7;
temp pt?‘ U” l erlt++;
l
l

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
E; Arrays
Let's see an example and look how the assembly code looks like:
i'» < vi s ‘
i mov dword ptr [r'sp+1Ch],1
1; i :5]:[“;5]; y y
‘[5] 7 1; w >i s i
1m Z q; mov dword pt!‘ [rsp+25h],9
Notice that there is no boundary check [in fact since the size of an array is a
constant, accessing an array element via a constant index can be check for
boundary check at compile time. The advantage is the fact that this type of access
are really fast.

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
g; Arrays
Let's analyze the following example:
I l
This is because Rust knows that “a” has 5 elements and accessing
element 100 will mean accessing memory outside array boundaries. /

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Arrays
Let's see another example where the index is not a constant:
Rust Eﬂrgﬂlﬂml
mm: = .; [package]
name : "ﬁrst"
HFHVH) i. version : "0.1.2"
.i: [ ; 5] : [9,- 5]; Editiuri a "2021"
Jil : : rand: :iarijumi');
1w 1 Z 1; [dependencies]
l hand = "9.3.5"
In this case Rust does not know at compile time what is the value of
idx‘ This means that it must check this during execution time.

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
g; Arrays
Let's see another example where the index is not a constant:
mm; :prﬂludri : ~;
lea rcx,[a]
i i i XOI‘ edx,ed>< i a ~
.i;[ ;5] Z [g3 5]; mov h8d,14h i4 7 a,‘ i i s i
ii: : raridzz i’); call memset
1pm] : 1;
i
In other words, since we are filling the entire array with O, Rust
optimizes it and uses a memset.

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
g; Arrays
Let's see another example where the index is not a constant:
mm; ; prf-ludri : ~;
i) i call randzzrandommsizm
.i; r : 51 : re; 51; mov qword ptr [idx],r‘a><
M : : raridi: i’);
win j : 1;
Notice that rust deduces the type of random value from the type of idx.
We will discuss more about this specific behavior for templates /
generics in Rust in another course.

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
®; Arrays
Let's see another example where the index is not a constant:
mov rax,qwor‘d pt!‘ [idx]
.7 .. 1 (mp rax,5
randﬂpmludru , setb 31
y test a1,1
‘l ‘> jne SET_VALUE
HI [ 3 5] Z [9; 5]; jmp PANIC
m: : randzz U; SETivALUE:
1pm] : 1; mov Faxmword ptr [idx]
} mov dwur-d w a[ra><*4],1
In other words, Rust checks to see if
idx is smaller than 5 before accessing PM": my m qwd W [idx]
a[idx]. If it is not, a runtime error lea "MU-1
t" b th mov edx,5
WI e FOWn. call paniciboundsicheck
UdZ

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Arrays
Let's see another example where the index is not a constant:
RUE!
mm; ; '; _
t :51“; 51;
Jil>1 : ravid::r*aiirlovi();
i[ Li 1 7 1;
prjntln! i" it . Cliil‘l);
However, in this case it is clear that idx is a value between O and 4, and
as such a[idx] will ALWAYS be valid. Rust, however, still performs the
boundary checks in this case (only on debug mode).
This is different from C++ (where these cases will be faster l)

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
® Arrays
Let's see another example where the index is not a constant:
Rust
m minml l
luL rut a: [192; 19000] 7 [0; 19999]; M
let wt sum : B;
i \' 10669 ‘l
a[i] : l(>Sle + i 2‘; $100‘; 7r? 131;
sum +7 a[i] a; usize;
i +: 1;
r
prjmlnHWl‘, Sum‘);
l
In this case it is clear that “i” will always be smaller than 10000 but Rust
will check boundaries, nevertheless.

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
g Arrays
Let's compare the speed of a Rust and C++ program:
extern w‘ { Fn V) > , ) “minds
F" U r> ‘ “mm 1) > » mu W0 (
m <1 < 1va a[\mw] : U,
m mu! a2’ ,1eaea] Z [afiaea], 5m; sum Z 0,
19: mm “mm iter‘ V 19,21; me; ner 7 e,
19K Start : (\, auto Stavk : 51+’ (\(fouﬂtf/O;
V mmmw ‘ Hm» (‘W < MW) <
m M 1 = 2-, 5m; 1 Z e;
‘were 300022 < whle (1 < woe-2) (
am 7 {(sum\i?§2)%1BP\ as , Outpuﬂpossible) a[1] Z MSW > 1 x 7)%1w);
Sum 4' BU as , sum 0* JUL
11*)‘ 560058 '> 700 1w‘
) >
1mg mm,
v )
1:»: m r 1,, Um m 7 D \v'an ML
pmmw <.» U ~ ,wmmnd'navn‘ WM 7M am , (mm (m\)(eml V many),
) )

***************Ending Page***************


***************Beginning Page***************
***************page number:27**************
®; Arrays

Let's compare the speed of a Rust and C++ program.
Both programs were compiled on a 64 bytes architecture, debug and
release mode. Tests were performed 10 times, and the average was
computed.

' Rust versions: 1.61.0 and 1.71.0

' cl version: 19.33.31424 for x64
nuuuuumuum
Rust(debug)—1.61 672 671 703 672 EBB 672 656 672 657 718 618
C++(debug) 546 561 561 578 562 578 563 563 561 563 563
Rust(release)—l.61 297 197 312 181 197 313 197 297 197 181 197
Rust(release}—1.71 281 181 281 281 166 296 181 281 181 297 281
(IN-(release) 189 295 306 306 295 308 295 195 308 295 299

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
g; Arrays
As a general conclusion (related to Arrays):
- Compiled with debug mode, Rust is slower than C++ (15% - 17%)
- In release mode, latest version of Rust gets better results. Keep in
mind that GetTickCount API has a variance of 16ms, and as such we
can say the on release mode, both C++ and Rust have similar results,
Keep in mind that on release mode, several optimization will take place
that include removing boundary checks where they are not required. /

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
g; Arrays
Let's see an example Where an array contains some complex objects
(such as a String).
ii i
:1: r ;; (1479}, t: raw/1;

1w]. rum‘); ioumm—i

' i H‘ ‘ i E , '4 ii
‘v w mum , , [a] [1] 123456,”:
If we build the array providing a different value for each element, then
everything works as expected. /

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Arrays

Let's see an example Where an array contains some complex objects
(such as a String).
RIIS!

mail I

—

1 z .pu-z'i; pr , . ;

winning" , [[21], 1U] i;
However, forthese cases, Rust .ii:,~§:§;;3m;:.3x:.i “Wm 5""; my m “MM
copies the initialization value into 1 l ‘a mi a Z WW; 4r~mi“\11“>,5]i
the arra -) hence the need for l fliiiiiifﬁll' kill;
the trait to be present. l m3 Sit m, m“ ma WW we “Mm Mm

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
g; Arrays
Starting from version L63 Rust introduced a new wa of initialin array
Where elements that don't have a Copy trait, via: H
ta}

This method iterates from 0 to the number of elements in the array and calls a

callback function with that index and the returned value of that callback function is

then Copied/Moved into the array‘ This method is in particular suited for cases

where elements in the array don't have the Copy trait. /

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Let's see an example: Mﬂ—
W“ Create itrmg Wm‘ mdex' 0
create 5L!‘1H£,[im.r:.-,I , in \v 2&5? 1W Mg‘ “1:”;
pr‘int1nlk"'Cr‘eate string with index: mm»: C21: $12231“: 1'le 3
J ’ “*W'M "_5' " T’; Create mg Wm. mm. 4
= - I»\1:'~M\LK.1W1~1'- + 659 A .1; Create :trmg Wm. mum-5
r'ﬁtumw .; Create <trmg Mm mdex' 6
3‘ HZPSVAH, ‘Sign’ ‘.575,’ WW‘ “57H WW.‘ than]
MYTH m' 2\ 1
J:[ ;7] 7 5m;:ammay;:ﬁuvLm'uE-dtegujug);
pmnrlm \1 "a: " , 1);
Notice that function createistring is called 7 times (once for each element In the
string)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
. Arrays
It is also possible to use closures (in particular if you want to instantiate
the entire array with the same value):

Rust

lam l l
mr fr] : 5ti121ar‘ray: #mrrjm lsl :Itr‘nvii_"abc" l l;

I
You can also use this method to instantiate an array with elements that respect a
mathematical property:

Rust

.
lawn, -l >
pi‘iiitli‘ili_'"a= ",.v',;

1‘

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
g; Arrays
Another solution to instantiate an array of elements that don't have
the Copy trait is to use a constant value. The general format is as
follows:
n l 1 : [: »; ] r [CUNSTANTQ/ALUE; 1;
Where:
- <Type> a is a general type (e.g., String). Usually, it lS a type that does not support Copy trait,
but it is not limited to this
' N — is a constant representing the number ofelernents in the array (e.gt, 1 or 100 or 12345) /

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
g; Arrays
Before we go forward with constant instantiation, let's first explain
what a constant is (from Rust perspective).

A constant in Rust is an object/value that can be fully computed/known
at compile time. This means that heap allocation is not possible (as we
do not know where the allocation pointer will end up). This means that
in some cases we can build an array using a constant value.

If an object is constant (meaning all of its data is know at compile time)
than we can bit-wise copy it (in a way we can say that - trait is
always present for constant object)

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
® Arrays
Let's see an example:
Rust
AftoNSTANTiiTRING: : IIHEL'M l;
::[ :7] : [AiLONSlANliSlPlNGﬂ];

printlnll‘ ‘, ,i:
Notice that String::new() is also constant. This is because an empty
string does not have anything allocated (so in a way everything (size,
capacity and pointer to data) is known at this point).

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
Arrays

Let's see another example:
RIIS!

"mm r

AiﬁoNSTANTiiTRING: : 1:151“ \r"abc" \;
::[ :7] : [Aiwmsmmiswumﬂ];
pmntlnu'a: ,r:
I‘ cv-rm‘\[au15\ :Jmmt can Mm wnst in {hung a:-

memory and as such, can not \ "‘ “' " ‘ "
provide a constant object‘

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Arrays
Let's see an example Where an array contains some complex objects
(such as a String).
Rils!
"Militl i n mam n 41‘
1 : [ ;;ri-m-i"123"'>. i .
::¥i’ui("ab(“'i]; ‘l ‘a’ “W” " alt‘?
l help. mnsmer non-mung her-e Paw]
Rust considers the entire Array an object (and as such it can not move part of the
array, only Copy them. Since String does not have a Copy trait, that operation is
impossible and will produce a compile error.

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
Arrays
This means that you can not copy element from an array to another,
you have to explicitly make a copy of themselves (except for the case
where Copy trait is present 9 elg. numbers).
RUSI
mmm') l
‘it : [ :1ﬁ'wtnﬂ123"), ::Fi"xmi_"abc"i];
a.‘ : ::lr'uirii'"456"/, ::Fi{iiiil"xy1"l];
mm] : rile];
pr*1ritr\.( , '. s1,[6], 111]];
l l
l unnct mu cut m new;

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
a Arrays
One solution to the previous case is to use .clone() method that creates
a clone of the existing object not altering its lifetime.

Rust
limit t
1. :[ ::+'r‘nri"~‘~ ">, lithium‘ aw];

Me] a al[@].tluriei t;

Dl'lﬂtlnli , , ﬁlial, "1.111);
l
This is more a generic solution for object that implement the Clone trait, in reality
any solution that creates a new object from another one will work (e.g.
String::from(...) for this case).

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
a Arrays
If objects from the array implement the Copy trait, these are not
necessary.

Rust
“my r
st Z r1, 11;
Z r1. 41;
sew] e 4L[G];
prlnrlnu'“ , ‘, mm], ‘1.111;;
1‘

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
®; Arrays
What about assignments between array .7
In this case we have 3 cases:
1. Assignment between arrays with different sizes
2‘ Assignment between arrays with the same sizes that implement
Copy trait for its elements
3. Assignment between arrays with the same sizes that don't
implement Copy trait for its elements
4‘ Assignment between arrays with the same sizes but different types /

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
Arrays
l‘ Assignment between arrays with different sizes
Rust
“an n i -i
(ii : [1, 2];
i: 7 [3, A, 5];
,
J
This is NOT possible; arrays must have the same size!

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
a Arrays
2‘ Assignment between arrays with the same size that implement
Copy trait for its elements
Rust
iiiéunll l
1 Z [1, 21; M!-
A; [1' 41=
lrlrdntllnlﬁl ‘m ‘, i1, m‘);
This works and both "al" and "aZ” are valid after assignment (nothing
is moved)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
g; Arrays
2‘ Assignment between arrays with the same size that implement
Copy trait for its elements
, , ii i
ii .; mcv dword pt!‘ [al+@],1
1 : [1, 1]; mov dword pt!‘ [E1+4],2
J; [3,n]: ‘*i' 1
a“: 1|‘ ‘ ‘ ‘ mov dword ptr‘ [we];
F'l'" " i ‘i i ‘ "11"" mcv dword pt!‘ [52+4],4
I‘,
V “my rax,qwnn1 pt!‘ [32]
_ mov qword ptr‘ [temp],r‘i><
In other words, a memcpy IS performed mov rax,qword w [temp]
between I and I mov qwor-d ptr [al],r-ax

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
. Arrays
3‘ Assignment between arrays with the same size that don't
implement Copy trait for its elements
Rust
Mimi,» i;
m : [ ;;+'vmri_"123"jr, :;+'mii_"455"1];
a: : [ :1fruinl:"AB"i, ::Fi'uni("(D")];
'ii : (1.‘;
a} lei mu! a2 Z[SM-mgJrnmimﬁWvHr-wgJrnmi‘([1“i]r
i mm uicuri LYLLJUiL’ 1‘ ha: kw»: manna: 1i i "mm ﬂats nut uiucimw an: may tram
5 r n Z ,0.
i ' value burrm-ied her‘? AME!‘ mrw'e

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
® Arrays
3‘ Assignment between arrays with the same size that don't
implement Copy trait for its elements
Rust
mam) r;
U] :[ :Itir'mm‘l."“], ::F"Jm1_‘4w“}];
a: : [ 1mm“ t‘ r, ::‘rum{“i[ ‘)1;
'H : (1.‘;
printlnH'“ r, 11;;
—

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
®; Arrays
3‘ Assignment between arrays with the same size that don't
implement Copy trait for its elements
Stack Heap
U i wu a1 in] villi-on
‘*1 Z [ ‘1“ 91 minim 1
I I in :5" M 21[U].capacitv a
]_ ;; l ‘5U J 7s [1] nuipn
' as 21[1].ien a
a! : [ so nuicapww z
:: \_“L1i"», 51 /
I: PCP‘) 44
1; as
25
111 : 51L; In
x pr‘1ntlﬂi\_“i' “,111; 11 j

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
®; A rrays
3‘ Assignment between arrays with the same size that don't
implement Copy trait for its elements
U i wu a1 in] villi-on
‘*1 Z [ ‘1" 91 21[U].ien 1
I I i H in i‘ M 21[U].CBDAUW a
]_ " l L“ J 7s [1] mum"
' 5a 21[1].ien a
a! : [ so nuicapww z m
: : \_ “a; "v, 52 a1 [n] az[u].pn /
;; (“er ‘ j» M mu] ien z
1 i as aziuiwaw z
IE [1] 81H] DU
<11 : 51L; ‘ Z
printlni if v “,m; I“ Elma"
v‘ 12 3H1] capacity Z

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
E/ A rrays
3‘ Assignment between arrays with the same size that don't
implement Copy trait for its elements
(i i wu a1 in] villi-on ? ; ?
‘21 Z [ H177 ‘ 91 21[U].ien z
1 1 \_ a ,i,
:: (H iii“) 54 21[U].capacitv Z ? .7 ?
1 . ' 76 [l] 21[1].pn
' 5a 21[1].ien z
34 Z [ so nuicapww z m
; ; \_ “a; ",v 52 a1 in] null-on N/A /
I I (“CF ‘ I) 44 aZ[U],ien N/A
1 i 35 22[U].capacirv N/A
25 [l] alIlen N/A
*1 Z ‘545 zu 21[1].ien N/A
v piﬂntini k ‘ ' 11"; 12 aZ[1] capacity N/A

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
Arrays
4‘ Assignment between arrays with the same size but different types
Rust
“an n i -i
(ii : [1, 2];
i: 7 [1.5, 2.5]; .rrimnnrsrili
ti M m at [1 5.‘ ‘,1.
imam twain-n arr-ii iilntigcri, I]
hum urily iiiluan, 1i

This is NOT possible; array must have the same type,

***************Ending Page***************


***************Beginning Page***************
***************page number:52**************
Arrays
4‘ Assignment between arrays with the same size but different types
Rust
“an n i -i
m : ["789", "DEF"];
i: 7 [ ::+'wmi"123"1v, nﬁmw'ABcW];
3} Let mut a) Z i 7S‘; “[U i,
‘ nun’ sip-whiz! array’ “My. 1|
inwm arrw [SM-mg‘ 2i
This rule applies even if coercion exists between element (e.g. String
can be coerced to &str).

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
g; Arrays

As a general rule:

- Assi nment between arra s is onl allowed when both arrays have
the hand the b

— In this case the assignment will be performed by iterating through
each element from the right side of the expression and assign it to
the element with the same index from the left side of the expression

- If elements within an array implement the Copy trait, then the array is
copied , otherwise it is moved.

— One can not move one element from an array, only the entire array.

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
Arrays

What if we want to pass an array to a function ? (well in this case the
behavior is different that the one from C/C++,
Rilst

with; [ ; 3]"i 7;‘ i

mum] t

a : r1, 2. 3i;

prinllnli'" J , 1i;
Question: How come "a" is available when calling println!
(shouldn't have “a” been moved to function sum ?)

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
. Arrays
Let's see another example:
Rust
"w 1am: [ z 2]) 7* \' W1 “n
1% n[8].iem_"\ 7- .1[1].1H:n<¢ i '
MW Mal-1W1; "' ‘H T;~§;‘Ll§lir§."§ZT;§l§§"$12!‘,,QLWKQIEZQQM .
;' elie -; "M M M Wm," m‘ My, 1, m
Mum n[1] . mm; ‘ ‘*‘ 1 Z ""'J“'"‘f";a,u, W, W,
mum: I;
a : \ :17!‘UH{"1Z"'Y, :2(r£1v'k_"abc")\;
1 : ‘vanilP'WmH
printlnlL'" v , M;
How come, this example does not work, but the previous one does ?

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
g; Arrays
Let's analyze the assembly code of the first example and see how Rust
compiles it.

1‘ ‘ * 71;‘,7
‘In: [ . :;]~\ 7; J may dword ptr‘ [a+e],1
' ‘ ‘ muv dwurd ptr‘ [a¢4],2
L am] * ‘[1] * ‘[2] mov dword ptr‘ [3+5];
a : [1, 2. 31; may rax,qwor*d pt!‘ [am]
‘ : {a}; muv qwurd pcr [temp+@],r‘ax
printerL'“ s , ‘, a}; mov eax,dword ptr‘ [3+5]
y mov dword ptr‘ [temp+5],ea><
lea rcx, [temp]
(all First: :sum
mov dwurd ptr [s],eax

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
g; Arrays
Let's analyze the assembly code of the first example and see how Rust
compiles it,

1tL tl : [1,231,
m [ . :th it, t muv dword ptr‘ [a+0],1
; ' ‘ 1 ‘ mov dword ptr‘ [mm
t ‘ldl ‘ ‘lll ‘ ‘Ll mov dword ptr‘ [a+8],3
w l 1m s : su m
d I ll. l- Bl; muv rax,qwor‘d ptr‘ [am]
t : ‘m t; mov qword ptr‘ [tempm1,ra><
tm-wtl m s , a‘; mov eax,dword ptr‘ [MB]
t mov dword ptr‘ [temp+B],ea><
lea r [temp]
call '2sum
The code makes a copy ofthe entire array a (ﬁrst s bytesthen
the rest qu bytes that remain] into a temporary space from
the stack , that is further send to method sum

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
Arrays
Let's analyze the assembly code of the first example and see how Rust
compiles it.
RAIS! C/C4+
Win: r ; 3]‘i 7;‘ i my m i
a[G] + 1U] + 1m II» return U[H]+y[1]+p[l];
mum) i mainU i
d:12_3y; as:'1zs-
mm “iiiiih
prinunir'" s , Ji; iilEliiprL'Leip,a,1Z);
iv 1 : Stliiit'Kfﬁiiif'iDu);
printﬂ:"5um a Inks);
One observation here is that Rust copies the entire array into stack
before sending it to the function that will process it.

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
® A rra ys
One observation here is that Rust copies the entire array into stack
before sending it to the function that will process it.
Let's see how C/C++ behave in this case:
sliinl iii l
P lnlﬂ" [litiilli ; in c/c++, there is no real difference between an array and a Qointer.
i . As such an arrav is send via a puinterw its ﬁrst element‘
"ial'il l i The main advantage here is performance (forexample for an array
1P] , i1,2, 5i; 0610.000 elements Rust will copy all 10,000 elements to the slack,
: Smill 51) i while C/C++ will just send a painter).
nrinm' “n ,'l;

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
Arrays
What about the example with a String array (that one that did not
work)‘ Let's analyze its assembly code
Rust
max 1am: t ; 21> r> -;
71‘th lv[1].1-\u;
\.
} ..
mama’; 1|
a : [ ::!rmn{"12"t,
:wwmﬂwwg;
J : may levvla);
——
It

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
®
Arrays
What about the example with a String array (that one that did not
work)‘ Let's analyze its assembly code
Rust lea rcx,[temp]
max lenv'a: t ; 21> r> -; lea rdx,[a]
\F amym-‘qy .~ n[l].]en(\ t "KW "16,39"
return d[B].l=H( \z call memw
1' Elie ‘t lea r‘:><,[temp]
"MW" HUI-MHZ‘; call Firstnmaxilen
); may qwcrd ptr [s],ra><
7
1
YHleH'j 1|
a : [ ::H‘mn{"12"t,
:2fr‘um1_"abc"}]; m
prinunu" 1 "jv;
t
.

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
g; Arrays
So when sending an array as a parameter to a function, Rust
performs the following operations:

1. Create a temporary array of the same size and type on the stack

2s For each element in the array that we want to send, it assigns its
value to the equivalent element from the temporary array. If the
type of the array support the Copy trait, then the value is copied,
otherwise it is moved.

3s The temporary array is then sent to the function (if Copy trait is
supported by the array type, the original array will still be available
after the function call).

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
g; Arrays
But Rust is designed to be fast‘ Why chose to copy an entire array when
there is a faster way (the one that C/C++ is using) that relies on sending
the pointer to the first element to a function ?

l. Sending a pointer instead of an array implies you don't need the
size. This means that boundary checks can not be performed and as
such several risks

2. lt is clearer like this —) in C++ you have to know that an array is send
by default as a pointer, in Rust the array behaves just like every
other type.

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
® Arrays
However, this is not really a problem, as you can send an array via
reference in Rust (using &[<type>;<size>] as a type)
Rus!
m FWD-ilrlﬂlv'l; &[€Tr‘in~;;2]) usirr- r
a[6].1‘:H(_':]:d[1].lerr() r 421.1%’); l r :1[1].lerrr"r; ,r;

\
r
Fm Purim"! l

l-JL a : [SLFlrryI I lrirrru' “l; ‘),‘,l,r jug: : lr'urrrl' ‘alwf l l;

pr 5 : rvmztrrnrh'r;

pr-lntlnrr‘;5;»vr:"“,a.r; M
\
1

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
®
Arrays
However, this is not reall a roblem as ou can send an array via
reference in Rust (using as a type)
R115!
1*; aw].1‘:m_':1:a[1].len() ‘i I'ELmTv a[a].1en(jl; ‘r Else r retur'n :1[1].lervr'v; }>;
\
r
main/‘y y’
a :[ :zrmlea Mme] "H:
r 1- call firstzzmaxilen
pr‘1ntln.r J , mov qwur'd m [s],r‘B><
\
J 3,["12","zb€"]

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Arrays
Rust checks the types for exact match (meaning that you can not send
a reference of an array of 2 elements to a function that expects 3
elements).
)7qu
mgwra; ar r: r
1r =1[B\.leur')>a\1\.lerr() 1 return e1[B\.lerrr'r; 1- e15! \r return amyler; };
1
mm r
1 : [ :1M‘Orru'"1l"'/, ::(r\:vrrr\'_"abc"1];
: rrrarzilvnhl. 3;
prirrtlrru." ‘J , "an Mr-‘wwmrq my MM My
‘ nut!’ “WM ref-awn» armmg, n
rwmd rarer-mm “Sh-mg‘ I]

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
® Arrays
But what if we want to send a part (slice) of the array. Well range
operation work on an array as well.
Rust
riairili l.
1* [1, 2, 3. A, 5];
FILM-A];
prlritlrili' ‘t , Li ‘, ,, in;
Slices for array work similar to how they work for Strings (in fact we can
say that a string is an array of u8 values),
However, since the size of a slice is unknow, the type of the slice from
an array will be -

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
'
Arrays
Let's see an example:
Rust (via index) Rust (using lreruturs)
Emma: M 11 ~ 1, (‘w-<1; H 1; 7;» {
, e; ‘ , a;
(or \ 1n H..a.lev'\1) l Iv" ‘ 1H 1v’.
,_ +1 \[l]; +: l;
) 1'
return '; FQTHPH ‘i;
‘r I’
1mm)‘ i "@1va -:
.1:[1,2,3,A,5,6,7,8,9,1(1]; I : [1,2,3,4,5,6,7,E,9,18];
7 : SU\\\L&:[1._3J)§ J : BvalSksLLJJW;
[minflﬂl("5: 1 "3; wintlnhﬁs: 1 "'>;
‘I I’

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
®; Arrays
Let's see an example:
mov qwurd ptr' [startislice],l
m: M 11 ~ 1. mov qword ptr‘ [endislice],3
7 a; mov rdx,qword ptr‘ [startislice]
‘ Qua. 1‘, { mov r3,qword ptr‘ [and_slice]
,_ t ‘[1]: lea FCX,[E]
\ lea r9,[vtah1e+46h]
‘ n call makeisliceifromiarray
1 mov qword pn- [SleQJKFLFQX
‘r mov qword p" [slice size],r‘d><
‘,1 i "luv rdx,qword m [51115119]
.1 1 [1,1,3,4,5,i1,7,2,9,1ﬁ]; mov rcx,qwurd ptr‘[51ice,ptr‘]
V : “RU-ii); call first::sum
pPiHTlnH ‘.7: 1 H); mov dword ptl" [s],ea><
1'

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
’
Arrays
A similar C++ approximation will look like this:
Rust (via index) C++
Emmi; M 11 ~ i. sum(cunst .1, mm)
i 0; i
(or i 1n 21.1.19va 1 : a;
». +1 ‘[i]; fur‘ r_ 1:@;i<wm;;++)
return '; return r;
‘r i
mm)‘ i "mm <
.1: [1,2,3,A,S,6,7,8,9,1(1]; n[] : [1,3,2,4,§,a,7,:2,9,1a);
a : swiéagilmai); : suml'a+1,(3'l));
pPiHTlH!(“S: 1 "ji; prinm'silm : ~|1",i);
1' i

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
®; Arrays
Let's see how functlon sum looks llke |n assembly:
mov rcXNWGPd PU‘ [6.16"]
..-.- M 1) .. . mov rax,qword W [,1
‘ ‘> mov 4mm pt?‘ [teanmax
: * g; mov qwurd pt!‘ [r5p»8Aah],ra><
1 8..:.. 1) { (HID rax,rcx
._ +1 ‘[1]; set!) a1
test 81,1
) jne INJIANGE
7; jmp PANICJZAUNDERV
; 1mm“:
U i mov Paxmword W [a.ptr]
> : : : : mov r:x,qword pl?‘ [lempil]
r1 I [1.1.3,4,5.i~7,8,9.l"]; mov eax,dwurd pt?‘ [raxwom]
: : (841.3”; add eax,dwurd pt!‘ [5]
Ninth.“ ‘.7: 7 q; mov dwurd pt!‘ [temp;],eax
. ' seto a]
r res‘ 81,1
jne mviovmmw
jmp um)
Mmqmmw

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
E; Arrays
Let's see how function sum looks like in assembly:
\ 1'. U ‘I, \ \
“““[ 1;‘ L ‘H MAW w \,~
7 * H; v‘ ‘@117, 1; HQQMW
I, +1 ‘[1]; ; ‘ ‘1
3; 'v» HHII 'LJLIP
TherearetwuchecksRustperforms: M“ V v, v l H
1. Aboundarychecklto makesure 0V ms.“ 1 J 1:1 ; 4
that”i” iswithingthe slice v , ‘ , , H , x
,‘ 2. An Inkegeroverflowcheck (this f m.
check is performed only on debug
"we, \"n ~ H» U I

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
g; Arrays
Keep in mind that Rust can optimize a lot and will probably optimize
the way index access is performed.

If possible, try to use iterators or a range that clearly indicates the
interval you are iterating over (rust can optimize this kind of cases and
not check for boundary at all).

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
Arrays

Another interesting feature is that Rust functions can return an array,
RUE!

createjrrayqtnine: v l ; 10] i

.\
miml i
a a createimvayl'Sl;

pmnnnil" 1);
This is different than what C can do (as you will need to return a
pointer to a heap allocated array). C++ has a class (std::array) that can
be used with the same scope (returning an array).

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
g; Arrays
Let's see how the assembly code looks like:
(min-3: 7 [ : pm
[J 11m‘; 1e]

|‘

\'\ 1

: ’ \"5 \i
‘ pmmnn 1“ mm
" mov edx,5

[an mmjmy

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
®; Arrays
Let's see how the assembly code looks Ilke:
mov raxmcx
. ‘ add rax,22h
(QUIlH-Jv / [ . wh mov Wm ptr [emiJanteﬂmax
["1 11W; 1*3] mnv qwurd ptr [(urrentipmnter],rcx
|\ wane:
‘ ‘ L mov rcxmword Bll‘ [empower]
,r mov rax,qword ptr [Lurreﬂtipointer]
L‘ ' \‘Mi mov 4mm ptr [r5p],rax
pmnnn u ‘ - ("ID raxmcx
L he w, {=1 je mum:
‘ '"°Y ""5 Inov raxmword an [rsp]
[all "eatejrray mov ecx,dword ptr [value]
mov dwurd ptr [rax],eo<
add FEX,4
mov qwurd DU‘ [(urrent_pomter],rax
jmp WHILE
EMUMM:

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
® Arrays
A C/C++ code similar to the rust one Will look like this:
Rust C/C++
in creamy-rag».awe: 1m -t- [15:1 191v‘. mm createj'waymw output, inr value)
[w 41w‘; 19] {
|‘ 1m’ current : output;
m mm \ L mt’ end : output+1€‘;
let a * weateid'v'MSH ‘. ‘A? (currennend) (
pmntlnH a); ‘current : value;
1> current++g
)
}
wm mam) -{
mt a[19];
createiar‘ray(a,5)l
}

***************Ending Page***************


***************Beginning Page***************
***************page number:78**************
Arrays
Implicitly, any reference to an array can be coerced into a slice (for the
entire array). A slice can also be mutable (and elements from the slide
can be changed). MI
wimpy: a i lil
Hill 1L : Alum; Z,

l Z a]
|n thlS example we i'JliJl-P L: until > i
reverse the content of 1i i'l'rlqulllh r 1 a Vi;
a mutable slice. 11:1?“ ' 1' *1 Z 1""

l "iIlJi'iii i
s :[1.1, 9,4,5}

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
Arrays
Multi-dimensional arrays are also possible (they need to be properly
specified in their type):
Rust
nmimj {
a: ll ;31;2l:l[1- Z, 31- H, 5, 6H;
Fm‘ y m emulmljjll 455
ﬁn‘ . in o..§[,l_1=n(w l
_ PFJHIW," r[;,][']>;
érintlmww;
_ )

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
Arrays
Type does not have to be specified; the previous example works just
fine event if we don't specify the type‘
Rust
mam) {
dIHl- Z, 31- [L1, 5- 5H; 123
Fm‘ ‘, m 8.41.1FH\_']( 455
ﬁn‘ . in 9..¢[,j_len(1 ‘K
prlntW," ".r[:v][']>;
printlnHM'V;
_ )

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
Arrays
The form where an array is specified via its value for a specific number
of elements can also be used,
Rust
mimji r
C: ii :3l; 4i Z HQ; Bi. l1; Bi. i2; Bi. i3; Bil: 000
Fm‘ 1, m Bﬂ'i.li‘ﬂi_':il 111
ﬁn‘ . in 9..¢[,l_leri(l i 222
pmntw," Thrill»; 333
l
pr‘ir|tlnll"""i;
)
i‘

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
Arrays
The form where an array is specified via its value for a specific number
of elements can also be used (in this case for all elements in the matrix)
Rust
niaini_',\ r
C: ii ;3i;4i:iis;si:di; sxs
rm r, 1n BUIlFHiljil 383
{ur' - in B..¢[,l_len(l l 83$
pmntw," Thrill»; B38
l
prir|tlnll""‘i;
)
‘i

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
Structures

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
g; Structu res
Structures in Rust are a bridge between how structures and class behave in C++t As
a general notion, a structure only contains data members (and this definition is
inline with how C/C++ sees a structure), In rust a structure is defined in a similar
manner, but it can also contain methods and traits (similar to C++) and through this,
it is more like a class in C++.

To create a structure, use the following format:
5min (Name) ( <Nm|e> r
var‘, = “WW, var, = <anue,>,
var; 1 “wen, Withthefollowing van = Mus,»
. 4, v
V"; ~ (‘l/“1" direct initiallzatlon W1 ' "Mm"
var,‘ = <typen> format var" = <vatuen>
l r
Just like a class, a structure / structure members also have some access modifiers
(etg. -) that will be discussed when talking about modules.

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
Structures
Let's see a very simple example:
RMSf
1'
_ yr , p1.x:3,p1.y:5
.> p2 km, pl vac
vanﬂl‘ g
‘L: , (X; 3,y;51;
: ,1 x: 10, y: 3a xv;
pr‘intln‘("p1.x: , p1.y: PLX, my};
pr'intlnH'bLX: . pLy: pgx. p4.y‘\;

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
The ownership ru\es work in a similar manner:
Rqu
1'
y: v
I»
mm g
‘L: , (x:3,y:51;
: p1;
pr‘intln‘("p1.><: , p1.y: PLX, my};
pr-inclnhﬂpLx: . pLy: L\L.X. My‘;
‘ V , .vLHMm um‘ -51
h m m 9mm numb-Ly 5».
w m 92 : w,
s x ww1n~p1.-:u» uLme -v mm.
- - Um; bwmxwid Mu‘: MU “M

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
® Structures

The same for borrowing:

Rqu

5L Mn Pulnt 1

+11 ‘,FkJ'manU“: Sum Pnint, -=; iEZ, v: 121, (
Fwy Z 1r;

‘i

m mamr) ~1
1w "m p: wmm : Pmm [x1 a, y: e ):
EL pumumm p, 3, 5);
pr‘intln.‘k_'“"~: "v, ",,: 'y‘, p.><, pvy'>;

\

,

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
. Structu res
Data members from a structure can be moved. This does not invalidate the
structure (in the sense that other members can still be accessed, it only invalidates
that specific data member)‘

FLISt
><~ l
‘ ' a l let Lv y “sum
l “mm ‘ { l my "W “My; We“ Mm Mai z,“ >1, 1H; t trim m m whim m» Lupy Us“
it: : i x: e. y: 0, name: :1ri-wrii"'A"‘r i;
r : n.nam9;
pl‘ii\t1ril("p.x= , p_y= , prisms: “X, p.y, p.name'l;

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
' Structu res
Data members from a structure can be moved. This does not invalidate the
structure (in the sense that other members can still be accessed, it only invalidates
that specific data member)‘

Rust
‘r Im-
y: .
name: .
mm: r
it: : l x: e, y: 0, name: :1ri-uliv"'A"‘
l1 : n.nam9;
pl‘ir\t1nl("p.x= ,p.y= tux p.y);

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
. Structu res
Let's consider the Point struct. What if we want to copy its content into another
struct ? (etg. change it in such a way that the next code copies the content of “p”
into “p2” instead of moving its
Rust > F z’

:1: , i r 1w mm. because a mi. type mm i mum m; m mmm m? (my trait
y, a i m ,1 p;
} 3i WWW; Xe.» v Ft» v» t, r v.»
t‘: : ix: a. y: 0 i:
P1 : n;
pr‘ir\t1|iii"p.x: , p.y: tuX, thy):
printlnii"p2.x: , DZsy: x ray);
t
i

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
Rust supports attribute for various declarationt ln particularfor structure definition,
these attribute allow specifying how a structure is organized and behaves in
memory,
Attributes are defined using the following format: — added before the
definition.
tr[derive(cldne)] Adds the trait clnne to a structure. This will add a method named -tu that structure that
creates a clone of that object.
lilderive(Clun9,CulIV)l Adds the clone and copy traits, Copy trait means that the assignment operation will perform a
cnpv lvia clone) instead cfi move operation
I[de|lve(Dehl|g)] Alluws structures ta be pretty ldrmatted when using .in println! macro
ereprl...)] sueeilv haw the strueture should he aligned,
- lilreprialignedililll —> members are aligned to 4 bvtes
- #[reprlCI] —> use "c" language alignment.
- #[reprlC,aligned(1l)]-) c language alignment ta 1 hvte

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Structures

Let's see how we can use attributes to change the way our structure works.
FMS!
‘l p,;<:1, p,y:Z

x: , P2 F1. til-‘Fl

y: ,
Ir

mam 1

J1 : (x:1,y: 2,‘;
prlnt nu p.><= , p_y= "J J.)\', p.y‘v;
prlntlnh'prX: . p2,y: pgx. pity);

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
Structures

Let's see how we can use attributes to change the way our structure works.
FMS!
‘l p,;<:1, p,y:Z

x: , p2 X11, ply=1

y: ,
Ir

mam 1

J1 : (x:1,y: 2,‘;
prlnt nu p.><= , p_y= "J J.)\', p.y‘v;
prlntlnh'prX: . p2,y: pgx. pity);

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
®
Let's see how we can use attributes to change the way our structure works.
Rust
‘r 7' WWW.“ 1 w
> \
XI , 1 \ HAM-hvp'uyvyt]
y; , \ ~ . m m» (1W 1; m implemented m mm
_ \
r 3; \ pub Mm gm [met
"151111;, x » ~» ruwnm w m; haunt! m Lew
4'
J1 : \‘x:1,y: 2‘;
println!k"p.x= , p_y= J.» mm
printlm \'_"pZ‘X: . p2,y: p4.:<. may);
\

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
Structu res

Let's see how we can use attributes to change the way our structure works.
RMSI

y: ,
)

main‘ ‘r ,‘

J: Z {x:1,y:2‘,;

pmnnm 4:‘ M;

i

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
. Structu res
Some traits are mandatory for array creation (eg. Copy trait)‘ In this case, the
compiler can not create the array because it can not copy the Point{x:1,y:2) into the
array.

Rm irradiﬁl“! m km)! mm mm Cow i; m gamma
‘i m D rwcmw 1 [F'mmhzzlwlhwir
X: ’ ‘ Hm m Law (ran 1. réquned became m Mum: om“ “111 ha mm
y: .
t
irratirijji r
‘HI: -m]:[ ix: 1, y:2};1a];
pr‘lntlHH_U pm};
;.

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
Structu res

Some traits are mandatory for array creation (eg. Copy trait)‘ In this case, the
compiler can not create the array because it can not copy the Point{x:1,y:2) into the
array. Once these traits are added, the code compiles as expected.
Rust

:<: , ‘

y: .
t

mam; 11 r

‘qr -1a]:[ ix: 1, y:2};1a]; m

.-

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
. Structu res
Keep in mind the Copy trait has to be present on all data members from a
structure, otherwise it can not be added to the entire structure. The next example
can not implement the Copy trait as String type does not implement it.

Rust
,tv , y
‘Mimi :1 ‘, l this mm an» m mpmw n-w
ll Z ix: 1, y: 2, name: ::lr<:rrvll[“123"l 1‘;
l1 I ,-
prlrrtlrrll'“ U);
l

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
. Structu res
But what if we want to use references as the type for data member. Let’s analyze
the foHowing example:

RIIS!
err-w-[EMBR] mining hh-Hm! imam
1‘ T 5r‘: mam-515m
x: , s r nine aw
y: _ 1 - “new marred 11m,” yarawetm'
Mm my“, “woman; 1 Mm nhnmc Lav-mm-
mmqr r gr-z V
p e (x: 1, y: 2, name: "A"}; 3} j:
r
What's happening here ?

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
Structu res

That's because we need to add lifetime details for any references that are being
used in a structure‘

RIIS!

l XI I

3'

"mim'i t
L‘ : l x: 1, y: z, name: "A" i:

l

Now, the code works, and compiles as expected. This lifetimes actually says that
the reference must live at least as long as this structure does.

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
® Structu res

Rust also supports empty structs that are defined by writing struct <name>;
Rust
‘st-w» SUN:EH\pLy5U‘L.LLI m
in Hmnil l

1:7. b : ‘:UitléEille,‘SLrwilll;

printlnl i' -i 'il l “r w w : ll ‘,std: IVHEWIZIHTDJWH ;mi'wmm1mm4')»;
i‘
Empty structs are also present in C/C++.
However, the main difference between how empty structs are defined in C/C++ and
the way they are deﬁned in Rust, is that an empty struct in Rust has the size U.
In Rust these type of types are called ZST (Zero Sized Types)

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
. Structu res
One major advantage of a ZST type is that it allows Rust to make some size
optimization for different templates/generics‘

Rqu
mantlnirxize of Empty 5mm : Sizeofemptystrutt:0
std: :mein: 1744-5 til: 1: pi l, l; OplloiYSomcEmpU/5Uuct> = 1
prlntlnll_"0ption<50meE|iiptyStmet) :
std::memxsigcittfiwi < “ill;
,i
For example, an Option that is a template over an ZST type has the size 1 as it only
needs that u8 from the beginning that states if the value is Some or None‘
Similarly, sets and hash tables can further be optimized in a similar manner (we will
explain how ZST helps here in a future course).

***************Ending Page***************


***************Beginning Page***************
***************page number:103**************
New Type idiom

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
g; New Type Idiom
New type idem is a way to quickly construct a structure over a specific type (for
example a basic type).

This allows one to easily create more meaningful structures that hold one or
multiple member‘
General format for creating a new type is:

Or
This is an equivalent of creating a tuple with values ofthe type specified in the new
type definition.

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
g; New Type |d|orn
Let's see some examples:
{y l; l ll Output
v : (1n); 10
pi'intlnll“ ‘, -.£il;
In this case we have create a structure with only one field (of type i32) that is
named MyNewType.
Since this is a tuple, We can access the value of MyNewType via I data member /

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
.
New Type Idiom
Keep in mind that this is a new type, and we can not instantiate it using the type it
is build on top of [in this case an i32)t This allows one to use a more meaningful
name for a time that in reality is a basic type (eg. type Age instead of i32)
Rust
v. ,l;
Hldllll'l l;
,z Z 29132; sillynfm "Swish ‘HM.
pr'iritlnll" -.Bl; lu'mm'“
y 3 l lat 1 i'i/Ngullyp! : N133

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
g; New Type Idiom
Rust optimizes the usage of this type. So even ifthis is a new type, the assembly
code generated is not different than assigned the same value to a i32 variable.

<, I‘:
if, i Output
Z (w); 10
pi‘intlnli'_‘ ‘, -.e‘>;
—
Because of this, using a new type comes with O cost (in terms of optimizations) but
adds an extra layer of clarity to your program when using them.

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
® New Type |d|om
You can even add method for such a type (as this is a struct). The next example
creates a new type Point and adds two methods to get the X and Y coordinates.
Rust
mum Pmnqizz, 5311,-
L:l‘F.@I
1‘
+11 gnjta Flu a.» 131 [
‘:Blt'JtI
l
}
in "mm; J,
1M p : Pnintt'le, 20'»;
prjntlr\!(“> 1}‘ , l1“, p.get 1m. p.5‘et My»;

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
L

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
g; Type a | las
A type alias is an alias over a different type that can be used to simplify the usage
of another type (or to provide more meanings to it)‘

It is similar to how - or - keywords work in C/C++.
General format for creating a new type is:
OI’
Where <type> can be an existing type (including tuples or types obtained via new
type idiom)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
a Type a has
Let's see some examples:
Rust
»: : 1e;
pmnnm i_“ v ‘i;
i
In this case we have created a type alias (- is I), This means that we can create a
variable of type int (and the compiler will behave as ifthat variable is of type i32).
This is very used when trying to mimic types from other languages (eig. C or C++].
Note that you don’t need to write int(10) like in the cnse 0]‘ new type idiom.

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
a Type a||as
You can a\so use this with tuples or arrays:
Rust
mw- @15an : ‘121, jag, 11.1},-
W W I W5; a‘; m:-
11, 2, 3),[192, 168, 0, 1]
lét p: Pmncsv : ‘11, 2, 37:
1pc addr: 1va : [191, 168, a, 1];
uranium“;151:": ‘, p, mar);
mmmm 1M1»? addr‘[0], add|‘[1], addr[2], Badman;
,‘

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
Type a||as

Let's see another example, this type using the use keyword:
Rust
\E-e u; 1: vifmt;
+11 1111111"; 1

15'. F: {11111 , 1.2;

let d: 11mm»;- : 1.5;

pr'intlr1‘L'“[F 1 WWW;
}

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
L

***************Ending Page***************

***************Beginning Page***************
***************page number:115**************
g; Box
Data (of any type) can be store on heap or on stack.
Up to this moment we have discuss how storing data on stack should be done (via
let keyword), However, a variable can be allocated on the heap as well (similar to
what C/C++ is doing with the new operator).
In Rust, allocating something in the heap means boxing it (in reality we don't obtain
just a pointer, but rather a unique pointer to that specific data). Similar format in
C++ is the usage of std::unique_ptrt
Format: \ l
1. letx: Box<type): Box :Vl9W(-’ValuE>) ‘.3
2, let X = Boxzr type>zzn€w(\value>); -) ::<type>:1 this is called turbo'fish it“ ‘

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
g; Box

Let's see a very simple example:

v) ‘I

‘f : ::: >:: gm); output

,‘Z : , 7 z; pa); x:1u y:20

pr‘)ntlr‘\.‘\'_“-: ‘ .: ‘, '-. 'v);

Notice that in order to get the value “x” or "y" points to, we have to use the
operator-9 *x=10 and *y=20 /

***************Ending Page***************

***************Beginning Page***************
***************page number:117**************
The ownership ruies work in a similar manner (a Box/pointer does not have the
Copy trait, so assignment is done via move.
Rust
Hidinri 1
: ::: nine-wile);
prinumrw: -,\,;
‘ crrw‘i[>1351] burrow M mum vaimr' u
.mrmm .5“,
i
l i 1n v , Hi3», llilv'muﬂzlﬁh
3 i in y 1;“
i V .31“, mud M»
4 i w'mthW“-':'H“.H.
i - v11“; mwm haw; mm “m

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
The ownership ruies work in a similar manner (a Box/pointer does not have the
Copy trait, so assignment is done via move.
Output
rr i >10
-: ::: ):: rm); y’
printlmr“, ‘, u i;

muv edX,4

muv rcX,rdx

call 3110;: an“: :exchangeJnalloc

"luv Guard vtr [temDJrlemoWLV'ax

mov Pax,qword ptr [tempimelmry]

muv dword ptr [raxLlB

muv qi-mrd pt!‘ [x],rax

W quord w [yl-r'ax

***************Ending Page***************

***************Beginning Page***************
***************page number:119**************
. Box
Boxes are in particular useful for recursive types (a structure that uses itself as one
of its data members). Since Rust needs to know the size of a type at compile time,
this is not possible. Let's analyze the following binary tree example:

Rust
l i
‘.ralut“: , 1 r Mm m.
‘mm: 5i M "ma,
J r r Wm nam-
main() -[ l WWW? “mm inﬁlrer'mn
J . M a’. rim».

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
®
Box
The general so\uti0n is to use boxes in this cases:
Rust
‘l
value: l
left: ‘1 ,1
right: L >
\
Ming) {
Hm? Z ,1
value: 19,
left: :;< 1::neu-Jl'mv
Fight: ::¢ >ZIHPL~M 4 ..)
I’;

***************Ending Page***************

***************Beginning Page***************
***************page number:121**************
/ BOX
Now It compiles and works as expected:
( )
struct ( 0mm“
value: ' Node(va\ue:10,lefl'Sume(Node(\/alue:5,\eﬂ:Ncne,nght:
19R: < < >>J None l), ngm; Some(Node(value:15, left: None, rigm Mme»)
right: < < >>,
l
F" (> {
let root : <
value: 19,
left: Sune( ::< >:: ( ( value: 5, left: None, right: \lone, )1),
right: Srwr~( ::< >:: < (value: 15, left: Now‘, right: \IQHC, m,
l‘;
println!(“{:?)‘, root);
l

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
. Box
Let's see another example:
Rust
Hmintl 1
'[8] : 2; 2,1,0
-[1] 1: Elemnsmy1100
printlnll" , . [B]. lll- lle;
>-[ ]~, : ::nmv.‘l_[l; 190]»;
printlnll"Elemns in y : ,.leu\' ,1):
We can use Box to create a dynamically allocated array.
In this case we have two types of allocated elements:
' A box over a speciﬁc array 9 variable "x"
' A box over a sllce from an array —) variable “y”

***************Ending Page***************

***************Beginning Page***************
***************page number:123**************
Box
Let's see another example:
RMSI
dermal i
v2: ,
v3: ,
j,
niainll 1
1: :2‘ >::n=wn { v1: s, v2: ‘A’, v3: l);
pmnnm l" m;
l
Let's take a closer look on how allocation is performed when dealing with
structures.

***************Ending Page***************

***************Beginning Page***************
***************page number:124**************
. Box

mov dwom m 5m 395m; r;

Let's see another example: MW MM w [stackieswz], ‘A’
mov byte rm [stack_test.v3],1

RMS! mnv ECXJZ
mov edx,4
Qall anm arm. Exuraﬂieivrallm
mov mm ptr [pmnmrjmmmnmax
mov raX,qword lm- [nulnter_Fr-om_box]
mov ecx,dw0rd Dtr [SKitk’C€S\.V3]
mov award ptr [pninteriFromibowv2],e(x
mov rcx,|1word ptr‘ [stackitest]
mov qword ptr [rax],rcx

Let's take a closer look on how allocatron l5 performed when dealmg W|th

structures.

***************Ending Page***************

***************Beginning Page***************
***************page number:125**************
®
mov dwom m 5m 325m; ‘5
Let's see another exam-Ia: mov MM w [stackieswz], ‘A’
mov byte rm [stackgesnvzm
mnv sax,“
mov edx,4
m; anm all“. “new mm
mov qword ptr [pmnmrjmmmnmax
mov rEX,qurd rm- [numter_ﬂ'om_box]
mov mm“ W [grammar
mov award ptr [pmnteriFromiboxNELEU
mov r:><,qword ptr‘ [stackitest]
mov Wm ptr [rax],rcx
J : m 7ZIH:W( (v1: s, v2: 'A', v3: H;
Let's take a closer look on how allocation is performed when dealing with
structures.

***************Ending Page***************

***************Beginning Page***************
***************page number:126**************
g; Box
This is a very different way of working than the way C++ does things,
For example, a new operation in C++ implies first allocating the memory and then
calling the constructor for the object located in that memory.
In Rust, you first create an object, then you allocate the memory and finally you
assign (transfer ownership) of the object that was created to that memory.
For simple object / types there is no difference between these two ways of
instantiating an object into the heap. On the other hand, the main advantage that
Rust has with this model is that it ensures that all objects are instantiated ! /

***************Ending Page***************

 