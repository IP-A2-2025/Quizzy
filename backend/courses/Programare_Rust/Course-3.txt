***************Beginning Page***************
***************page number:1**************
Rust programming
Course — 3
Gavnm Dragos

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
E; Agenda for today
1. Enums
2‘ Error management
1‘ Panic
2, Option
3, Result
3‘ if let/ let else / While let
4. Question mark operator

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
V
Enums
L

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
a En u ms
Enums in Rust are quite different that a classical concept of enums
from C/C++.

The format (in terms of keywords) is however similar:
Rust
< l
l
Similarly, to access a value from the enumeration use
<enum_name>::value

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
En u ms
Let's see some examples:
Rust
RELl,GI'eeH,Blue,L-leite,BldLV, l ‘ |
mini} l l l
L Z mm; l M‘
printlrill'"Co1m‘ is red"); 'i “W”; ‘ 1
,i 2 l 9M [MW 4,
l l ' ~ mm whim mum“;
i MU 1mm.’ Vim-“in; mm- “in a 4 i, pr, Him
The code won't complle l
because unlike C/C++ an enum is not implicitly associated with an int
value, and as such can not be compared with another type !

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
En u ms
While initially the tendency is to consider these two pieces of code as
equivalents, in reality, their behavior is quite different.
Rust C/K-n
REFl1(3V‘k?El'i,Flll9,li‘JhiT\EvBlECk, l
"emu \ ‘V Z -~pi~d- mainU 1‘
ii' t :: :1Red( 1r U‘; if 1
W pr‘1|'itlnli_'"<lolor is red"‘i; érintﬂumép is PM");
i i.
iv l
i

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
a En u ms
This is because in Rust, an enum is more similar to a C++ class than to
C/C++ enum type.

Rust C/c++
PFHH 1mm ( qull Calm‘
Red,6reen,Blue.i\ihjte,Bla(k, i
i mt value;
pin-"ii.

i i i . (mm-p- :wnr w: Red : a;
Th|s IS a better approxmatlon of "WWW- 31.1»; m1 we” = 1;
how Rust enums work, was-M 51m; 1m Blue : z;

mini w" star" m: white : 5';
‘swig-rm J-Vdi; in: Black : 4;
Colorhrir v) = value-(v) i}

1.

i,

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
. En u ms
Let's see how the new example in C/C++ compiles,
C/c++
(
n \ W; "We ‘wanna m We magma ﬁfe\19>"
W Z *1]; So what happened?
‘ﬁ'ww-n : l;
51L: : 2;
.0an : 3;
51m = .1;
Color‘( ‘1) 1 ‘.aluefju) {1
\.
1,
majn() (
if (L g 3mm
printﬂ'tolor is Red");
\
1

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
. En u ms
Let's see how the new example in C/C++ compiles,
C/C++
\n \ m; Mp! WWW; m m? wwmm ﬁrm 1+»-
M Z ‘11; So what happened?
er'n : l;
Elbe : 2;
.w-nrg : 3;
Bled = a;
1;
main
printﬂ'"CDlor‘ is Ralf”);
\
1

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
' En u ms
Let's see how the new example in C/C++ compiles,
C/C++
\n \ m; Mp! WWW; m m? wwmm ﬁrm 1+»-
M Z ‘11; So what happened?
er'n : l;
Blue : 2;
.w-nrg : 3;
Bled = J;
Color( ‘1) 1 vain-2U) {1
\.
1,
majn() (
t : IIVEPI'
printﬂ'"CDlor‘ is Ralf”);
\
1

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
'
En u ms
Let's see how the new example in C/C++ compiles,
UM ( Now the code
mhu'; complies and
M Z W produces the
ﬁlm.“ Z i1 expected output.
Eh»: : 2;
alhv'g : 3;
51m = .1;
C010!‘ u) 3 ‘.alwe V‘
*
)z >
malm') \'
L : ::P~d;
if (.: :: new) printﬂ"C(vlor‘ is Red");
\
1

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
En u ms
So, What does the previous example means for our Rust code:
Rust
i
REL1,GI'EEH,Blue,L-Jhite,BldLV,
J mnim'» 1’
L Z mm;
1+ ' :: :1Red %
println‘\""CQ1m‘ is Fed");
1‘
It means that we need to add a way to compare two Color objects, if
we want this program to compile and run as expected.

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
En u ms
So, What does the previous example means for our Rust code:
Rust
mm-
\
"an v’,
r : IIRFF‘;
a; V :: 11mm \'
prjnrlnwﬁcolor is red");
}
Now the code runs and works as expected,
But what is that - formula on top of the enum declaration ?

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
®; En u ms
The pound sign (I) followed by I is the way Rust adds attributes for:
' Various declarations (structures, enums, etc)
' Methods or functions
' The entire program
Attributes will be studied in another course, but they can be used for
several things:
- To provide metadata about an object (version, name, docs, etc)
' To set up the configuration the compiler/linker should use when building an
object
' To automatically generate code

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
a En u ms
it derive(-)] means automatically implementing a trait called
into a structure / class / enum / etc. Automatically in this

context means different things based on the trait.
In particular for an enum, we have used — —)
meaning that we will implement the PartiaIEq trait for that enum‘
For a type (let's call it SomeType) a PurtiulEq implementation means
adding to functions (eq w equality) and (ne ¢> not equal)
Rust

i-tyis. , tun»: ii l ‘i a, i l

new . ether: a ,i r> ~; ,. i
l

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
a En u ms
The C++ approximation is using operator overloading to do the exact
same thing:

Rust

"wpl Pm-nnlEq {w Emir-WW [
+11 eq(&>el+', out’: $5unieTypE) ';- bool i ,. i
in |iei&5eii, other‘: mmiaype» -> mm i .. i

i

c”

firm’. SmHETyDé

\‘

submit:
hm operatul‘ :: (mm SQmeTypeJi other‘) (4..)
L191 operator i: (LCM SomeTypeS other") in‘)

J

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
g; Enu rns
So why PartiulEQ and not just EQ ?
Well -> lets start with what equality means (or more precisely equivalence).
We define a binary relation I as an equivalence relation, if and only if it is:
a) Reflexive 9-
b) Symmetric -) .ifund only if-
c) Transitive -) if-und-then-
In practice, not all binary relations reflect an equivalence relation (main due to the
reflexive characteristics).

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
g; Enu ms
For example, if we are to look on 32 bytes floating value, and in particular
to how NaN is represented on IEEE 754 format, then we can deduce the
followings:
HI!I!I!I!I!I!El!HIIIHHHHHHHIIIHHHBHHHIHHH
?11111111???????.>.v????????.v?????
' In reality, there are 2“ possibilities to write a NaN
' So if you compare two NaN(s) via a bit check, they may be different, but they are
both NaN

' As such, a bit-by-bit comparison between two numbers will not be reflexive (for
floating values).

- While there are solutions (such as compare only some bits), adding this type 0ro ’
for every float will highly impact the performance,

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
a En u ms
Let's see how a simple enum looks like in memory ?
Rust
mini li'lm' i 7
Red, 6W, We, time, mt
ln mini'» l
Di’jiiLli\l(“Li_\: in on," i]“,5Ld:tmeni::>l4e Jt'::'.£ului>i',i);
l
So one difference from C/C++ is that outside any other specifications,
a simple/small enum looks more like an u8/i8 value than an int (the
way it is treated in C/C++).

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
g; En u ms
Let's see how a simple enum looks like in memory ?
l, i
g Pm, Law-w, 21w, lea rcx,[c]
lullute, Ella!) i» lea rdx,[ofw‘set to a Colorzwlhjte object]
ll l. call VartialEq::eq
L 1mm; mov byte ptr‘ [temp_value],al
; :: :Il-llilte i mov a1,byte m [tempivalue]
pl‘iﬂf1ril("~lii‘ l‘ in'h‘); test a1,1
i jne print_scmething
l jmp endiprogram
' “c” object is in fact an I value (see the -fr0m the assembly
code), where Color::Red is associated with value 0

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
g; En u ms
Let's see how a simple enum looks like in memory ?
l, l mcv b te tr C 0
r Perl, Law-w, 21w, lea rcx,[c]
lullute, Ella!) l lea rdx,[ofw‘set to a Colorzwlhite object]
ll l. call PartialEq::eq
L ::F1ed; mnv b te Itr‘ tern: Value al
; :: :Il-llilte r mcv Hume m [tempivalue]
princlnw‘ Ml‘ 1- imw'h ‘ l; test a1,1
l jne print_scmething
l jmp endiprogram
' Next we need to call eq method from PartialEQ with two parameters
(self- denoted by RCX register that holds the address of “c”) and a
reference (offset of another object of type Color to compare again

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
g En u ms
Let's see how a simple enum looks like in memory ? Addrﬂicmcniwm 3
i, v mov byte ptr‘ [c],0
g Pm, Law-w, Him", lea rcx, c
ll l call Parna q::eq
L 1mm; mnv byte ptr‘ [temp_value],al
; :: 1mm i mov Hume m [tempivalue]
pl‘iﬂf1ril("~lii‘ l‘ in'h‘); test a1,1
i jne print_scmething
l jmp endiprogram
' This offset points to a static address where the value "3" (u8) is
located. Why 3? Well —) Red = 0, Green = 1, Blue = 2, White = 3 an
since we compare “c” with Color::White, the object has to be a "3"

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
g; Enu ms
Let's see how a simple enum looks like in memory ?
it mm
mov qword pt!‘ [r5p~8],ro< // self muv byte ptr [CLB
mov qword pt!‘ [rs|>~19h],rdx // other lea rcx [c]
,h ‘ ;
23$“ ZSZMYPZPILLZZZLM lea m offset to a Colorzzwhite object]
muvzx embyte PU‘ [rdX] call Partializce
-—r [rspdoiqntx mov byte ptr‘ [temp_value],a1
j, ,Uheum muv a1,byte pt!‘ [temp_va1ue]
mnv byte ptr paling/Blue]; // false test al,1
1 mm- ‘ “gum; jne print_something
1 _ tum 1 4
mnv byte ptr [return_va1ue],:| // true Jmp endiprogram
endilfilihel:
2'“: if?” p" ["wumq As we can wee all this function is
(if? iffy“ doing is to compare the first byt
from the two objects.

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Let's see how a simple enum looks like in memory ?
sub F5p,ZEh >ub rsp,68h
muv quay-I1 pcr [rsp-vi],rcx // self mm, byte ptr [c],0
muv qwom pcr [rspuolnmax // other lea rcx [c]
vzx eaX,h te tr 71X l 4 ‘
22v qwdypvplrsgnslwax lea rdx offset to a Colomzwhlte object]
mum wmyte w [m1 call Partiali z :e-
2;" 2:21:20 [r5p410h],rcx mov byte ptr [temp_value],a1
j!’ ifjhlﬂji" mnv al,byte ptr [temp_value]
mov byte MCI‘ [returng/alueLB // false test 31,1
‘ “imp t “la-"Jam jne print_something
i _t :n_pir' z
m byte ptr [remm_va1ue],1 // true jlnp end-PMEPQ'"
d if l bel:
en ‘mg/i 51 h e w [rmwﬂm Notlcethat”arld a|,1”.This'lrl5!ruction makes surethatthe value
ofal is EllhEl’ 1 or 01mg is a clear indicator that the result ofth'ls
'"MX @aml lunctlon is a bool value {with 1:true and O:false).
add rSpJEh
m

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
g; En u ms
Let's see how a simple enum looks like in memory ?
i, v mov byte ptr‘ [c],0
g Pm, Law-w, 21w, lea rcx,[c]
lullute, mm i» lea rdx,[ofw‘set to a Colorzwlhjte object]
ll l. call VartialEq::eq
t ::F1wi; mnv l: t2 Itr‘ tern: Value al
; :: :Il-llilte i mov a1,byte m [tempivalue]
princlnw‘ Ml‘ 1- ii“i'h ‘ l; test a1,1
i jne print_scmething
l jmp endiprogram
' Finally, we check the bool value returned from the previous step to
see if it is true (value 1) or not

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
g En u ms
This means that a proper C++ code that reflects this Rust code is:
(lass Color‘ {
Hints; value;
Eulu'(u1HL8 1 v) = value(v) ﬂ
publlz:
Static (Emit (010!‘ Red,GreeV\,BluE.whitE,BlackS
bcol cpc"at0"**(c0nst Color‘& v) { return value :: Vvvalue; )
};
const [uluv' [uluvzzRed (a);
Conn (nlor fntnr':;6reen(1);
(oust Lolor Laloprlue (n,
(oust color Calor::white(3);
const colm~ Coluv‘::Black(-’l);
vow Mm) (
(010" z 1 L010P::Red;
if (c ~ colorzmhim) mom );
l

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
E; En u ms
So why are Rust enums build like this ? ls there a specific advantage
they get by doing this ?

Well yes 9 but first, let's see some examples (Rust/CH)
1. Enurn with just some variants
l l l
unite, Fla’) g» l;

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
® En u ms
So why are Rust enums build like this ? ls there a specific advantage
they get by doing this ?
Well yes —) but first, let's see some examples (RUSt/C++)
2. Enum with just some variants with specific values
RUS! C++
Lit-11v“ :l emu £1;;; c010,‘ {

E'lilllll wmr l Red : 2,

Red : 2, Gi'e'eri = 121,

Green : 19, Blue,

Blue, white,

L-Jhite, Black Black
I }:

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
® En u ms
So why are Rust enums build like this ? ls there a specific advantage
they get by doing this ?
Well yes —) but first, let's see some examples (RUSt/C++)
3. Enum with a specific type (e.g. int)
RUS! C++
Lit-mg :l ellLHH £1;;; C0107‘ : 1m (
(15H Red : 2,
mm; Calm‘ l Gi'eeri = 121,
Red : 2, Blue,
Green : 10, white,
Blue, White, Black Black
I }:

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
.
En u ms
So why are Rust enums build like this ? ls there a specific advantage
they get by doing this ?
Well yes —) but first, let's see some examples (RUSt/C++)
3. Enum with a specific type (e.g. int)
Rust
Lit-l he i

mm

Red : 2, .

EFPPD : 10, ,

Blue, l'lliite, BlaLk
I }:

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
.
En u ms
So why are Rust enums build like this .7 ls there a specific advantage
they get by doing this ?
Well yes 9 but first, let's see some examples (Rust/CH)
3. Enurn with a specific type (e.g. int)
Rust
M, 1 l ‘Willem

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
.
En u ms
So why are Rust enums build like this ? ls there a specific advantage
they get by doing this ?
Well yes —) but first, let's see some examples (RUSt/C++)
3. Enum with a specific type (e.g. int)
Rust ,
l l
l
P911 I 1,5!‘een I LEW? I 15
l mm,» i;
pr‘1ntln!ﬂ“iI l "7:

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
g; En u ms
So why are Rust enums build like this ? ls there a specific advantage
they get by doing this ?
Well yes 9 but first, let's see some examples (Rust/CH)
4. Bitflags
' Bitflags are NOT possible in Rust (with the standard library and functionality)
- There are however different crates (eg —, -) that provides
this functionality through some Rust macros
- In C++ bitflags over enums are easily implemented via friend functions that
implement operators like I, I, I, etc. /

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
g; En u ms
So why are Rust enums build like this ? ls there a specific advantage
they get by doing this ?

This is the main case why enums are build like this (flexibility).
5. Multiple data member types enums
' Since an enum in Rust is more like a class than a classical enum from C, there
is no reason to limit the variants to a specific type
- In C/C++, a|| variants from an enum have the same type (usually I if
something else is not provided)‘ This limitation can be overcome if we use
classes with static const values instead of
enums. l ‘WW
- In Rust, however, we can create different "l""'»~ ‘
variants of different types -)

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
Overview (Rust enums vs C/C++ enums)

—m—
simple enums Yes Ves
Simple enums mapped to a speciﬁc type Yes Yes
Simple enums with different values (of the same Yes Yes
type) associated to each variant
Enums that work as a bitﬂag No‘ Yes"
Enums with value of different types Yes No'"
' There are some (rakes Such as Eﬂlllllsnﬂlﬂr bit/WI! "in! SoNEs INS Problem vfu macros

“ Requvzs (he usage ollrilnd keYWurd do overwrite Opevamrs Such a; | \ , && , Etc

m Can no! be done wlrh damn-1| enumS, but iullv supporled through smmiem

***************Ending Page***************


***************Beginning Page***************
***************page number:36**************
® En u ms
Let's see some example of enums with variant of multiple types.
Rust
Ger ive( , j
mammal Integeri 0i,Fioal( ),Charaueri a)
Characterifi'mm
lit J' a \fdlu:§::1ntegei"(19'i§
let F : \ialuesxFloaﬂlJi;
1» c : Valuvs::Chai‘actei‘i_‘ vi;
piintlnHHiI"i,i."'1,{:"i“,j,f,ci;
i
The reason for the Debug derivation is to provide println! macro some
sort of reflection that can be used to print enum values,

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
® En u ms

Let's see some example of enums with variant of multiple types.

Rust

mm Value; l
I'ltegg"ll l
Floatg'fil), WWW, WW1, i. i ‘ii-m. I 11;
Charattem'ithari, " 5': www: if J
m i : mnm;untegerijwji; :i-Ukmvugww. ' " ' " ' '
printlm‘: i ll“, i as m);

So if this is not possible:

How can we tell if “i” is a Values::|nteger, Values::Float or

Values::Character ?

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
®; En u ms
Let's see some example of enums with variant of multiple types.
i
Inwgwn ‘i,
Flue“ i,
i'l'iar‘nrtw‘( i,
When we are trying to find the underline type of one of the variants
from an enum, we often use the term discriminant‘ The discriminant is
often a numerical value that speciﬁes the type (for example in this
example the discriminant could be I for Integer, Ifor Float and Ifor
Character).

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
® En u ms
The solution is to use match to validate the type of an object from Values:
RM“
mum value; l
F1mtl+-'_'\,
Cl'lm'BCtengIhB"),
l'u >41th why»: l : kllwluew '7 3P1 l
\alllin':Infegarujvalue'l 7: 'ivalue‘
i 7- '1.
ln mum) l
l» i a ‘\3 l.~'-'.'Ilﬂteg?r‘l_'19l;
pvirltlnl l l’ ll“. £in JC'CilH'CleCV llii) l ,

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
® En u ms
The same can be obtained by implementing a method into an enum:
RM“
unum M111“; 1{
mum-1;,
Charaftemrhaﬂ,
1‘ pl my“; 1{
m ml ntmEiw'qx r 151}
>,-\+ 1
‘g1 wa::Integer‘\_'ival\lej\ 7; 'ivalua
i 7, '1.
in W11,“ 1 1
let i 7 ‘Jib'15::IHtegerW'16);
wintlnnj , 1' 1; . 1411,1111»),

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
g En u ms
Alternatively, we can use _ to check if two values
from the same enum have the same discriminant.
use >Ld::memi OUKPU!
enum -; ‘a’ and 'b‘ are Dime same varianttvpei

imam )J ‘a‘ and 'c‘ are not \he same variant type!
icnlt l,
i
f" 0 i
12c a : Iziviiegevllﬂ);
let b 7 -;im,=gm-(m>;
lit ( * Itiﬁ'nllll);
1r mm: (86> :: mm; (am) i
printlni( ii‘ ii iii‘ l, iii» Mm‘ ,iiiii i ),
i
ll’ mam‘: (&a> '7 men: (Erll
printlni[“ r‘ n w m" Mir *i‘ viii w :1 *wi‘ i“);
i
i

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
® En u ms

The previous example can be adjusted to find out if a value of an enum is
of a specific type‘ Keep in mind that this method, while it works implies
creating a temporary object to be used for comparison !
M" m5-
Ci'iiiiii ‘L31HP: 1

Integer i 1311'

Fluati' i Fl iv

Characterii ' a! ‘i,
1 [ii mlue: '

m liilitiiijulir'i ml i

mummy“;.41-miuumi1wuiji :: LLd’2m!iii2.LiiLU,iiiliik'iLiiSWJluzL.ZIYitegeiiEii'i

hi iiiiilhii i

luL i : VJLUDLI’IHUE§EV i'18i,

vaiiLliiii' i i ,>i ,i.JL Liiipi‘

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
a En u ms
A variant from an enum can also be a set of values. The next example
creates two version of an lpAddress (v4 and v6).

RAISE
liar v .,~\ \
mu"- vpstmv-r": 1
vﬁwl'i- W5, Hit‘, ~16‘, HIE- W5" v4r192,1ss,0,1) va1s2oxAsao,255,0,u,6529s)
in "mm ;
1v’ ipil Z vwﬂrwwzuwwz, 162v 6, 1:‘.
1‘: 1p; , Iw'hﬂrc::*:\\5\'8x2|516, mum, amen. B>:OBBE:. moses. mlrnzw;
wimlm ; ‘1, -; ; , ipil, ipil'n

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
En u ms
Let's see some example of enums with variant of multiple types.
RUSK
l um rll l
vl 7 ::lntPgPrllUlI
v 7 ::Intcg0rl_28‘l$
il' Al :: ,1 l
w-umlMHEqual imeggmw
l wl'.» ;
[HﬁﬂtlnHllDif¥EPEHf mtegem“ 1;
1
When comparing two enum variants, Rust will compare both their
types and their value (if present).

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
En u ms
Let's see some example of enums with variant of multiple types.
RUSK
l um rll l
vl 7 ::lntPgPrllUlI
l- , 1:1l-thEU-=
il' Al :: ,1 l
w-umlMHEqual imeggmw
l wl'.» ;
[HﬁﬂtlnHllDif¥EPEHf mtegem“ 1;
1
When comparing two enum variants, Rust will compare both their
types and their value (if present).

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
En u ms
Let's see some example of enums with variant of multiple types.
RUSK
l um rll l
vl 7 ::lntp<erl18l:
v 7 :_ 2.0‘.
il' Al :: ,1 l
w-umlMHEqual imeggmw
l wl'.» ;
[HﬁﬂtlnHllDif¥EPEHf mtegem“ 1;
1
When comparing two enum variants, Rust will compare both their
types and their value (if present).

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
En u ms
Let's see some example of enums with variant of multiple types.
RUSK
l um rll l
iv 7 IilthPgPr'llUli
v i uncle-t
ii Al :: ,1 i
ﬂi‘iiltllil\llEquSl integers“;
l wl'.» ;
pr‘\ﬂtli‘il\llDif¥97‘=:Hf Integers“ 1;
l
Even if the value is the same (10) since there are different types
(Integer and Float) they will not be equal.

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
En u ms
Let's see some example of enums with variant of multiple types‘
Rust
bealy lv
‘ llllell l l
Lilillltlllli “Size nF Values : “, itd :mun: .sigu ul'. :~ l ll.
l
So why is the size of Values 16 bytes ?
- an Integer is 4 bytes
- a hool is one bytes
- a float64 is 8 bytes

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
® En u ms
Let's see some example of enums with variant of multiple types.
Rust
Inn-gw 111‘,
Efmlﬂ hﬁnl K,
mama-s‘.
m 5 1 udmw IzlntPnglW;
‘F4’ b 7 ‘waluw: :IF'UOIQW' .= I‘;
1w r 7 \m1u@:::Rea1<_1_23-4\,
Let’s see how i, b, or r look in memory.

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
. En u ms
Let's see some example of enums with variant of multiple types.
RUSK
Imam-‘L \,
m»; .0 A .1 .2 ‘I ‘5 ~s ‘1 .x ,9 “n m m ‘n A;
Rein W. o 1n n n n
‘ nuihw -‘
Y 7 :IHme I‘;
7 ::F:r;r<1<_1.234\,
Let’s see howl, I, or I look in memory.

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
. En u ms
Let's see some example of enums with variant of multiple types.
RUSK
Imam-‘L \,
m»; .0 A .1 .2 ‘I ‘5 ~s ‘1 .x ,9 “n m m ‘n A;
Rein '\_ 1 ,
‘ HMJH‘ -;
\ : IIIVV'F'vV‘\lU\‘
7 ::F:r;r<1<_1.234\,
Let’s see howl, I, or I look in memory.

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
. Enums
Let's see some example of enums with variant of multiple types.
RUSK
Imam-‘L \,
m»; .0 A .1 .2 ‘I ‘5 ~s ‘1 .x ,9 “n m m ‘n A;
Mn 2 5. as an cu 15 u n 3r
‘ HMJH‘ -;
\ : IIIV'WngNlUH
Y 7 :IHme I"
Let’s see howl, I, or I look in memory.

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
En u ms
This means that in reality, this is more like a union than multiple data
members within the same class“
Cw upraximarmn c“ [1017mm beyond)
l ~
\‘
H l l D
li s ,
l
l: I
l;

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
Error management

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
E; Error management
For every program (regardless of the language it is written in) there are
three situations that require error management:
compile Error Usually when some semantics onne language are Repairthe error and compile again

incorrect.
Run-time Error Ari errarrhar can be mariagerl hythe program (e.g. we In this case, we need to have a logil:
imanageahle) are trying to connect to a database but the inrerner within the program that lrealslhis
connection is unavailable) error (e.g. pops up a message and
the" Wail for (he internel
connection to he available)
Runatime Error An errorthat hv is riamre stops the execution ofthe Nothing. These are the eases where /
(aririral) program (e.g. a game can not star! ifthe graphical the program irisr stops.
driver is not working)

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
E: EFFOI' management

ln reality, run»time errors can be:

1. Treated -) meaning that there is a specific code that treats an error
(a specific execution flow that takes into consideration various cases
where errors might occur)

2. Un-treated -) these are dangerous situation that might lead to
program crashing or undefined behavior

A well written program falls into category 1 (meaning that the

programmers of that program were very careful about various situation

that might occur and can produce an error)‘

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
E: EFFOF management
Let's see a C/C++ example and discuss how an error might be treated:
mu n1. n4‘) ~i
i ii i i 1twi<nljimhi<n;i;
I mm ‘Vii-.3», mgr) {
whim‘ ‘.1 ,Lil\1(digu[l],dif;i [1],»,-
We will focus on I function, and not on the problems from the main
function (eg, not enough parameters).

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
E: Error management

What potential problems can we spot on I function ?

tuvr n1, n1) \‘
u ii i Eitiiil<iil),/'Elt[i](iil);
}

l‘ -or- can be null pointers (e.g. for example ifthe command
line arguments are less than 2)

2‘ -or- can be invalid numbers (we are working with string, so
there is no guarantee that either n1 or n2 respect a valid numerical
format;

3. -cou|d be a valid number, but it is 0 and division by 0 will
produce an error.

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
E: Error management

So how can we change function “div” to treat errors ?

1. Change the signature of function “div” to return either - (if the
division was successful) 0r otherwise and put the actual result
in a reference or pointer.

It is recommended to use a reference as we don't need to add an extra

validation to check if the result pointer is valid.

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
EFFOF management

So how can we change function “div” to treat errors ?

l. Change the signature of function “div” to return either - (if the
division was successful) 0r otherwise and put the actual result
in a reference or pointer.

The usage of such a function will be as follows:
C
majn( ar'g“, m-wr) l
i-wtilt;
1r (div(ai [11w 5‘~‘[2].ie£uit):: i i‘
pl‘intﬂ'"Rrsu1t 1g; “i1",|‘esu1t);
) else r
i
)

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
E: Error management

So how can we change function “div” to treat errors ?

1. Change the signature of function “div” to return either - (if the
division was successful) or alse otherwise and put the actual result
in a reference or pointer.
E——

- Easy to write lregzrdless of the language) - We neetl references [this means that eyery
hiiietieri call should be preceded by a
varlable definitlorl where the resiilt will be
out)

- Bool type is hot necessarily associated with
ermrs and as siieh some rESlAilS might be
mlsleading.

~ We dah't know the aClUEi error litist that
there is one].

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
E: Error management
So how can we change function “div” to treat errors ?
2. Change the signature of function “div” to return an — (an
int value that if set to O (or other constant) means no error, and
otherwise means an error code). Similar to precedent case, the
actual result should be put in a reference or pointer
i

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
E EFFOF management

So how can we change function “div” to treat errors ?

2. Change the signature of function “div” to return an error code (an
int value that if set to 0 (or other constant) means no error, and
otherwise means an error code). One possible usage:

C
Uri WWW my, M 3,-qu i
11' Wile
i i error : (1vir'iargvilivnr'm/ilivresultll

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
E: Error management

So how can we change function “div” to treat errors ?

2. Change the signature of function “div” to return an — (an
int value that if set to 0 (or other constant) means no error, and
otherwise means an error code), One possible usage:
m——
- Easy to write iregzrdless of the language) - We need references [this means that every
- We thew the error and we can act on it tuhetlen oail should be preceded by a

varlable definitlon where the result will be
out)

- Int (or numerical) types are not necessary
associated with errors and as such some
results might be misleading.

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
E: Error management

So how can we change function “div” to treat errors ?

3. Use - (meaning that div function signature will not be
changed)‘ Instead, whenever an error occurs, an exception will be
thrown‘

This is a different approach that starts from the assumption that a
function signature should reflect its purpose and not its error
handling mechanisms.

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
® EFFOF management

So how can we change function “div” to treat errors ?

3. Use exception (meaning that div function signature will not be
changed). Instead, whenever an error occurs, an exception will be
thrown‘ Possible usage:

C
Us‘ WW“ will, M algal l
t l
prinmw ii "d‘ldlui:ﬂi‘ﬂv'[l],ﬂi‘!:'.[21H>
I ilD)\)5)uYiEyUEY‘Yuil
I‘ printfi '1 7:1» i, ' i,
1 purim vi - in l

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
i5: EITOI' management

So how can we change function “div” to treat errors ?

3. Use - (meaning that div function signature will not be
changed)‘ Instead, whenever an error occurs, an exception will be
thrown‘
m——

- Easymwriteiregzrdless ofthe language] - Notreallyiinearintermsufcode execution
- We know the error and we can act on it . Memory ailocation might not be cleared
~ Can't reenv be enforced (sorneone can
decide not to use it, because a try...catch
biock is nor necessary to read the resuit ova
function.

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
E: Error management
So how can we change function “div” to treat errors ?
4. Use an error specific type that holds both the value and the
error/error codes This is a more modern approach of the error
management problem. A definition (for C++ language) looks like
this:
This type was introduced in C++ with the 2017 standard. /

***************Ending Page***************

***************Beginning Page***************
***************page number:69**************
E Error management

So how can we change function “div” to treat errors ?

4. Use an error specific type that holds both the value and the
error/error code‘ This is a more modern approach of the error
management problem. A possible usage:

CH 2017+Standard V
ll (i ‘has \‘Jluéi il-l

Notice that the code is quite small and the .variable incapsulates

both the value and the error.

***************Ending Page***************


***************Beginning Page***************
***************page number:70**************
E: Error management
So how can we change function “div” to treat errors ?
4. Use an error specific type that holds both the value and the
error/error code‘ This is a more modern approach of the error
management problem.
E——
- Easy to write lregzrdless of the language] - Might require some adjustments in haw
- We know the error and we can act on rt someone programs if he/she are used with
- Linear programming an error management similar to cases 1,2 or
- Entoreeabie (you can not get the result a
without knowing the error as well)

- This is e type designed forerror
management so rt has no double
interpretation

***************Ending Page***************

***************Beginning Page***************
***************page number:71**************
E: Error management
A general observation on these four cases:
- Older languages (e.g. C) usually use cases l or 2 (e.g. Windows API
(case l), Linux API (case 2))
— Newer languages (C++, Java, C#, Python, etc) usually support cases 1
to 3. The potential risk here is that none of these cases are
enforceable (meaning that someone might write a program and use
all 3 techniques to propagate errors)
— Modern languages (eg C++17/C++20, Rust) support the 4"‘ method
as well‘ /

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
a; Error management
———m-
Case 1 (return True/False) Yes Yes Yes
Case z (return error code) Ves Yes Yes
Case a (exceptions) - Yes »
Case A (return True+value for success, False otherwise] - stdmptional Option
Case 4 (return valua for success, error lnformatlon - stdzexpectad Result
otherwise) std::variant

***************Ending Page***************

***************Beginning Page***************
***************page number:73**************
E: EFFOI' management
' What differentiate Rust from the rest of the languages that
implement the 4th method is that Rust does not implement
exceptions.
- This means that a programmer can decide to use either case 1,2 or 4
in Rust if he/she wants to return an error.

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
E: Error management
Error management in Rust is done via:
1. - macro (if we want to immediately exit a program)
2. - template/generic type (if we want to return a value or
nothing — the latter meaning that an error has occurred)
3. - template/generic type (if we want to return a value or an
error that explains what happened).

***************Ending Page***************

***************Beginning Page***************
***************page number:75**************
Error management (panic)

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
g; Error management (panic)

A “panic” is a critical runtime»error that you can not recover from.

In Rust, these situation can be encountered in two scenarios:

1. The execution flow reach a point where the outcome cannot be
computed in a deterministic way (e.g. a possible undefined
behavior). Stopping the execution at this point Will provide more
information for a developer to fix the actual issue (e.g. a heap
overflow). In Rust this is done at thread level (meaning it will stop
the current thread, not the entire process).

2. The logic of the problem / its purpose can not be served anymore,
and the programmer decides to stop the problem at the current
point of the execution.

***************Ending Page***************

***************Beginning Page***************
***************page number:77**************
i
Error management (pamc)
Rust provides a macro called - ) that can be used to abord a
program immediately. macro has two forms:
' a R
Pam“! ()1 “MW r
panic! (message); fig;
pamill'TxpeCting Fl: yr m he smaller‘ than v1:

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
.
Error management (panic)
Panic errors can also be triggered if the programmer is trying to
perform an operation with an undefined result:
Rust
w-jntlnl rm: “ i; ‘ ‘W ‘fulﬁl’ Stirling???volt-Quanttu-hwt “W. an m “th U n:

In this case, there is an attempt to read a value from a vector outside
its bounds, While it is possible that the memory from the offset "10”
(the value of.) is accessible (e.g. a value on the stack) the outcome
is undetermined and it is better to cause an abort at this oint that try
to understand an error thrown by an incorrect value of a later.

***************Ending Page***************

***************Beginning Page***************
***************page number:79**************
g; Error management (panic)
lts also important to notice that Rust tries t0 identify this kind of error
from the compile phase. Let‘s compare the next three cases:

Z '1-31,
iiiii‘: ii
‘my? ' ‘ That's obvious (“[101 is clearly out or bounds for an
V H _ _ M array nf3 elements].

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
i
Error management (panic)
Its also important to notice that Rust tries t0 identify this kind of error
from the compile phase. Let's compare the next three cases:
Rust Rust (1.51.0)
-: [1a], ,: [31]],
FFJULlH‘ i “,1: “i, [w'niliriii“x: “i;

***************Ending Page***************

***************Beginning Page***************
***************page number:81**************
®
Error management (pamc)
Its also important to notice that Rust tries to identify this kind of error
from the compile phase‘ Let's compare the next three cases:
Rust Rust (1.51.0) Rust (1. 71.0}
"131er k mutt t; 31ml‘ 1
. * [10,28.38]: 1*[18.ZB,30]; 1*[1E7.ZB,39];
-: [m], -:.[Iﬂ]], ,: [[8]]-
pr‘)ntln‘\“;1: “,r, [w'irleH'V“x: “3; minnow‘: “r;

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
g; Error management (panic)
Rust 1.71.0 seems to be able to identify even more complicated cases
(for example when we use more complex equations)
-: 'm rr' rm‘
; m nnr r,
H ll “all” ‘H l W l v l The compile makes the correct inference (v[0] = 10,
r a. .l-m .m .nn m _‘ v[1]=ZO,v[0]"v[0]/v[1]=10‘10/20=100/20= s

***************Ending Page***************

***************Beginning Page***************
***************page number:83**************
i
Error management (panic)
A solution to “trick” rust compiler and make it not detect an out of
boundary case is the following:
Rust/l 71.0)
Sfi'l"'lflr‘l€‘1'l r i, tl'ir'Ead 1. evr'il'
or’ a: :"Wki;
‘owl .rwm “will.
1 : M r .~ “will, Vi.-.V‘1.l‘l_l‘<1-Hul’lli|
7 7w, w‘ ml;
. r [PM l1
“Pmtlmlnﬂ: ' “l; we,“ M remind m, “u len. n> w, 4W», “V i :
v ,m who; navy“)!

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
Error management (panic)
A solution to “trick” rust compiler and make it not detect an out of
boundary case is the following:
Rll51(l 71.0)

steam ‘.lr‘uiii utensil,

Keep in mind that this solution was tested With Rust 1.71.0
It is possible that future version of Rust might detect this behavior from
the compile time and trigger a compile error instead of runtime panic.

***************Ending Page***************

***************Beginning Page***************
***************page number:85**************
g; Error management (panic)
Rust also has a method (catch_unwind) that can be used to capture a
panic (similar to what try...catch mechanism is doing).

However, it is not recommended and if used with C++ exceptions from
an exported function, the behavior is undefined.

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
.
Error management (panic)
Rust also has a method (catch_unwind) that can be used to capture a
panic (similar to what try...cutch mechanism is doing).
RUE!
' m 1v‘ my‘ ‘7M W —

***************Ending Page***************

***************Beginning Page***************
***************page number:87**************
. Error management(pan|c)
Rust also has a method (catch_unwind) that can be used to capture a
panic (similar to what trymcatch mechanism is doing)‘

RIIS!

WHMHW-w: . 1M Function wassuccessiul r» rewm value i5.2

returi - ;

um": ,
i Z ﬁttizzpmrm eitii Wilma“; i» Wm," i;

\r mwjiiui
pi’ii'itli'i!i'"Fun(ti0l\ \-1a5 successful r> return value is: .miiiiqqii‘
pr'lhllviii'Turictiun felled with panic“),

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
Error management (Option type)

***************Ending Page***************

***************Beginning Page***************
***************page number:89**************
a Error management (Option type)
Rust Option type allows a function to return two scenarios:
' A ﬁ case (something is not OK) —) and no value associated
' A true case 9 the requested value is returned,
m: (Source: Dpfl'DﬂJS from rare library] Simplified View
pit’ iii-inn opnmun i
r m QHHPi Option <r:-
None, i
NONE,
saw-(T),
i
Sewer’ Ti.
i

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
.
Error management (Option type)
Let's consider the following problem 9 we would like to write a
function that returns a number only if the parameter is odd, or no
number if the parameters is even.
Rust Rust
\,iﬂl1i‘lDT>"OCll‘ll:l'lI ji 7;, : > validatwiritiiﬂri: ji 7;‘ 1 7

l Jl'lllllZIIIll l 1ina2::1\'

return Srini/‘l'i'l; Sow/‘(M

r e15! i; 0r g» e15! (
FETHV'H NUHE; NONE

***************Ending Page***************

***************Beginning Page***************
***************page number:91**************
Error management (Optlon type)
Option type has the following methods:
unwrepr ) -> Returns tne value irno error is present or panics
otherwise
expect( , we‘: & ) e; Returns tne value ir no error is present or panics
wrlh a speciﬁc message otherwise
unwrapioﬂ , delauit: ) -> Returns tne value ir no error is present Ora default
value in case oi error
unwrepiorielsm >< , r; ) 7:, Returns tne value rr nu errur ls present nrthe
result of a functron m case or error

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
® Error management (Optlon type)
Let's see some possible usage of validateOdd(...) function:
RUST
+1‘ \.'=11id:1Leudd(nt 13:) ~0pUmvi31; r r
(71!"an g
[1!‘erle r “Hr nr r‘ r "~11 H‘, rsnnm'am'Y);
r r
pmnrlnn“ rr'ﬁr "r;
)
7,

***************Ending Page***************

***************Beginning Page***************
***************page number:93**************
a Error management (Option type)
The same example can be written using the match keyword in the
following way (this is actual recommended way to check the value of an
Option).

Rust
+11 iaiimrvjmim mi a, I'lptirri'i\i:'2\ i )
irr r : liniiimwimiusi;
r i
Sonieivaluei :) prlntlnli" r 1 W: ivaluel“",\.
wa :> [winflnliml r ii i ii niii “i,

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
® Error management (Option type)
Let's see some possible usage of —function:
Rust
“.‘Bllrlaté mam; 3 7;, 1 , .; __ l
r : “1mm! urlr1(5).uvn~napl_"r;
In this case we expect —function to work correctly.
Variable I is of type i32.

***************Ending Page***************

***************Beginning Page***************
***************page number:95**************
.
Error management (Option type)
Let's see some possible usage of —function:
Ru$f
‘valldate mam; ji 7;» : ) i .. i
mam i
i : \‘dljdeLE Utiril.uiii~.‘r3pi_'i;
pr‘i|vt1nli_'"N\mlber‘ is odd: "m;
In this case, since 4 is not odd, a panic (runtime) error will be triggered.

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
I
Error management (Optlon type)
Let's see some possible usage of —function:
Ru$f
Mandate ‘134911773 ‘A 77> Z ) 1' .. 'r
mam 1
printlnlr'"Number‘ is odd: ","r;
In this case, since 4 is not odd, a panic (runtime) error will be triggered.

***************Ending Page***************

***************Beginning Page***************
***************page number:97**************
® Error management (Option type)
Let's see some possible usage of —function:
Rust
walldate mam; ji 7;, 1 , i __ i
i : “lame utilii-Qluiivnati til-n1);
In this case since we have used method, the Option<i32>
value is evaluated. Since, 4 is not an odd number, the error case will be
triggered and the default value will be returned (in this case, it is I)

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
® Error management (Optlon type)
Let's see some possible usage of validateOdd(...) function:
RUST
rm validmgmn'r; in‘; V, @ptinmnz: \r )
m respunie nnmutwry V» 1:4 r
'1; There is an error!

j Number is odd. '1
rm “mum 1

1o. r‘ : validate ut1t1(4).uvu~.vap w elBeLr'espunSe rwtumn;

pr‘i|'rt1nlt'“t. rm‘ r 1' H~1 U ‘,m;
'r‘
Similarl a function that returns the value in case of error can be used
via ‘unwrap_or_e|se method‘

***************Ending Page***************

***************Beginning Page***************
***************page number:99**************
® Error management (Option type)
Let's consider the following code:
RUS!‘
ﬁr mam» i;
irr "HIT x; [irifinnl‘lry‘1r‘ig> : Souveijﬁrmng::h-mviw, rr'nqﬁii;
1m um y: [vptmizsn-mg: None;
pr‘)ntlri.‘\'_“-:i “in F-iﬂi“.><.y,>;
y Z X;
prilitlrvii“- rm , i"'i“.><vy);
What is the issue with this piece of code ?

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
-
Error management (Optlon type)
Let's consider the following code:
Ruif
{r , ,
‘\ irnnw 1‘. I PR 1‘ r‘

***************Ending Page***************

***************Beginning Page***************
***************page number:101**************
g; Error management (Option type)
Assignments between enums follow the same rules as for other data types. ln
particular for Option, since String does not implement the Copy trait the ownership
of that string is transferred entirely to variable "y" making variable "x" useful‘

But what if want to transfer iust the String (not the entire variable) and keep the
variable "x" but with the variant "None" .7 This feature is in particular useful is an
Option<T> is part of a structure from where its more complicated to remove it?
The solution is to use the method defined as following: lets assume
variable “s” is of type Option<T>; then will have the following effect:
~ If s l5 of type Some(T), then make sZ of type SomelT) and move the T value from s to sZ. Then
becomes None
- lfs is of type None, then make 52 oftype None and do nothing to s

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
I
Error management (Optlon type)
Let's consider the following code:
Ru$f
iridium i
.; , > Z Wei; ::+r-nwi"my st|‘ing"]"i;
t: : : None;

. 1 “mid-ii,‘ x:SOme1“my string», yINone
pr'ilitlni i "x: 1 y: - , ,3»; XINDDQ, y:Some["my string“)
Notice that after the call y = x.take(), x becomes , and the String

from x is transferred to y.

***************Ending Page***************

***************Beginning Page***************
***************page number:103**************
Error management (Optlon type)
Let's consider the following code:
RUST
rm mam r
1:" "m x: UDLlDrMSUUrg» : Sumersuurgzzrmmwjn, LL n Mr);
rrr "m y: r'mﬁnnwzwmp : None;
y : x.ta\’ér',‘r; x:Some(“mystrrng“},y:None
w'intln‘r'“- 1 r v -1 ".‘>“,va'»: XINcne,y:Some["mystnng“)
y : XAakkr'); X:None,v:NQnE
;-.mim1nlr"‘-:1»‘l, ,:-1»‘1“,><.y';
'r‘
In this case:
. First moves "my string" rmm "X" to "v" and makes "X" None
- Second : X, Laker ‘,1; has nothrngto move from “x” (as it is arready None) and as such
becomes None as well.

***************Ending Page***************


***************Beginning Page***************
***************page number:104**************
g; Error management (Option type)
How does an Option<T> looks in memory ?
The simplest way is to consider it as a structure with two fields (a bool
one and one of type T):
m_—
0k bool (oran aligned number) lfthis ﬁeld is 1 [true] than (he ﬁeld value is

correct and available, otherwise it is not

value r {the type from the template/generics] The actual value (only ifﬁeld uk n 1 (truel)
However, for some cases this template only contains the value. Since a
reference is never null, an 0ption<reference> in Rust does not need the
.field, and as such it is guaranteed to be of the same size as the size
ofa reference l

***************Ending Page***************

***************Beginning Page***************
***************page number:105**************
. .
Error management (Optlon type)
Let's see the sizes of an Otion in memory. For that we will use the following
standard command (—) , that is an equivalent of sizenf keyword
from C/C++s
Rust
“mm r
pr'intlnH"SJ'Ze of OptimKuSile> : std::mem::>L4e my. ;r 11>:
Dr‘1nttn.‘k_"5ize or 0pt10n<i22> : std::rrrem::z1veim::l ‘ ;;r)\:
printlnH'Size m‘ Optmndﬁd) : stdnmemnaimyrn: 1 “w,-
pr‘)ntlr‘r.‘\'_"SjZe or Optiomklstw : gtnzzruenrzzmze mm ‘a >.~r r);
prirrtan"SiZe of optiomsuxdszw : gm;;m(-m:;=1.—~;n+';;t = >=r_jr‘r;
r
5.19 Of Optrun<us|ze\ : s
Size ofOptron<r32>:8
5.12 utOptrnn<r5Ib= 15
Size Dr Option-‘Slstv : 1s
Size oi OptiorkBox<i32>> : s

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
Let’s discuss the previous resultst
—m—
usize a it can be either 2,4 br s (depending dn the architecture). ln this case it is a x64
architecture (meaning the size bf s).
0ptien<iaz> a Twn ﬁeld member (ﬁrst ﬁeld -) 4 bytes (with elignment) isthe 0k part, second
ﬁeld is an actual i32 value)
Opti0n<i64> 1s Two ﬁeld member (ﬁtst ﬁeld —> a bytes (with alignment) is the 0k part, second
field is an actual i54 value)
Option<&s!r> 16 One ﬁeld (the actual strvelue). If null then None value is considered.
Keep in mind that size_uﬁstr) = 1slpninter+si1e),bbth s bytes
Op¥i0n<Box<i32>> a One ﬁeld (the pbintet to an i32 value). If null, than ane value is considered. /

***************Ending Page***************

***************Beginning Page***************
***************page number:107**************
. Error management (Optlon type)
Now \et's see how Option handles memory for an enumeration:
M EE-
l
Fed, Green. Elue 5“ "NOW :1
l Srze of Option<Color\ : 1
mam 1
println.‘\'_"sze of Color : 5td::u\enr::s;;e min m);
m‘i|'rt1n.‘k"'Size oi; Optioerolol‘> : std::mem;=-:.~L~>~jr=;< 1 hr)»;
r
Notice that 0pti0n<Color> and Color have the same memory size.
Let's see why this happens.

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
g; Error management (Option type)
Let's evaluate how memory looks like in the following cases:
> w-wm
‘1 : Tnnvvl ::E"l,u"l;

***************Ending Page***************

***************Beginning Page***************
***************page number:109**************
Error management (Option type)
Let's evaluate how memory looks llke in the following cases:
Rust
H c COW COlQrIIReﬁ OZ

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
®
Error management (Optlon type)
Let's evaluate how memory looks like in the following cases:
Rust
c Color Coroaned oz
L11 Optrcm<Coth> Some(Color :Green) 04
char: Green
Some1Cok1r::Greenl

***************Ending Page***************

***************Beginning Page***************
***************page number:111**************
®
Error management (Optlon type)
Let's evaluate how memory looks like in the following cases:
Rust
c Color Coroaned oz
L11 Optrcm<Coth> Some(Colur :Green) 04
02 0pfron<cmer> None 01
Nuns i E
1 (Hex 01)

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
®
Error management (Optlon type)
The same logic applies for enums with multipre types:
M ED
demve! ‘,\
( rnteger(10],Doub\e(1.5|,None
Integeﬂ >,
Flean ).
sunlr 3,
uoubler ‘,\
1
mdirvrf) q
' : ::Integerr_'18jr;
d : ::Duub1&(1.5),'
'1: -< ~» : None; "n"
println‘ r" , , ",imm); I
) E!

***************Ending Page***************

***************Beginning Page***************
***************page number:113**************
. Error management (Optlon type)
There are some exception cases to this type of optimization:
“5' ED
11-‘ “1-1 ‘1 Size OFMuillVailleEnum : 1
‘ , ‘ SlIC of OpllorYMUillVEiUCEnum) : 1
Mgr-3*“,
mire-353.
were 1w.
I “mini i
U intlnl l “Sun BF liultiValucEnuivi : “, Std:‘uicm IILICiOlVI : ' vi'i'i:
pvjntlnlL“Slle of ovum:munivalugsnulw : sinnmwwsieo um»- - l» ji i.
In this case, MultiValueEnum has 254 values. As such it is still possible for Rust to
find an invalid value (255) to be used for cases. As such the size ofthe
enum and Option<..,> are the same (one byte).

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
I
Error management (Optlon type)
There are some exception cases to this type of optimization:
“5' ED
‘lﬂv'mr-l l
‘salt-I‘ 15L
‘ llllllllhll
pr‘1ntlr'ili“S)zE 0F l'lilltJValueEmmi : “, <trl"merri ' ' ‘v ii?‘ ' t ‘l l i;
pr'iv\tlnll“5125 0F [imamMillnvaluetntmr» Z ;tn:.wem.::i—i:ge:: t mi;
However, if an enum fills up the entire space of possible value, this will force the
Option to use an additional byte to represent the discriminant, As such, the size of
the Option<.4.> will be higher.

***************Ending Page***************

***************Beginning Page***************
***************page number:115**************
g; Error management (Option type)
It is also worth mention that Rust has several types that have similar optimization if
used with an Option:

- NonNull (a raw pointer that can not be Null)‘ In this case, the value Null (since it
is an impossible value) will be used to describe the None case from an Option
- N0nZero(numeric type) (an integer that can not be 0)‘ The following types are
allowed: NonZerol8, NonZerol16, NonZer0l3Z, NonZerol64, NonZerollZB,
NonZerolsize, NonZeroUB, NonZeroU16, NonZeroU32, NonZeroU64,
NonZer0U128, NonZeroUsize. These types are in fact wrappers around the basic
integer types that make sure that the value is not 0. As such, they can be used
within an Option and keep the same size in memory. /

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
® Error management (Optlon type)
Now let's see how a C++ representation of a Rust Option looks like‘
We will try to represent an Option<i32> in Rust‘
cw (possible representation [or Op!fon<i32>)
(M55 Uphonallnt r
rwl Bk,‘
int value;
nlhli'
Optionallntﬁ]: Ok<FEl:i), value-(B) r}
optionaumw v): 0mm), “mm r)
1nllr'n ‘rxnl hasivalueo Hm: r Wm“ 0k; }
lnllr: m valuer) runsl r n (xok) mm. “em-w; Irknn value; )
}

***************Ending Page***************

***************Beginning Page***************
***************page number:117**************
I
Error management (Optlon type)
And the usage within our function for odd numbers will look like this:
c“
(
m ;
41w;
Frpfbinn'lnf validareoddr unhn‘) r
if (value "r z :: 1)
PETUVVI Optionallnﬂvalue);
else
return OptionalIntU;
1

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
a Error management (Option type)
Similarly, for the case ofa reference (denoted by a non-null pointer in
C++), consider the following possible implementation:

CH
1age otitiwvalnereiemeTeInt
i
int ‘valuE;
Dlllllllii
nminnalr'rrwr-wrnlnrr_‘i 1 ValUEli'iHllpti“) i}
optimaHem-entertainiint “.‘l : valuei'vi (l
\nlimi ram llHSiv'SlHEiljl ('niij‘ r value !: win-m; l
Uillﬁi‘ ma ealuer') Lam
i
(value Z min-w) yew",-
‘value;
i
1';

***************Ending Page***************

***************Beginning Page***************
***************page number:119**************
. Error management (Optlon type)
C++ comparison:
andithem »( , +: ') , » 0pt10n< .~ anthen‘ && ﬁrm'ﬁ Cm) [from (‘H231
Obs: method is the opposite Df {so it is not necessary}.
C++ also supports a lot of operators on top ofstdxoptronal, Fa! examp/e (hasJu/ud) method is also
called via a casz upemmr m haul).

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
g Error management (Optlon type)
C++ comparison:
,_ std::opt10nal<int> v:1iJ:tcOcd(ir\t value) r
‘HH_%275§()'> < M 1f(va1ue%2::i)
mum So~c(n); PIWY'QWY'" value;
) Misti”, MUM return std::nullopt;
' >
} ) void ma,r() r
am r : VA rune-0mm);
F" 1 (Us q, \r (this ﬁrm-(1)
1? hr 7 4H U’ wwrﬂ as‘: , r.va1ur~());
print1n\(“~| r1» r’ w ()J C15“ U .
P> 0)) punt“ )7
r E159 r )
println‘<“[r r );
> ‘I
r

***************Ending Page***************

***************Beginning Page***************
***************page number:121**************
®; Error management (Optlon type)

As a general overview, use Option in the following cases:

1. You have a function that might or might not return a value of some type (one
good example will be something like a —unction that might be
able to convert a parameter into a valid number or it might be not)‘

< > StringToNumbeMs: & )
Instead of
Str‘ingToNt|rr1ber(s: & , result: & )

2. You need to return an error code from a function (etgu use the Option<T> to
include the error code, or None for no error code). This a less utilized case, but
it is still possible.

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
Error management (Result type)

***************Ending Page***************

***************Beginning Page***************
***************page number:123**************
a Error management (Result type)
Rust has a special generics/template type (declared as an enum)
named Result that is used for these cases:

mm (Soulce: resulzvrs fwm cure library) SimpllflEd view
glut‘ euuln Result-IT, 5:» {
pub ‘11.1w Resu1t<T, E.»
on’ T), l
our),
El‘l‘(E),
)
Err‘( E),
l

***************Ending Page***************

***************Beginning Page***************
***************page number:124**************
.
Error management (Result type)
Let's see some examples:
Rqu
ﬁi'm' inm'rl: , HQ: 3 e,» < , & v r
it v; :: e r
return Fr‘r‘("|]ivisioﬂ by Zero");
1» 811 r
)
Hmnrw ;
r, dimlbllﬂlsv 0);
r‘: “1]v1ElDHt5,1‘H
printw'" , r1, rm,-
r

***************Ending Page***************

***************Beginning Page***************
***************page number:125**************
.
Error management (Result type)
Note that division function can be simplified by removing the return
keyword and the final semicolon:
Rust
\1i‘"?ii'.r'il u; , 71.‘, l" ,s; :i
Errl"l)ivision by Zero“
i ~15“ .l‘
Mil r m
T0 PI'OVide even more le m; . l V. . t 1
clarity, and-can 1+ H- ﬁ 8i .7 _ ‘ H
be preceded by the 3 '1-11 l “Errl DIVJ>IDH by Leno l
enum name: ‘ 1:0lti_ul l rm

***************Ending Page***************

***************Beginning Page***************
***************page number:126**************
'
Error management (Result type)
To check if a Result contains an or an I value, use the methods:
/ ---//
Rust
‘11.131rnt'rl: , HQ’ '1" ' , ll : '1 1
nulmr 1
: t\;\.1‘1'ul'S.Br.
w \.1> e'mrl
pr‘)nt1n‘l“Err‘m‘ med: “, \'.\'JV'V"1 Lunsm'ap't t:
pintln‘:“5u|:cess, result is r UNLuHWJw'H.
‘ m

***************Ending Page***************

***************Beginning Page***************
***************page number:127**************
'
Error management (Result type)
To check if a Result contains an or an I value, use the methods:
/ ---//
Rust
‘11.;31rnr'rl: , n." '1" ' , Bl : '1 1
nulmr 1
: unrru 1'5...
pr-wnnwsrmw med: new“: mmmtvr r:
pintln‘:“5u|:cess, result is r urrjmmwwm.
‘ mm-
and a success case (eg. a division between 5 and 2)

***************Ending Page***************

***************Beginning Page***************
***************page number:128**************
Error management (Result type)
Why do we need that .unwrap() t0 get the or .value ?
Rust
l‘.\“';\rr'llll: ,n'v l" ,3 "l ..l
milinl'l l
: tlJ‘.1LJlel5.Zl.
1+ l» >- m;
pl‘1l‘ltlnll“El‘l‘ﬁl‘ med: “, hem ;
pvintlnl 1_“Su(ccss. result is ", l All l l.umn‘1pl"l l;
That's because both ‘err and .ok methods return an O tion and not the actual
value: and w
Where T and E are template/generics '\ , " \'
types define in Result enum. l()_']
l

***************Ending Page***************

***************Beginning Page***************
***************page number:129**************
Error management (Result type)

Result type has the following methods:

Returns the varue rl nu error .5 present or WK; wrth a Spenfm
message OIhEFWrSQ

Returns the varue rhw error is present or a deraurt tame m case cl
error

Returns the var-ta || no error I; present urlhe resuk ufa functrun m
(ass of Error

***************Ending Page***************

***************Beginning Page***************
***************page number:130**************
.
Error management (Result type)
Let's see how Rust result type is stored in memory:
L 1+ viu- 155 r
Frm.“ v v
UM ,Jlui r
Wm“ I r Z rig-Janet;
, 13:4:wi1stleeap,
M r .1; u‘ r t
i m‘1ntln‘1“ualue : ", \JH'HH'BPLUI

***************Ending Page***************

***************Beginning Page***************
***************page number:131**************
. Error management (Result type)
Let's see how Rust result type is stored in memory:
Rust‘
11:;1;i'¢r.:11w: r _ , v
L 1r viu- . 155 1.
t '1???“ ' ' +0 +1 +2 +3 +4 +5 +6 +7
‘ V UM ‘,JlHl r 01 DA DO DU UO DO DD UO
M r .1; u‘ r t
> Possibtestructure Cregresentation
m‘1ntln‘1“ualue : ", r.Hr'rHray'u_ n; s\ruc1Ererase(
1' unsignedcharinde-x;
t signed char vatun;
)

***************Ending Page***************

***************Beginning Page***************
***************page number:132**************
. Error management (Result type)
Let's see how Rust result type is stored in memory:
Rust‘
11:41am Jalmgi r r.» . , v
' 1r viu- . 155 1.
t 7152'?“ ' ' +0 +1 +2 +3 +4 +5 +6 +7
‘ V tjtir'ijrlui r DU DA CID DU E8 03 OD UO
‘ wmru; 1 E803 0000(hexl11000(0XE8+DX03‘256)
r : ‘5.’ r" mum-
’ ' ' Possibte structure Cregresentatiorv
prtr'anHWalué : ", VJH'HH'SPL u; structOkCasa(
t unsignedchirindex;
1 unsignedint vahlc;
)

***************Ending Page***************

***************Beginning Page***************
***************page number:133**************
. Error management (Result type)
Let's see how Rust result type is stored in memory:
Rust‘ Possrble structure Cregresentatron
11:;1;i'¢r.:11w: r _ , v
t . m ‘ union Resultii32’i8(
1* ‘W ' w 1 unsigned charindex;
Frm.“ v v
m‘ ,JlHl r 5mm‘
r unsigned char mdcx;
y unsignedint vatue;
“1.41m; 1 )Ok;
r Z tilirt'Jﬂrlﬂ't;
, 1:1:41'Jsrlaem; struct(
1‘ ‘J’ L“ ‘ ‘ unsigned Iharmdcx;
i m‘1ntln‘1“ualué : ", r.Hr'Hu'ay'H_ n: s'gmddm value;
1» )m;
r )

***************Ending Page***************

***************Beginning Page***************
***************page number:134**************
Error management (Result type)
Let's see how Rust result type is stored in memory:
RH“ Caller:
v Lifw'g'n '1 u): t _ v lea rmlr]
> n m 155 J‘ call Result::ls_ok
t M": “ ' ‘ NotlcethatRCX hutdslheaddressof-H!
[Wt 3M V t
WW 1 Z Hjuhm‘:
* )II C" ltftlﬁﬂi",
M
mwnHuHWahm : mwmw w:

***************Ending Page***************

***************Beginning Page***************
***************page number:135**************
Error management (Result type)
Let’s see how Rust result type is stored in memory:
Rust
JBZJWLileuc: r t, < , )
L 5+ value -: 255 r
Errrnatte »
,\ else \'
th'malue "t
‘r
r
"151ml r end_if
r Z ugly-Jana);
r : 132 0|‘ 1314580);
1r end_if:
t
pr)ntln\(“value = ", ruu'rwramj);
\
,

***************Ending Page***************

***************Beginning Page***************
***************page number:136**************
g; Error management (Result type)

Rust - type has two similarities in C++:

1. std::variant (available from C++17) —) more generic, and can be
adjusted to reflect a Result

2. stdzzexpected (available from C++23) —) this is the closest template
that mimics the way Rust Result works.

Note that std::variunt is not designed for error management (but it can

be used for this purpose). stdzzvariant can contain multiple different

types while Result only has two types.

***************Ending Page***************

***************Beginning Page***************
***************page number:137**************
' Error management (Result type)
C++ comparison:
Obs: method is the opposite of (so an equivatent rs not necessary)‘

***************Ending Page***************


***************Beginning Page***************
***************page number:138**************
g Error management (Result type)
C++ comparison:
Fn (.nluw: 1 t) < , >
( atd:‘varmntnntﬂit,Jrvt8it> JRZil)"iig<th value)
n witt- < 255 ( {
\"r'(.'a ,e ES J \r (value < )m)
) em r return (JHinWalue,
mom“: as 1 clsc
) return (lniKZitM/alue;
> )
Fr‘ U ( vuld ma'r\()
let "m r Z (w); 4
r‘ , (1600); auto r : IBZiOriliﬂl'a);
1r r. () r : LKZ ur,8(1968);
\j 1f (stdzzrm as :lHE'Y‘hd\]\/r‘<,¥\t32 L>(r‘))
pr-lntlnr(“,rmz) {) , r‘. ()); pmrvtﬂ 5m l<fn-:ew-tuntllitﬂrﬂ);
} )
)

***************Ending Page***************

***************Beginning Page***************
***************page number:139**************
g Error management (Result type)
C++ comparlson:
Fn (.nluw: 1 t) < , >
( atd:‘cxputcddntﬂit,intSib minimum value)
n witt- < 255 ( {
\"r'(.'a ,e ES J \r (value < )m)
) em r return (JHinWalue,
mun“: as 1 clsc
) return (lniKZitM/alue;
> )
Fr‘ U ( vuld ma'r\()
let mut r : (w); 4
r‘ , (1600); auto r : IBZiOriliﬂl'a);
1r r. () r : LKZ w ,mmee);
g 1r (rmasﬂalﬂm
pmnunrrwrw r) , r‘. m; mm“ 5w , r.va1ue());
} )
)

***************Ending Page***************

***************Beginning Page***************
***************page number:140**************
®; Error management (Result type)

It is worth mention that - can be used as a returned type for -
function, Option however can not. In order to use a - as a return
type for the main function, the I type has to implement a special trait
called Termination. For example, the following types implement this
trait:

' std::process::E><itCode

' Unit type “[)” or void

' Never type "l"

***************Ending Page***************

***************Beginning Page***************
***************page number:141**************
® Error management (Result type)

Let's see some examples:

Rust

m Mum e» Fauna‘), jar» r; M
m X I 10;
pl‘int1rrl(“- rug‘, X»;
OKUI‘)?

)

or with

Rust

w std::prchSSHEleCidP; M

r" mainﬁ V» ReitlltﬁEwitCude, 15:?» \'
m >< : 10;
pl'ir\t1n1(“- 11w, x");
Okrtutttme: :SUCCESS'r

\

J

***************Ending Page***************

***************Beginning Page***************
***************page number:142**************
Error management (Result type)
Let's see some examples:
Rust
mum ‘l e» ,_ . > l
- : 10;
pl‘irit1ril(">< : -l;
tllqleu
l
W nah Minn.“ .5 m “Wm, m m
Since “i32” does not implement the trait Termination, it can not be
used as valid type for the Ok variant of an Result from main function‘

***************Ending Page***************

***************Beginning Page***************
***************page number:143**************
If let
let else
While let

***************Ending Page***************

***************Beginning Page***************
***************page number:144**************
g; lflet/let else/while let
When used with enums, - and Hhave a special syntax that
allows de-structuring the enum an copy t e value associated with it
into a variable that Will further be used in the next expression block.
Format:

' if Ie! Enum Variantlvariable) = Expression { }

' while let EnumVariant(variabIe) = Expression { )

Where:

» Expression returns an Enum object. One ofthe variants ofthat Enum has to
be of type EnumVariant

» lfvariable is of type EnumVariant, the variable is initialized and the if
condition is considered to be true

e This also mean that while in complex expression from if let or while let form,
that variable is initialized and can be used.

***************Ending Page***************

***************Beginning Page***************
***************page number:145**************
-
If let/ let else / vvhlle let
Let's see a simple example:
Rust
BUUll ‘l,
Flnﬂtl_ l,
I‘,
mm l

l : ulntr-gr-mj1el:

1F MIMQEQWQ) : J l
mmmw is Integer‘ and has Value: l "1);

1,

***************Ending Page***************

***************Beginning Page***************
***************page number:146**************
®
If let / let else / vvhlle let
Let's see a simple example:
Rust
l
Ennll ‘l,
Irvtegel'( ‘l.
Flnat( v,
l
maul‘) l
1‘ : ::Integw‘(16);
pr‘intlnl("i is Integer and has v;
1,

***************Ending Page***************

***************Beginning Page***************
***************page number:147**************
®
If let/ let else / vvhlle let
Let's see a simple example:
Rust
l
Emil’ l,
Inlegem' ‘l.
llcvatl h
l
mmlj) {
1 : :tInLe_er‘(16:l;
pr‘intlnll_"i is Integer‘ arm
} l

***************Ending Page***************

***************Beginning Page***************
***************page number:148**************
0 .
If let/ let else / vvhlle let
Let's see a simple example:
Rust
l
Integerl ~,_ llslntegerand has value: 1o
l II‘;
Mil-ll: l
J : :tIntegerllGl;
+: ::Flnat(1.2,l;
n’ [:InLeger’( 1:1,Fluall'vlll : l_1,l'l l
Dr‘1ntlﬂll“i is Integer‘ and has value: w "l;
printlnll'T is Float and has value 1 >1 "1»;
l
)

***************Ending Page***************

***************Beginning Page***************
***************page number:149**************
'
If let / let else / vvhlle let
Let's see a simple example:
Rust
lf"l” lsuflype Integer and "f" lsuflype Floatthen
opy the value of “I” into "v1" and the value of "f" lnto "vZ'

***************Ending Page***************

***************Beginning Page***************
***************page number:150**************
. .
If let/ let else / vvhlle let
Let's see a simple example:
Rust
Hyman ‘l. Integerl ‘l, Floatl ) l
l : ::Integer‘<10l;
+' , ::Buull ‘,v;
1F llntegel'lell.Fll'JEitlUQ/\ : l1.ll l
primlnvl'd is Integer‘ and has value: 1 "v;
prinllnll'T J's Float and has value : ‘.1 "It;
1 else l
pr‘i|1tlnll_"N0 match“);
l
)

***************Ending Page***************

***************Beginning Page***************
***************page number:151**************
-
If let/ let else / vvhlle let
Let's see a simple example:
Rust
F (Integer'ldl.FllHtlnj/l : 41¢}

***************Ending Page***************

***************Beginning Page***************
***************page number:152**************
. .
If let/ let else / vvhlle let
This feature is in particular useful for usage with Option. For example:
Rust
lellélilelldll’§lValue: l r; 1 ) l
507Vli‘l_\‘1‘1llv‘l XZD
l Elie l X:1
None “:1
1' XZZ
l X14
“mu-ll}
l
' : B;
printlnll"): : l w;
- +: 1;
l
l

***************Ending Page***************

***************Beginning Page***************
***************page number:153**************
g If let/ let else / vvhlle let
The same logic with multiple variants can be used for as well:
frv (x: , WM: > r> < ><
w X < mlm { um'w'
Sume(><) ‘:O/FD
}else{ ‘fl'lfs
None “1'14
l
}
WC" O l
let mut X : 0,‘
while let (immi), smm~<j)) :( (X, s), (X ‘ a) 2)) (
mnﬂnlvz my l m‘);
X +1 l;
l
l

***************Ending Page***************

***************Beginning Page***************
***************page number:154**************
®
If let / let else / vvhlle let
The same logic with multiple variants can be used for - as well:
Rust
smaller maul-U 5)
qmnwjlmq- ~ 2, 8)
—

***************Ending Page***************

***************Beginning Page***************
***************page number:155**************
g; lflet/let else/while let
- is also a special syntax that allows direct initialization of a
variable from an expression that results in an enum (for example an
Option)

Format:

- let EnumVoriont(vuriab!e) = Expression else ( <error code> }
The error code is usually a panic macro , or a return values (if this is
called from a function). It should be noticed that this is a sugar syntax
for the following:

' let x = if let EnumVariant(variable) { variable ) else ( <error code>)

***************Ending Page***************

***************Beginning Page***************
***************page number:156**************
® If let/ let else / vvhlle let

Example:

Rust

{ll Llel4"l‘itl'ldHlV-.I 131, “Luv: iill " [lptlun<iil> l m
.\ l

None

{n "ml-ll) {
1w’ swam : whine, Lllaan, a) ‘g par\iLl[“:l:ll ll, illl,11i_‘; -‘l; l;
princlml“-:l><_l ‘,l;

l

Notice that "x" is of type i32 ! (and not Option<i32>)

***************Ending Page***************

***************Beginning Page***************
***************page number:157**************
. If let/ let else / vvh||e let
Example:
m:
\ else ‘I. ' 1 'wﬂ mum; Mm)“
"my-Hg; {
SUYHE(':] : ‘Smaller UidH- a) Else ‘g panimf'Faii to initialize x'w; ,L;
printivm"x: - ",>;
J‘

***************Ending Page***************

***************Beginning Page***************
***************page number:158**************
g If let/ let else / vvh||e let
You can also use syntax to return something from a function:
{n (XI ,value: >r> < >{
1r >< < value { °""‘"'
Smm‘(><) gelix[2):4
) else ( gelixl4):'1
NQHC
}
}
{n (vnlun: )'> {
let Some(x) : (value, 3) else ( return '1; };
X*2
l‘
f" O (
printlﬂlfgrrilff; U“, (2));
println!(“geL >111 f)“, (4));
}

***************Ending Page***************

***************Beginning Page***************
***************page number:159**************
Question mark operator (?)

***************Ending Page***************

***************Beginning Page***************
***************page number:160**************
® - r/ I!
Z Question mark operator( ? )
Rust has a special unary operator "I" that works with Option and

Result generics in the following way:
- Let's consider these ex ression: ”-', where ‘I’ is of type
— or i
' The "?” performs the following actions:
1. lfthe value of “I” is Some (for O tion) or 0k (for Result), then "I" gets
unwrapped and assigned it to "f'
2t lfthe value of "I" is None (for Option) or Err (for Result) and the function
where "-' operation is located returns an Option or Result, then the
function returns immediately the value of “I” -) a None or Err
OBS: ”?” operator can only be used in a function that has a return
type of Option<m> or Result<..i>

***************Ending Page***************

***************Beginning Page***************
***************page number:161**************
.
Question mark operator (”?”)

Let's see some examples:
Rust

Wm it‘: i’ 7 :iiiiil‘1§\iii\'—‘llu'r,‘FiiPilSiir

printlnii“ “, " Vi:
In this case since both Some(10) and Some(15) are valid, the result
returns the expected sum.

***************Ending Page***************

***************Beginning Page***************
***************page number:162**************
.
Quest|on mark operator (”?”)

If however, we change one of the parameters to None, the sum is not
possible anymore, but we don't need to change the code as the
execution will stop when evaluating "y".
Rust

ammJ: u" 1' l
r

dmrjrnv e 3,|r\:rjrur@r'19‘r, hnne'r:

pmntlvm“ r otter‘:

***************Ending Page***************

***************Beginning Page***************
***************page number:163**************
.
Question mark operator (”?”)
In reality, sum function can be written in two ways:
A) Using question mark operator ?
Rust
7 JR
B) Using if expressions Equivalent
Rust code
Z e.
1r _. r. ‘Wm r r-z-Lur'i How. ,r vlw-i : _.Jiv.‘rl;\_‘, r

***************Ending Page***************

***************Beginning Page***************
***************page number:164**************
.
Quest|on mark operator (”?”)
Its important to notice that the operator ”?” does not require the same
type to be used (but rather the same type for the error case).
RIIS!
,urzrr}~ 4 , ;
[\r'lr'rtlﬂlﬂ"'-t Z

***************Ending Page***************

***************Beginning Page***************
***************page number:165**************
.
Question mark operator (”?”)
Its important to notice that the operator ”?” does not require the same
type to be used (but rather the same type for the error case)‘
RIIS
.

***************Ending Page***************

***************Beginning Page***************
***************page number:166**************
Question mark operator (”?”)
Its important to notice that the operator ”?” does not require the same
type to be used (but rather the same type for the error case)‘
RIIS!

***************Ending Page***************

***************Beginning Page***************
***************page number:167**************
. .
Question mark operator (”?”)

The same logic applies for Result as well. In this case it is important for
a conversion between the error type of different Results to be possible.
RIIS!

hm w , . v ‘l

MW Evrrlbll

>',lilllll'~ 4 _ >. l

prmt1mq"-: Z

***************Ending Page***************

***************Beginning Page***************
***************page number:168**************
Question mark operator (”?”)
The same logic applies for Result as well. In this case it is important for
a conversion between the error type of different Results to be possible.
RIIS!
m BEE]
.
- Z hail?‘

***************Ending Page***************

***************Beginning Page***************
***************page number:169**************
Question mark operator (”?”)
The same logic applies for Result as well. In this case it is important for
a conversion between the error type of different Results to be possible.
RIIS!
_ OWLZZAi
_ pr)ntlnlﬂ"‘>: Z -i,

***************Ending Page***************

***************Beginning Page***************
***************page number:170**************
' ll II
Question mark operator ( ? )
The same logic applies for Result as well. In this case it is important for
a conversion between the error type of different Results to be possible.
RIIS!
hm l7, . - r
VLtlJYll Errrlblli
_ Z Plow." \er MJ nun“ . V
ji i - m “an 'Fromﬁ/lv is no! implemented m ‘131
‘H ll“ l l we m M31“ vm- two-mm r r r tilt-mm‘ Vuhrus :1 "H uriun w
_ pi’)ntlnlﬂ"'>t Z - l, Z nu: in: hillmnng whri twos- “vermin! tr'ui m-l r
In this case, Err(f64) can not be converted to Err(i32) so this type of
error can not be propagated.

***************Ending Page***************

 