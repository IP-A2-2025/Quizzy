[{content={parts=[{text=--FlashCardSeparator--
Single
--InteriorSeparator--
What does KMP stand for in the context of string searching algorithms?
--InteriorSeparator--
Knuth-Morris-Pratt
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
Is KMP commonly used in practice for string searching?
--InteriorSeparator--
No
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is the primary goal of the KMP algorithm?
--InteriorSeparator--
(right) Find a substring within a string
(right) Optimize string searching by reusing comparison information
(wrong) Sort a string alphabetically
(wrong) Compress a string
--InteriorSeparator--
medium
--InteriorSeparator--
1, 3
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In the context of the KMP algorithm, what does 'T' represent?
--InteriorSeparator--
The text string
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In the context of the KMP algorithm, what does 'P' represent?
--InteriorSeparator--
The pattern string
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the output of the KMP algorithm if the pattern P is not found in the text T?
--InteriorSeparator--
-1
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the time complexity of the naive string searching algorithm in the worst-case scenario?
--InteriorSeparator--
O(d^2)
--InteriorSeparator--
medium
--InteriorSeparator--
2
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is meant by "P appears in T at displacement i"?
--InteriorSeparator--
(right) P appears in T starting at position i.
(right) T[i..i+m-1] == P[0..m-1]
(wrong) P is alphabetically before T
(wrong) P is the reverse of T starting at position i
--InteriorSeparator--
medium
--InteriorSeparator--
2
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the core idea behind the KMP algorithm's optimization?
--InteriorSeparator--
Reusing information from previous comparisons to reduce unnecessary comparisons.
--InteriorSeparator--
medium
--InteriorSeparator--
3
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In the KMP algorithm, what is the "OVERLAP" string?
--InteriorSeparator--
The prefix of the pattern that matched the corresponding part of the text.
--InteriorSeparator--
medium
--InteriorSeparator--
3
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In the KMP algorithm, what is a "frontier"?
--InteriorSeparator--
A prefix of the pattern that also matches a suffix of the OVERLAP.
--InteriorSeparator--
medium
--InteriorSeparator--
4
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is the significance of choosing the largest possible frontier in the KMP algorithm?
--InteriorSeparator--
(right) Avoid missing potential matches.
(wrong) Simplifies the computation
(wrong) Reduces memory usage
(right) Ensures the most efficient shift of the pattern
--InteriorSeparator--
hard
--InteriorSeparator--
4
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
Why isn't the entire string considered as a frontier in KMP?
--InteriorSeparator--
Because shifting the pattern by the entire string's length results in no progress.
--InteriorSeparator--
hard
--InteriorSeparator--
5
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What value is assigned to f[0] when calculating the prefix function?
--InteriorSeparator--
0
--InteriorSeparator--
easy
--InteriorSeparator--
10
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What does the prefix function f[k-1] store in the KMP algorithm?
--InteriorSeparator--
The length of the longest proper prefix of the pattern P[0..k-1] that is also a suffix of P[0..k-1].
--InteriorSeparator--
hard
--InteriorSeparator--
6
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is the condition for the KMP algorithm to return a match at position i?
--InteriorSeparator--
(right) k == m
(wrong) i > n - m
(wrong) k > m
(wrong) i == n - m
--InteriorSeparator--
medium
--InteriorSeparator--
9
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the time complexity of the KMP algorithm?
--InteriorSeparator--
O(n + m)
--InteriorSeparator--
medium
--InteriorSeparator--
10
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the condition under which the KMP search loop terminates when there is no match?
--InteriorSeparator--
i > n - m
--InteriorSeparator--
medium
--InteriorSeparator--
9
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In KMP, if T[i + k] doesn't match P[k] and k is not 0, how is 'i' updated?
--InteriorSeparator--
i = i + k - f[k - 1]
--InteriorSeparator--
hard
--InteriorSeparator--
8
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
In KMP, if T[i + k] doesn't match P[k] and k is not 0, how is 'k' updated?
--InteriorSeparator--
(right) k = f[k - 1]
(wrong) k = k - 1
(wrong) k = 0
(wrong) k = f[k]
--InteriorSeparator--
hard
--InteriorSeparator--
8
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In KMP, if T[i + k] doesn't match P[k] and k is 0, how is 'i' updated?
--InteriorSeparator--
i = i + 1
--InteriorSeparator--
hard
--InteriorSeparator--
8
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the purpose of the 'k' variable in the KMP algorithm?
--InteriorSeparator--
It represents the number of symbols that have matched between the text and the pattern at the current displacement.
--InteriorSeparator--
medium
--InteriorSeparator--
5
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which of the following represents a benefit of using the KMP algorithm over the naive string searching algorithm?
--InteriorSeparator--
(right) KMP avoids unnecessary comparisons by reusing information from previous matches.
(wrong) KMP is simpler to implement
(wrong) KMP uses less memory
(wrong) KMP can be parallelized more easily
--InteriorSeparator--
medium
--InteriorSeparator--
3
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
If the longest frontier of P[0..i-1] has length x, what is guaranteed about P[0..x-1] and P[i-x..i-1]?
--InteriorSeparator--
P[0..x-1] == P[i-x..i-1]
--InteriorSeparator--
hard
--InteriorSeparator--
10
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
When calculating the prefix function, if P[k] == P[i], how is f[i] updated?
--InteriorSeparator--
f[i] = k + 1
--InteriorSeparator--
hard
--InteriorSeparator--
11
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Why can the inner `while` loop in the prefix function calculation execute a maximum of 'm' times in total?
--InteriorSeparator--
(right) The variable `k` only increases by 1 at a time and never goes below 0.
(right) The `while` loop only decreases the value of `k`, which cannot decrease more often than it increases.
(wrong) The length of the string is bounded by `m`
(wrong) It is related to the length of the alphabet
--InteriorSeparator--
hard
--InteriorSeparator--
11
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In the KMP algorithm, what is the relationship between the frontier of a string of length k and a frontier of a string of length k-1?
--InteriorSeparator--
The frontier of length k extends a frontier of length k-1 by one symbol.
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What does the notation S[i..j] represent?
--InteriorSeparator--
The substring of S starting at index i and ending at index j.
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In calculating the prefix function, what does `k = f[i-1]` initialize 'k' to?
--InteriorSeparator--
The longest frontier of the string P[0..i-2].
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which of the following best describes the role of the prefix function (f) in the KMP algorithm?
--InteriorSeparator--
(right) It helps determine the next viable displacement when a mismatch occurs.
(wrong) It calculates the hash of the pattern for faster comparisons.
(right) It precomputes the length of the longest proper prefix which is also a suffix for prefixes of the pattern.
(wrong) It predicts the likelihood of the next character matching.
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
When the while loop in the KMP search algorithm terminates, which of the following conditions determine if a match was found?
--InteriorSeparator--
(right) k == m
(wrong) i > n
(wrong) i == n - m
(wrong) k == 0
--InteriorSeparator--
medium
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which scenarios lead to i + k increasing in each iteration of the KMP main loop?
--InteriorSeparator--
(right) When there is a character match (T[i + k] == P[k])
(right) When there is a mismatch at the first character of the pattern (k == 0)
(wrong) When there is a mismatch and k != 0
(wrong) None of the above
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What happens when calculating the prefix function, and the characters P[k] and P[i] do not match?
--InteriorSeparator--
The algorithm considers the next smaller frontier by setting k = f[k-1].
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Which of the following is true about the frontiers of a string?
--InteriorSeparator--
(right) A string can have multiple frontiers.
(wrong) A string has only one frontier.
(wrong) The longest frontier is always half the length of the string
(right) The empty string is a frontier of every string.
--InteriorSeparator--
medium
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In the context of string searching, what is a 'displacement'?
--InteriorSeparator--
The starting position of the pattern within the text.
--InteriorSeparator--
easy
--FlashCardSeparator--
}], role=model}, finishReason=STOP, avgLogprobs=-0.1831107385936394}]