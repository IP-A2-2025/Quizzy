***************Beginning Page***************
***************page number:1**************
Algorithm Design: Domain Specific Algorithms -
Strings
Stefan Ciobaca, Dorel Lucanu
Faculty of Computer Science
Alexandru loan Cuza University, laand, Romania
d1ucanu©info.uaic . ro
stefan.ciobaca@info.uaic.ro
PA 2020/2021
:l 51 - '= I: oqo
Algoritmi pis andruri PA 2020/2021 1/65

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
a Problem Domain
a Boyer-Moore Algorithm
a Boyer-Moore Algorithm Revisited
a Algoritmul Knuth-Morris-Pratt
a Regular Expressions
El 5' i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 2 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:3**************
Plan
a Problem Domain
BoyerelVloore Algorithm
Boyer-Moore Algorithm Revisited
Algoritmul Knuth-Morris-Pratt
Regular Expressions
:1 e? - -= :z oqo
Algoritmi pis andruri PA 2020/2021 3 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Alphabet, string

0 Alphabet : nonempty set A de characters
A1 I {A,a,B,b,C,c,...,Z,z}
A2 : {0,1}
A3 I N

9 string of characters: a finite sequence of characters in A
formal: s:{0,1,...,n—1}—>A

9 empty string: 5 : (Z) —> A

9 the length is| of a string s (or length(s) or s./ength()): the number of
characters of the string
iEi I 0
ifs:{0,l,...,n—1}—>Athen |si :n

9 s[i] - character on position i (O g i g |si);

6 substring: s[i..j] : s[i]s[i + 1] . . .sLi] (i gj)

Algoritmi pis andruri PA 2020/2021 4/65

***************Ending Page***************


***************Beginning Page***************
***************page number:5**************
The set of strings A*

o concatenation (product) of two stringsi $1 and $2: is the string $1
immediately followed by 52
$152 I $1[O] . . . $1[l51l — 1152[O] . . . SgHSgl — 1]
l5152l I l$1l + l52l

o se : as : s

o A* os the set of strings over alphabet A
A* the monoid freely generated by A
if A : {a17 . . .,am}, then A* I L((a1 —l— - - ‘ am)*) (we define later the
regular expressions and their language)

0 a language is a subset L Q A*

Algoritmi pis andruri PA 2020/2021 5/65

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Factor, subsequence
0 x is a factor of s iff there exists u, v. s.t. s : uxv
factor and substring are equivalent
x is a proper factor iff x 75 s (equivalently, uv 7Q e)
0 x is a preﬁx of s iff there exists v. s.t. s : xv
write x ﬁpref s
0 x is a suffix of s if there exists u. s.t. s I uX
write x gsuff s
o x is subsequence of s iff there exists |x| —l— 1 strings W0, W1, . . . , w|x|
s.t. s : w0x[0]w1x[1] . . .x[|x| — 1]W|X| (i.e., x is obtained by erasing
lyl — lx| characters in s); write x gsseq s
Exercise
Are there gpref and gsuff partial orders? I
El [5' i E :5 $1‘:le
Algoritmi pis andruri PA 2020/2021 6/65

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
Lexicographic order
0 lexicographic order:
Assume a total order g on A. Extend g to A* x A* as follows:
51 g 52 iff 51 gm; 52 or there exists u, v, W G A* and a, b G A s.t.
$1 I uav, $2 I ubw and a < b.
Exercise. Write in Alk a function that decides the lexicographic order
between two strings.
El r51 i E :5 ‘)QQ
Algoritmi pis andruri PA 2020/2021 7/65

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Occurrence
o x occurs in s ifx is a factor of s
o x has an occurrence at start position i in s if s[i] . . . s[i + |x| — 1] : x
0 x has an occurrence at end positionj in s if s[j — |x| + 1]. USU] : x
0 first occurrence of x in s is the smallest start position (if there exists)
El 5' i E :5 ‘)QQ
Algoritmi pis andruri PA 2020/2021 8/65

***************Ending Page***************


***************Beginning Page***************
***************page number:9**************
String Searching (Matching) Problem
Input Two strings: s I s[O] . . . s[n — 1], called subject or text, and
p : p[O] - ‘ - p[m — l], called pattern.
Output The first occurrence of the pattern p in the text s, if any; —1,
otherwise.
Variant: find all occurrences:
Input Two strings: s I s[O] . . . s[n — 1], called subject or text, and
p : p[O] - ‘ - p[m — l], called pattern.
Output A set M consisting of all the occurrences of pin s.
Algoritmi pis andruri PA 2020/2021 9/65

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
The naive algorithm: helper
/* @input: strings s[0..n—1], p[0..m—1],
a position i, O <= i < n
©output: true, if p <=_pref s[i..n—1]
false, otherwise */
occAtPos(s, p, i) {
n = s.size();
m = p.size();
for (j = O; j < m; ++j) {
if (i+j >=n || s[i+j] !=p[j]) {
return false;
}
}
return true;
1'
Execution time: O(m) in the worst case
m a 2 E 2 \oqo
Algoritmi pis andruri PA 2020/2021 10/65

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
The naive algorithm
/*
@input: strings s[O..n-l], p[O..m-1]
@ouput: the first occurence of p in s, if any
—1, otherwise
*/
firstDcc(s, p)
{
n = s.size();
m = p.size();
for (i = o; i < n; ++i) {
if (occAtPos(s, p, i)) {
return i;
}
}
return —1;
}
m a 2 E s ‘000
Algoritmi pis andruri PA 2020/2021 11/65

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
The naive algorithm: the worst case analysis
Time: O(n - m) in the worst case,
Exercise: 1. What is the worst case?
Remains the algorithm correct if we replace i < n by i < n — m in the loop
for? What about the execution time?
El 5' i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 12/65

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
The naive algorithm: expected time
Assume that A has d characters, d 2 2.
X _ 1 ,s[i-1] and p[j-1] are compared
U 0 ,otherwise

p,-J- = Prob(X,-J- = l) = F (the first] — l characters |n p must match)

the number of comparisons : 2:11_m 2111 Xij

the expected number of comparisons = Rizal-"1 271:1 Xij)

g 2(n + 1 — m)

Question: are there algorithms requiring O(n) for the worst case?

cl 51 2 E :2 oqo

Algoritmi pis andruri PA 2020/2021 13/65

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
A bit of history

0 1970, S.A. Cook: assumes that El algorithms O(n + m)

o Knuth and Pratt au refined Cook's theory into an algorithm

o Morris independently discovered the same algorithm

o 1976: Knuth, Morris and Pratt algorithm (KMP)

o 1977: R.S. Boyer and J.S. Moore design an algorithm on a different
idea

o 1980: R.M. Karp and M.O. Rabin design an algorithm on a
hashing-based idea (see the seminar)

Algoritmi pis andruri PA 2020/2021 14/65

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
P | a n
e Boyer-Moore Algorithm
cl 51 - '= :5 Q q 0
Algoritmi pis andruri PA 2020/2021 15/65

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Example
012 3 4 5 6 789101112131415161718
IIII-IIEUEU@EE U@I
75
EIE
19 20 21 22 23 24
EIIEE
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:17**************
Example
012 3 4 5 6 789101112131415161718
IIII-IIEUEU@EE U@I
75
EI®
19 20 21 22 23 24
Elm
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Example
O l 2 3 4 5 6 7 89101112131415161718
IIIIIIIEUEEU®§EE U@I
75
EI®
19 2O 21 22 23 24
EI®EI
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:19**************
Example
012 3 4 5 6 789101112131415161718
IIII-IIEUEU@EE U@I
75
EIE
19 20 21 22 23 24
Elm
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Example
012 3 4 5 6 789101112131415161718
IIII-IIEUEUEEE UEI
75
EIE
19 20 21 22 23 24
EIIEE
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
Example
012 3 4 5 6 789101112131415161718
IIII-IIEUEUEEE UEI
75
EIE
19 20 21 22 23 24
EIIEE
E
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Example
0 1 2 3 4 5 6 789101112131415161718
IIII-IEUEU@@EE U@I
E
19 20 21 22 23 24
EIE@I
7é
I®
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:23**************
Example
0 1 2 3 4 5 6 789101112131415161718
IIII-IEUEU@@EE U@I
19 20 21 22 23 24
mm®®m
E IE
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Example
0 1 2 3 4 5 6 789101112131415161718
IIII-IIEUEU@EE U@I
19 20 21 22 23 24
Ell-E
EIE
E
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
Example
0 l 2 3 4 5 6789101112131415161718
IIII-IIEUEU@EE U@I
19 20 21 22 23 24
EIII®
EI®
cl 51 - '= I: @ch
Algoritmi pis andruri PA 2020/2021 16 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Bad character shift rule 1/3
Avoids unsuccessful comparisons with characters from the subject that do
not occur in the pattern or in a (maximal) suffix of it.
shift[C] I
(m — 1) — the last occurrence position , _
_ , 1f C occurs 1n pattern
of C 1n pattern
m , otherwise
(alternatively, shift(C) : max({0} U {i < m | p[i] I C}))
El r51 i E :5 ‘JQCV
Algoritmi pis andruri PA 2020/2021 17/65

***************Ending Page***************


***************Beginning Page***************
***************page number:27**************
Bad character shlft rule 2/3
i i+shift[‘A’]
j casel:shift[‘A’]Zm-j
i i+m-j
_
j case2:shiﬁ[‘A‘]<m-j
First case: i = i + shift [s [i1];
Second case: i = i + m — j;
El 5' i E :5 ‘JQCV
Algoritmi pis andruri PA 2020/2021 18/65

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Bad character shift rule 3/3
If pm ¢ Sm I c.
0 if the rightmost occurrence of C in p is k <j, p[k] and s[i] will be
aligned (i : i + shift[s[i]])
9 if the rightmost occurrenceof C in p is k >j, p is sfifted to right with
one position (i I i + rn - j)
9 if C does not occur in p, the pattern p is aligned with s[i+ 1..i+ m] (i
: i + m). Become a particular case of the ﬁrst one if shift[s[i]] : m.
Algoritmi pis andruri PA 2020/2021 19/65

***************Ending Page***************


***************Beginning Page***************
***************page number:29**************
Boyer-Moore Algorlthm (ver5|on 1)
BM(s, p, shift) {
n = s.size();
m = p.size(); SigmaInv(c) uses Sigma {
i=m-1;j=m—1; j=O;
repeat { while (Sigma[j] != c)
k = SigInaInv(s[i]); j++;
if (S[i] == P[j]) { return j;
i = 1-1; }
j = j-l;
} preBMBcs(p) uses Sigma {
else { m = p.size();
if ((m-j) > shift[k]) shift = [m | i from [1..Sigma.size()] 1;
i = i+m—j; for (i = m-l; i >= 0; ——i) {
else j = SigmaInv(p[i]);
i = i + shift[k]; if (shift[j] == m)
j = m-1; shift[j] = (In-1) - i;
} }
} until (j<0 || i>n—1); return shift;
if (j<0) return i+1; }
else return —1;
}
Algoritmi pis andruri PA 2020/2021 20/65

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Ana|y5|s
Worst case: O(m - n).
Expected time is much better.
We will see later that.
El 5' ' _= :E ‘)QG
Algoritmi pis andruri PA 2020/2021 21/65

***************Ending Page***************


***************Beginning Page***************
***************page number:31**************
P | a n
a Boyer-Moore Algorithm Revisited
cl a — -= I: J) q o
Algoritmi pis andruri PA 2020/2021 22 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Motivation

Bad character shift rule is inefficient if the alphabet is small (binary, for

example).

ln such cases the algorithm could be more efficient if uses the information

gained from compared suffixes.

This case is called the good suffix rule.

El 5' i E :5 QQQ

Algoritmi pis andruri PA 2020/2021 23/65

***************Ending Page***************


***************Beginning Page***************
***************page number:33**************
The good suffix rule: case 1
0123456789111111111122222
0123456 78901234
HIIIIIIHHHHHHHHHHHHHHHEHHH
HHHEHHIHHH
0 1 2 3 4 5 6 7 8 9
0123456789111111111122222
0123456 78901234
HIIIIIIHEHHHHHHHHHHEHHEHHH
HEREIN-HEB
0 1 2 3 4 5 6 7 8 9
i—1 :j—1 : 7, m : 10, s[i—1];é pL/—1], p[j..m—1]: s[i..i+m—j—1]
p[1..2] : p[8..9], p[O] 75 p[7] and p[1..2] is closest to p[8..9] having this
PrOperty U ﬁ 2 E
Algoritmi pis andruri PA 2020/2021 24/65

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
The good suffix rule: case 1, formally
Case 1:
if p[i — 1] does not match and p includes a copy of pU..m — 1] preceded
by a character 75 p[i — 1], then shift to the closest copy from left with this
property.
El r51 i E :5 ‘)QQ
Algoritmi pis andruri PA 2020/2021 25/65

***************Ending Page***************


***************Beginning Page***************
***************page number:35**************
The good suffix rule: case 2
0123456789111111111122222
0123456 78901234
EEIIIIIEEEEEEEEEEEEEEEEEEE
EEEEEIIEEE
0 1 2 3 4 5 6 7 8 9
0123456789111111111122222
0123456 78901234
EEIEIIIIEEEEEEEEEEEEEEEEEE
EEEEEIIEEE
O 1 2 3 4 5 6 7 8 9
i—1 :j—1 : 5, m : 10, pU..m—1]: s[i+m—j—1],
p[0..1] : s[8..9] is the longest preﬁx of p that is a suffix of s[0..9]
:1 51 i E :2 01110
Algoritmi pis andruri PA 2020/2021 26/65

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
The good suffix rule: case 2, formally
Case 2:
— if Case l is not applicable, then do the smallest shift such that the suffix
of s[0..i+m—j—l] is matched by a prefix of p
— if longest suffix of s[0..i+m—j—l] matched by a prefix of p is the empty
string, then shift with m positions
— but “suffix of s[O..i+m—j—1] is matched by a prefix of p" is equivalent
to “a suffix of p is matched by a prefix of p
— a proper factor that is prefix and suffix is called border

Algoritmi pis andruri PA 2020/2021 27/65

***************Ending Page***************


***************Beginning Page***************
***************page number:37**************
goodSuff(j) - definition (Case 1)

goodSufo) : the end position of the occurrence of p[j..m — 1] closest to

j and and it is not preceded by pLi — 1].

If such a copy does not exists, goodSuff(j) I O.

We have 0 g goodSufo) < m — 1.

Proposition

The values of goodSuff(j) can be computed inl O(m) time. I

The proof at seminar.

cl 51 2 E :2 QQG

Algoritmi pis andruri PA 2020/2021 28/65

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Preprocessing in Case 2

/p(j) I the length of the longest prefix of p that is suffix of pLi..m — 1].

We have

Proposition

lp(j) can be computed in O(m) time. I

The proof at seminar.

El r51 i E :5 QQQ

Algoritmi pis andruri PA 2020/2021 29/65

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
Good Suffix Rule
Assume that p[i — 1] does not match (aftert p[j..m — 1] matched).
9 lf goodSufo) > O,the shift with m — goodSuff(j) positions (case 1).
8 If goodSuff(j) I O, the shift with m — lp(j) (case 2).
If p[m — 1] matches, thenj : m and the shift is correct.
cl 51 t E :2 oqo
Algoritmi pis andruri PA 2020/2021 30/65

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Boyer-Moore Algorithm (version 2)
BM(s, n, p, m, goodSuff, 1p) {
k = m-1;
while (k < n) {
i = k; j = m-l;
while (j > o && p[j] == s[i]) {
i = i-l;
j = j-l;
}
if (j < O) return i+1;
otherwise pm does not match and shift with the maximum 0f the
values returned bu the bad character shift rule and the goof sufﬁx rule
1*
}
El 5' ' _= :E QQG
Algoritmi pis andruri PA 2020/2021 31 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:41**************
Boyer-Moore Algorithm: summary

o O(n + m) time if the pattern p does not occur in the text; otherwise
it remains O(m - n)

o however, with a simple modiﬁcation (Galil rule, 1979) O(n —l— m) time
can be obtained in all the cases

0 the original algorithm of Boyer-Moore (1977) uses a simplified form of
the good suffix rule

0 the first proof for O(n + m), when the pattern p does not occur in
the text, was given by Knuth, Morris and Pratt (1977); a different
proof was independently given by Guibas and Odlyzko (1980)

0 Richard Colen (1991) established a limit of 4n (with a easier proof),
then a limit of 3n (with a more complex proof)

Algoritmi pis andruri PA 2020/2021 32/65

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Pla n
a Algoritmul Knuth-Morris-Pratt
cl a] — '= I: J) q 0
Algoritmi pis andruri PA 2020/2021 33 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:43**************
Naive Algorithm1
Ell-WEE“
III...-
uuuuulu

1Exemplu din [CLRS] m 51 - '= :5 ‘)QO
Algoritmi pis andruri PA 2020/2021 34 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Naive Algorithm1
Ell-WEE“
5.....-
uuuuulu

1Exemplu din [CLRS] m 51 - '= :5 ‘)QO
Algoritmi pis andruri PA 2020/2021 34 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:45**************
Naive Algorithm1
Ell-WEE“
55-...-
uuuuulu

1Exemplu din [CLRS] m 51 - '= :5 ‘)QO
Algoritmi pis andruri PA 2020/2021 34 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Naive Algorithm1
Ell-WEE“
HEB...-
uuuuulu

1Exemplu din [CLRS] m 51 - '= :5 ‘)QO
Algoritmi pis andruri PA 2020/2021 34 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:47**************
Naive Algorithm1
Ell-WEE“
BEBE-.-
uuuuulu

1Exemplu din [CLRS] m 51 - '= :5 ‘)QO
Algoritmi pis andruri PA 2020/2021 34 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Naive Algorithm1
Ell-WEE“
HHHHHII
uuuuulu

1Exemplu din [CLRS] m 51 - '= :5 ‘)QO
Algoritmi pis andruri PA 2020/2021 34 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:49**************
Naive Algorithm1
Ell-WEE“
HHHHHII
uuuuulu

1Exemplu din [CLRS] m 51 - '= :5 ‘)QO
Algoritmi pis andruri PA 2020/2021 34 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
| t 't' 2
n Ul lOn
Eli-WEED
uuuuulu
uunun-u
uuuuulu
2Exemplu din [CLRS] m 51 2 E :2 QQO
D. Lucanu, 5. Ciobécé (FII 7 UAIC) Algoritmi pis andruri PA 2020/2021 35/65

***************Ending Page***************


***************Beginning Page***************
***************page number:51**************
Intuition3
III-HEHEHIIIIII
HHHHHII
EIIIEIIIEIII
BEBE-II
EIIIEIIIII
For the pattern ababaca, if at position i exact the ﬁrst 5 characters match,
then there is no chance that the pattern match at position i+ 1. But we
have chance at i+ 2. Why?
3Exemp|u din [CLRS] a 51 , E aw
Algoritmi pis andruri PA 2020/2021 36/65

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
Ideea
HHHHHHH-
cl 51 2 E :5 0 q 0
Algoritmi pis andruri PA 2020/2021 37 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:53**************
Idea
HHHHHHH-
cl a] 2 E :5 0 q 0
Algoritmi pis andruri PA 2020/2021 38/65

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
Idea
IIII-“I-I-IIII
II-I-m
We are interested to find the largest k s.t. x1 . . .xk is both prefix and
suffix of the matched prefix.
El i5‘ i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 39 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
Notations
o reminder: border (frontier) of a string t - un factor that is both preﬁx
and suffix of t
0 notation: maxFr(k) - the maximum border of p[O..k — 1] that is
proper factor of (71$ p[O..k — 1])
f[k] : |maxFr(k)| (the length of the longest border of p[O..k — 1])
oexamle' _ababaca
p ' p — 0 1 2 3 4 5 6
k maxFr(k) f[i]
1 5 O
2 a O
3 a 1
4 ab 2
5 aba 3
6 5 O
0 notation: u 3f, v iff u gmf v and u gsuff v
Algoritmi pis andruri PA 2020/2021 40/65

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
Reasoning problem domain 1/4
o formal definition of of maxFr(v):
maxFr(v) <f, v
maxFr v maxFr v
( l v ( l and
(VW)W <f, v implies W gf, maxFr(v);
i.e., the maximum border is maximum relative to 3f, as well.
w w
maxFr(v) v maxFr(v)
El i5] i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 41/65

***************Ending Page***************


***************Beginning Page***************
***************page number:57**************
Reasoning problem domain 2/4
0 notation: maxFrO(v) : v, maxFrj+1(v) : maxFr(maxFrj(v))
o we have:
<f, maxFrJ+1(v) <f, maxFrJ(v) <f, ' -- <f, maxFr1(v) <fr
maxFr0(v) : v
v = maxFr0(v)
maxFr l (v) V 11'me r l ( v)
maxFr2(v) maxFr2(v) maxFr2(v) maxFr2(v)
.InaxFr‘] (v) V muxFr l (v)
Algoritmi pis andruri PA 2020/2021 42/65

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
Reasoning problem domain 3/4
Theorem
u ﬁf, v dif there existsj 2 O s.t. u : maxFrj(v). I
Corollary
u <f, v if there existsj > 0 s.t. u : maxFrj(v). I
El 5' ' _= :E JDQG
Algoritmi pis andruri PA 2020/2021 43 /65

***************Ending Page***************


***************Beginning Page***************
***************page number:59**************
Reasoning problem domain 4/4

Theorem

lmaxFrj(p[O..k — 1])| : fj[k]. I

Since the borders ofi v : p[0..k — 1] are

<fr maxFrj+1(v) <1:r maxFrj(v) <fr <fr maxFr1(v) <fr

maxFr0(v) : v

it follows that their lengths satisfy the relation

< fj+1[k] < fj[k] < < f[k] < f0[k] : k

and the "shift" from maxFrj+1(v) to maxFrj(v) is equal to fj+1[k] — fj[k]

El 5' i E :5 {JQCV

Algoritmi pis andruri PA 2020/2021 44/65

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
Example 1/6
Here is an example how fli] is used for an efficient searching:
0 1 234567891011121314
EE-IIIHIIHEHHIIIIIIII
“BEBE-H
0 1 2 3 4 5 6
O 1 2 3 4 5 6
-%E-'E
o failure at position i: k : 2
o f[k] : f[2] I O
o shift with k — f[k] : 2 — 0 : 2 positions
o the next position to be compared: i: 2, k : f[k] : 0
cl 51 t E :2 QQG
Algoritmi pis andruri PA 2020/2021 45/65

***************Ending Page***************


***************Beginning Page***************
***************page number:61**************
Example 2 / 6
01234567891011121314
Eli-WE
ﬂuHuH-H
O 1 2 3 4 5 6
O 1 2 3 4 5 6
f I Hanna-u
mun“
0 failure at i: 2,k I O
o f[0] I?
o shift k— f[k] : 1, so f[0] : —1
o the next position to be compared: i: i+ 1 : 3, k = f[k] + 1 = 0
El 5' i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 46/65

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Example 3/6
01234567891011121314
RBI-WE
“llama-ll
0 1 2 3 4 5 6
O 1 2 3 4 5 6
f I "llama-H
mun“
0 failure at i: 3,k I O
o f[0] : —l
o shift with k — f[k] : O — f[0] : l positions
o the next position to be compared: i: i+ 1 = 4, k = f[k] + 1 = 0
El 5' i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 47/65

***************Ending Page***************


***************Beginning Page***************
***************page number:63**************
Example 4/6
01234567891011121314
qu-uuuuuuuuunu
BEBE:-
Hanna-ll
O 1 2 3 4 5 6
O 1 2 3 4 5 6
I§§m§
o failure at i: 9,k I 5
o f[5] I 3
0 shift k — f[k] I 5 — f[5] : 2 positions
o the next position to be compared: i: 9, k : f[k] : 3
El r51 i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 48/65

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
Example 5/6
01234567891011121314
Eli-WE
IIIHH-
Human-El
O 1 2 3 4 5 6
O 1 2 3 4 5 6
I§§m§
o failure at i: 11, k : 5
o f[5] I 3
0 shift k — f[k] I 5 — f[5] : 2 positions
o the next position to be compared: i: ll7 k : f[k] : 3
El 5' i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 49/65

***************Ending Page***************


***************Beginning Page***************
***************page number:65**************
Example 6/6
01234567891011121314
Ell-WEI
II-HHHH
HEEIIIH-EI
0 1 2 3 4 5 6
o the first occurrence of the pattern matching
El 5' i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 50 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Rules
0 if p[k] I: s[i] and k : m — 1, then we have an occurrence of the
patterns at the start position i — m + 1;
o if p[k] 75 s[i] then k becomes f[k] (k : f[k]), i.e., we test the next
border;
o if k I: —1 then increment both i and k;
o if p[k] == s[i] and k < m — 1 then increment botht i and k;
cl 51 2 E :2 00o
Algoritmi pis andruri PA 2020/2021 51/65

***************Ending Page***************


***************Beginning Page***************
***************page number:67**************
KMP Algorithm in Alk
KMP(s, p, f) {
n = s.size();
m = p.size();
i = O;
k = O;
while (i < n) {
while ((k != —1)&&(p[k] != s[i]))
k = fEk];
// k == —1 or p[k] == s[i]
if (k == m-l)
return i—m+1; /* gasit p in s */
else {
i = 1+1;
k = k+1;
}
}
return —1; /* p nu apare in s */
} m ﬁ 2 E 2 ‘000
Algoritmi pis andruri PA 2020/2021 52/65

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Execution Time
6 Remarks:
9 for any k, —1 g f[k] < k.
9 the value k increases at most n times (the same is true for i)
9 at each inner while loop k decreases, but it is always Z —1
9 per total, k cannot decrease more times than it increases
Q so the inner while will execute at most n iterations in total
9 Conclusion: the execution time for KMP is O(n)
cl 51 2 E :2 oqo
Algoritmi pis andruri PA 2020/2021 53/65

***************Ending Page***************


***************Beginning Page***************
***************page number:69**************
Failure function f: introduction
o since f is used when a comparison fails, f is also called failure function
o usualy denoted by 7t (e.g., in [CLR])
0 recall that f[i] : lmaxFr(p[O..i — 1])l (the length of the maximum
border of p[O..i — 1]
o example:
Human-u
mun“
0 A naive implementation with O(m3) time is possible (exercise)
o Question: if f[0..i — 1] is already computed, how f[i] can be
efficiently computed?
Algoritmi pis andruri PA 2020/2021 54/65

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
Failure function f: computation

0 recall that the'borders of v : p[O..i — 1] are:
<f, maxFrJ+1(v) <f, maxFrJ(v) <fr - -- <f, maxFr1(v) <fr
maxFr0(v) : v
and fj[i] I ImaXFrj(p[O..i - 1])

o it follows that f[i] : fk[i — 1] + 1, where k is the smallest integer
having the property p[fk[i — 1] —l— 1] I p[i — 1]

0 i.e., we look at the preﬁxes of p that are suffixes of p[O..i — 2] and
take the largest for that the next character is equal to p[i — 1]

o but the values fj[i — 1], j I 0,1,. .. are in f[0..i — 1]! (which is
already computed)

Algoritmi pis andruri PA 2020/2021 55/65

***************Ending Page***************


***************Beginning Page***************
***************page number:71**************
Failure function f: Alk description
f[0] = -1; f[1] = 0;
k = O;
for (i = 2; i < m; ++i) {
// invariant: k = f[i—1]
while(k >= o && p[k] != p[i—1])
// invariant: there exists j cu k = f‘j [i-1] si
// j is cel mai mic cu p[f“j [i-1]+1] != p[i—1]
k = f[k];
k = k + 1;
fEi] = k;
}
Execution time: 6(m).
The analysis is similar to that of KMP.
cl 51 t E :2 QQCV
Algoritmi pis andruri PA 2020/2021 56/65

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
Failure function as an automaton
—|b —\a —\c
a b a b a c a
start eggs“ a; m a o o
_la
ea
—\a
An automaton consists of:
o input alphabet (eg, a7 b,c7 . . .)
o state (e.g., —1,0,1,...,7)
o initial state (—1 in the example)
o accepting (final) state (7 in the example)
o instantaneous transitions: (e.g., —1 —> 0)
o labeled transitions; (0 i> 1,1 i> 2,2 i> 3, . . . ,0 1} _1, 1 l’> 0, . . .)
Algoritmi pis andruri PA 2020/2021 57/65

***************Ending Page***************


***************Beginning Page***************
***************page number:73**************
Plan
Problem Domain
BoyerelVloore Algorithm
Boyer-Moore Algorithm Revisited
Algoritrnul Knuth-Morris-Pratt
a Regular Expressions
El 5' ' _= :E @QO
Algoritmi pis andruri PA 2020/2021 58/65

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
Motivation: patterns in many text editors (e.g., Emacs)
From documentation (Emacs):
— Any single character except newline ("".\n)
One period
[O-9]+ One or more digits
[A 0-9]+ One or more non-digit characters
[A-Za-z]+ one or more letters
[-A-Za-zO-9]—l— one or more letter, digit, hyphen
[aA-Za-ZO—9]+ one or more letter, digit, underscore
[-,A-Za-zO-9]+ one or more letter, digit, hyphen, underscore
[[zascii:]]+ one or more ASCII chars. (codepoint O to 127, inclusive)
[[:nonascii:]]+ one or more none-ASCII characters (For example, Unicode charac
[\n\t ]+ one or more {newline character, tab, space}.
Demo cu Emacs
Algoritmi pis andruri PA 2020/2021 59/65

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
(Mathematical) Deflnltlon
Deﬁnition
The set of regular expressions over the alphabet Z is is recursively defined as
follows: _
0 a, empty are regular expressmns
O any character in Z is a regular expression;
o if e1, e2 are regular expressions, then e1e2 is a regular expression;
0 if e1, e2 are regular expressions, then e1 + e2 is a regular expression;
0 if e is a regular expression, then e* is a regular expressions.
Often we use parentheses to show how the above rules were applied; e.g.,
(a + b)*
cl 51 2 E i5 v?» ‘11ch
Algoritmi pis andruri PA 2020/2021 60/65

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
Abstract Syntactic Tree (AST)
a a + b (a + b)‘
cl 51 — '= :5 @ch
Algoritmi pis andruri PA 2020/2021 61/65

***************Ending Page***************


***************Beginning Page***************
***************page number:77**************
Relationship with the package <regex> in C++, Emacs
regular expression in math notation
[0-9] 0+1+--~+9
[0-9]* (0+ 1 + +9)*
[0-9]+ (0+ 1 + +9)(o + 1 + + 9)*
cl 51 t E :2 oqo
Algoritmi pis andruri PA 2020/2021 62 /65

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
The language deﬁned by a regular expression 1/2
Definition
The set of strings (language) L(e) described by a regular expression is recursively
deﬁned as follows:
0 L(e) : {a} (a is the empty string (of size zero)),
O L(empty) I Q)
0 if e is un character then L(e) I {e};
0 if e I e1e2 then L(e) : L(e1)L(e2) : {w1w2 | W1 G L(el), W2 G L(e2)};
0 if e : e1 + e2 then L(e) : L(e1)U L(eg);
0 if e : ei" then L(e) = UkL(ef), Where L(e?):{s},L(e{‘+1)= L(e1)L(ef);
O if e I (e1) then L(e) : L(el).
Remark. The operator _* is called Kleene star or Kleene closure.
cl 51 i E :2 Wwv
A'goritmi Pis andmri PA 2020/2021 63/ 65

***************Ending Page***************


***************Beginning Page***************
***************page number:79**************
The language deﬁned by a regular expression 2/2
Example: Consider A : {a7 b7 c}. We have
L(a(b + a)c) I {abc, aac} and
L((ab)*) I {5, ab, abab7 ababab7 . . .} : {(ab)k | k Z O}.
Justification:
L(a) I {a}
L(b) I {b}
L(b + a): L(b) U L(a) I {b7 a}
L(a(b + a)) : L(a)L(b + a) : {2b, aa}
L(C) I {C}
L(a(b + a)c) : L(a(b + a))L(c) : {abc7 aac}
L((ablo) I {6}
L((ab)1) : L(ab) : {ab}
L((ab)2) : L(ab)L(ab) I {abab}
L((ab)3) I L(ab)L((ab)2) : {ababab}
L((ab)*) : Uk>0 L((ab)k) : {5, ab7 abab, ababab7 . . .}
Algoritmi pis andruri PA 2020/2021 64/65

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
The end
The next lecture:
o the AST of regular expression in ALK
0 parsing algorithm
0 the automaton associated to a regular expression
o searching using the automaton
El 5' i E :5 QQQ
Algoritmi pis andruri PA 2020/2021 65 /65

***************Ending Page***************

