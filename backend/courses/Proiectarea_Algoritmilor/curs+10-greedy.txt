***************Beginning Page***************
***************page number:1**************
Algorlthm DeSIgn: Greedy Algorlthms I
Stefan Ciobaca’, Dorel Lucanu, Paul Diac
Faculty of Computer Science
Alexandru loan Cuza University of Ia$i, Romania
d1ucanu©info.uaic . r0
stefan.ciobaca@info.uaic.ro
paul.diac@info.uaic.ro
AD 2022
m 51 * E :5 OQO

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
E1 ﬁ ' _= :E l) ‘k O
D. Lucanu, S. Ciobécé, P. Diac (FlliUAlC) Greedy Algorithms AD 2022 2/1

***************Ending Page***************


***************Beginning Page***************
***************page number:3**************
Algorithmic Paradigms
P | a n
E1 ﬁ ' _= IE J) ‘k O
D. Lucanu, S. Ciobécé, P. Diac (FlliUAlC) Greedy Algorithms AD 2022 3/1

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
About Paradigms
0 paradigm : a typical example or pattern for doing something;
a method, model or standard.
9 algorithmic paradigm I a general method that can be used in the
design of a class of algorithms, solving problems of similar properties.
9 Examples of algorithmic paradigms: Divide and Conquer, Greedy,
Dynamic Programming, Backtracking, Branch and Bound.
0 Not to be confused with programming paradigms:
o imperative: procedural, object-oriented
o declarative: functional, logic, constraint programming
Greedy Algorithms AD 2022 4/1

***************Ending Page***************


***************Beginning Page***************
***************page number:5**************
Optimization Problems
P | a n
E1 ﬁ ' _= IE J) ‘k O
D. Lucanu, S. Ciobécé, P. Diac (FlliUAlC) Greedy Algorithms AD 2022 5/1

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Optimization Problems
An optimization problem is a computational problem that requires finding
the best solution out of a set of feasible solutions. The best solution can
also be called the optimal solution.
Best usually is either maximum or minimum, therefore the notions of
maximization or minimization problem are used.
A solution is feasible if it meets a set of validity constraints. Such an
solution is evaluated with an objective function clearly defined in the
problem; to rank among other feasible solutions.
In a discrete optimization problem, the variables defining both input and
output are discrete, defined over numerable sets like integers, strings, or
graphs. The opposite are continuous optimization problems working with
real or rational numbers: decimal variables.

Greedy Algorithms AD 2022 6/1

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
Relation to Decision Problems
Reminder from previous lectures:
A decision problem has the output yes or no, equivalently true or false, or
some other form of a binary outcome.
Optimization problems are often studied in their decision form. This is
useful for complexity analysis and reduction between problems.
To transform an optimization problem into the decision version of it, a
bound on the objective function result is added to its input. For example,
finding the shortest path between two nodes in a graph is transformed into
the problem of finding a path of total distance at most k.
However, in practical applications, optimization versions need to be solved
more frequently. For many of them, greedy is a good candidate as a
framework for designing a solution.

Greedy Algorithms AD 2022 7/1

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Greedy Ingredients
P | a n
E1 ﬁ _ _= :E J) ‘k O
D. Lucanu, S. Ciobécé, P. Diac (FlliUAlC) Greedy Algorithms AD 2022 8/1

***************Ending Page***************


***************Beginning Page***************
***************page number:9**************
Greedy General Description

Greedy can be applied to many problems of similar flavor: the solution can

be constructed by a sequence of similar steps in which a choice is made,

usually choosing for one element of the input if or how to include it in the

solution.

In each step greedy takes the best choice based on currently known

information and some local-view criteria. This may result in the optimal

solution or a suboptimal one, depending on the problem, on the criteria,

and possibly on the problem instance.

A greedy solution correctly solves a problem if it ﬁnds the best solution

possible on any valid instance. In practice, suboptimal results may be

acceptable, if no feasible algorithms are known to find the optimal solution.
Greedy Algorithms AD 2022 9/1

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Proving Correctness
Greedy algorithms are relatively simple to design and computationally
efficient, and easy to implement.
However, the downside is that their correctness is usually hard to prove.
A frequent method used to prove greedy correctness is the exchange
argument. lt incrementally modifies an optimal solution into the solution
produced by the greedy algorithm without worsening the solution's quality.
Thus, the greedy solution is at least as good as an optimal solution.
Other techniques used include induction, proof by contradiction, greedy
stays ahead method, matroid theory, and others.

Greedy Algorithms AD 2022 10/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
Problem Properties
P | a n
E1 ﬁ _ _= :E J) ‘k O
D. Lucanu, S. Ciobécé, P. Diac (FlliUAlC) Greedy Algorithms AD 2022 11/1

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Properties of Problems Solvable by Greedy Methods
Optimal Substructure: an optimal solution can be constructed from
optimal solutions of its subproblems. A subproblem is a instance of the
problem, smaller-sized then the original instance and that can take part in
solving the initial instance, based on some hierarchical structure with
multiple levels.
This is also a property of problems solvable by dynamic programming that
we Wlll learn in next lectures. The difference is in the following property.
Greedy Choice Property: there is a choice guided by certain criteria to
reduce a (sub)prob|em to only one of its possible subproblems. This
eliminates iterating over many and possibly overlapping subproblems. For
classic greedy algorithms, the choices are final, there is no need to
reconsider them at any further point.

Greedy Algorithms AD 2022 12/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
P | a n
E] ﬁ _ _= :E J) ‘K O
D. Lucanu, S. Ciobécé, P. Diac (FlliUAlC) Greedy Algorithms AD 2022 13/1

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Continuous Knapsack Problem
Given a knapsack of known capacity, and a set of objects, add fractional
parts of objects in the knapsack such that the selected parts are of the
maximum total value. Each object is described by its yalue and weight.
Input: n, v[O...n-1], W[O...n-l], W, all natural numbers
Output: p[0...n-1], p[i] € [0,1] C R, Vi € O, n-1 such that:
n—1
0 Z p[i] >< wli] g W total weight fits
i:0
n—1
o Z p[i] >< vli] is maximum profit possible
i:0
cl 51 t E :2 A“
Greedy Algorithms AD 2022 14/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
Continuous Knapsack - Example
For n : 3 objects:
i O 1 2
w[i] 1 2 3
v[i] 10 15 2O
Knapsack capacity W : 5 kg.
Maximum total value solution:
0 add the whole first object, or p[O] I 1.
added value: 1 >< 10 : 10, remaining: 5 — 1 I 4 kg.
9 add the whole second object, or p[1] : 1.
total value: 10 + 1 >< 15 : 25, remaining: 4 1 2 : 2 kg.
9 add 2/3 of the third object, or p[2] : O.(6)
total value: 25 + 2/3 >< 2O : 38.(3), remaining 2 — 2/3 >< 3 : 0.
Greedy Algorithms AD 2022 15/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Continuous Knapsack - Greedy Criteria

o Subproblem structure. At one step we can choose an object i and any
fractional number p[i] E [0,1] - the fraction of that object to add,
consistent with the remaining capacity. This would reduce to the
subproblem with n — 1 objects, v[n-1] and w[n-1] - without the
chosen element i, and capacity W — p[i] >< W[i]. The total value
possible for the subproblem +p[i] >< v[i] can be the total value
included in the original knapsack.

o Greedy Choice Property: the optimal solution for any subproblem, is
to choose the object with the highest v[i]/W[i] ratio, add as much of
it as possible to the knapsack: either full or a fraction that will ﬁll the
knapsack. Finding the solution to a (sub)problem always reduces to
only one other subproblem.

Repeat while the knapsack is not full and there are objects left.
Greedy Algorithms AD 2022 16/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:17**************
Continuous Knapsack - Proof of Correctness

Q by contradiction: assume that for some instance greedy solution
GREEDY : grd[0 . . . n-1] returns a solution of strictly smaller value
than one optimal solution, say OPT : opt[0...n-1]. We will prove
that OPT would be strictly better by exchanging some part of an
object with GREEDY, thus not optimal, thus the contradiction.

9 consider items sorted decreasing by ratios v[i]/W[i] Which are distinct.
nil nil

e Z grd[i] X v[i] g Z 0pm] X v[i].
i:0 i:0

0 let i be first idx such that grd[i] 51$ 0pt[i].
by design of greedy, grd[i] > opt[i].

Q then there must be an indexj > i such that grdU] < optLi].

Greedy Algorithms AD 2022 17/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Continuous Knapsack - Proof of Correctness, continued

6 consider the new solution EXH : exh[O...n-1] with
exh[k] : opt[k] Vk 51$ i,j.

0 exh[i] : opt[i] + f5 and exh[]] : opt[j] — e? >< W[i]/WU], E > O

9 a can be chosen small enough to have ethi] Z 0

e total weight of EXH is 22;}, exh[k] >< W[k] I
22;?) opt[k] >< W[k] + a >< W[i] — (a >< W[i]/Wm) >< W[j] the same
weight as OPT, so g W, therefore exh[] is a valid solution.

o the total value of EXH is: 22;; exh[k] >< v[k] I
22;, Oprlkl >< vlk] +5 >< v[i] - (e >< W[i]/W[i]) >< vm
which is Z value of OPT because:
6 >< v[i] — (r5 >< W[i]/WUD >< v[j] > O <:>
v[i]/W[i] > vU]/w[j] which is true because of 0 and 9.

Q contradiction: we found a solution strictly better than OPT.

Greedy Algorithms AD 2022 18/1

***************Ending Page***************


***************Beginning Page***************
***************page number:19**************
Continuous Knapsack - Implementation, Complexity

1 /*Input :n natural number of objects, W — capacity

2 v[O...n-1], w[O...n-1] — values and weights

3 Output2rnaximum profit = sum(v[i]*p[i]) such that

4 O<=p[i]<=1 is the part of each object */

5

6 sortObjectsO; // descending by v[i]/w[i]

7 usedWeight = 0; profit = O;

8for (i=0;i<n;i++){

9 if (w[i] == O || float(w—usedWeight)/w[i] >= 1) {

10 p = 1; // take it whole

11 } else {

12 p = float(w — usedWeight) / w[i];

13 }

14 profit += v[i] * p;

15 usedWeight += w[i] * p;

16 }

17 print(profit);

cl a] e E :5 oqo

Greedy Algorithms AD 2022 19/1

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Discrete Knapsack
Given a knapsack of known capacity, and a set of objects, add objects in
the knapsack such that the selected objects are of maximum total value.
Each object is described by its value and weight. Each object can be taken
as a Whole or not at all (O — 1 knapsack).
Input: n, v[O...n-1], W[O...n-l], W, all natural numbers
Output: p[O...n-l], p[i] €{0, 1}C N, Vi G O, n-1 such that:
n—1
o Z p[i] >< W[i] g W total weight fits
i=0
n—1
o Z p[i] >< v[i] is maximum profit possible
i=0
C. 51 e E :2 A“
Greedy Algorithms AD 2022 20/1

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
Discrete Knapsack - The (same) Input Objects
For n I 3 objects:
i 0 1 2
w[i] 1 2 3
v[i] 10 15 20
Knapsack capacity W : 5 kg.
Greedy choices using the same strategy: V[i]/WU] : [10, 7.57 6(6)]:
0 add the Whole first object, or p[O] I 1.
added value: 1 >< 10 : 10, remaining: 5 — 1 : 4 kg.
9 add the whole second object, or p[1] : 1.
total value: 10 + 1 >< 15 : 25, remaining: 4 — 2 : 2 kg.
9 cannot take the third object: 3 > 2, so the value remains 25.
0 greedy does not produce the optimal solution.
we will use another paradigm to solve this problem next lecture.
Greedy Algorithms AD 2022 21/1

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Interval Scheduling
A list of possible activities is given by the start and ﬁnish times of each
activity during the day. We want to choose as many non-overlapping
activities as possible to participate in.
Input: n, s[0...n-1], f[0...n-1] - natural numbers: start and finish times

of n activities, with s[i] < f[i], Vi G 0,n-1.

activity i starts at s[i], ends right before f[i], so it takes [5U], f[i])
Output: A Q {0, . . . , n-1} maximum cardinality set of activities

such that [s[i], f[i]) O [5U], fUD I Q), Vi #j G A
Greedy Algorithms AD 2022 22/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:23**************
Interval Scheduling
A list of possible activities is given by the start and ﬁnish times of each
activity during the day. We want to choose as many non-overlapping
activities as possible to participate in.
Input: n, s[O...n-1], f[O. . . n-l] - natural numbers: start and finish times

of n activities, with sli] < fli], Vi € O,n-1.

activity i starts at s[i], ends right before f[i], so it takes [sh], f[i])
Output: A Q {0,...,n-1} maximum cardinality set of activities

such that s[i] Z f[j] or s[j] Z f[i] Vi #j € A
Greedy Algorithms AD 2022 23/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Interval Scheduling - Example
Today, a student can participate in:
activity start end description
lecture 10 12 take the AD Lecture
code 09 17 participate in Google CodeCamp
theater 18 20 go to the theater
serial 21 22 watch a movie
club 19 24 go to the club
One optimal solution is:
Participate in 3 activities: lecture, theater, serial.
Greedy Algorithms AD 2022 24/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
Interval Scheduling - Example
Today, a student can participate in:
activity start end description
lecture 10 12 take the AD Lecture
code 09 17 participate in Google CodeCamp
theater 18 20 go to the theater
serial 21 22 watch a movie
club 19 24 go to the club
Another optimal solution is:
Participate in 3 activities: code, theater, serial.
Greedy Algorithms AD 2022 25/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Interval Scheduling - First Greedy Criteria
A first idea is to solve the problem with the greedy strategy of prioritizing
the shortest activities first. This works on the example: first decide to
watch the serial, because it takes only 1 hour, then the lecture and theater
both talking 2 hours. However, this strategy does not always lead to an
optimal solution.
Can you ﬁnd an example on which it fails?

Greedy Algorithms AD 2022 26/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:27**************
Interval Scheduling - First Greedy - Counterexample
Consider the following start and end times:
activity start end
one 09 16
two 15 18
three 17 23
The described strategy chooses activity two with the shortest duration of 3
hours. But activity two overlaps with both one and three and so we can't
choose any other. Solution {two} is not optimal because solution
{one, three} contains more activities and they don't overlap.
Greedy Algorithms AD 2022 27/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Interval Scheduling - Revised Greedy Criteria
A better idea would be to prioritize the activity with the earliest finish
time, out of all the remaining valid activities. This is always optimal, and
we can prove it.
0 we can use the exchange argument technique.
9 let e be the (index of) earliest ending activity (globally)
9 let OPT be an optimal solution (max cardinality, non-overlapping)
0 let eOpT be the (index of) earliest ending activity in OPT.
9 consider EXH I OPT\ {eOpT} U {e}.
Greedy Algorithms AD 2022 28/1

***************Ending Page***************


***************Beginning Page***************
***************page number:29**************
Interval Scheduling - Revised Greedy - Proof
9 we can prove EXH is also an optimal solution.
O |EXH| Z |0PT| - 1 + 1 z |0PT|
o Va G EXH \ {e} it holds that f[e0pT] g s[a] based on validity of OPT
o but f[e] g f[eOpT] as e is earliest ending globally
o so, Va G EXH \ {e} we have: f[e] g f[eOpT] g s[a] so no activity in
EXH overlaps with e.
o activities in EXH \ {e} are non-overlapping as part of OPT.
o :> no activities in EXH overlap.
o :> EXH is also an optimal solution.
0 To complete the proof, we also need to show that applying the greedy
criteria repeatedly leads to an optimal solution.
Q A subproblem of the initial problem instance is defined by any subset
of the activities in the original instance (or in input).
9 We will prove that {e} U any optimal solution for the subproblem of
all the activities starting after f[e] is optimal.
Greedy Algorithms AD 2022 29/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Interval Scheduling - Revised Greedy - Proof
® Let 5 be any nonempty sub-problem and e5 G S the earliest ending
activity in S which is chosen by the greedy algorithm, if ran on 5.
Q Let EXH5 be any optimal (sub)solution of S that contains e5 G S, we
proved above EXHS exists in Q.
Q Let RESTEXHS : EXH5 \ {e5} be the other activities in the optimal
(sub)so|ution.
Q RESTEXHS is an optimal solution for 5 \ {al a overlaps with e5}
o If there would be a better solution BTR for S \ {a|a overlaps with e5},
then BTR U {e5} would also be a better solution than EXH5 for 5
which contradicts EXH5 optimality.
Q By using further induction the algorithm's correctness is proven.
Greedy Algorithms AD 2022 30/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:31**************
subproblem S
%
es |—| |—|
—
— —
_ _
subproblem S\{a|a overlaps with es}
PM
l—l
l—l
-—- _-—- }lBTRl;é|RESTEXHSl
l—l l—l
cannot have a better solution
because any other optimal sub-
solution U{es} is optimal for S
cl 51 , E :2 0&0
Greedy Algorithms AD 2022 31/1

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Interval Scheduling - Implementation, Complexity
High-level description of the algorithm...
0 start with selected activities set SEL : (D;
9 out of all remaining activities, choose e: the one with earliest finish;
9 add e to SEL;
9 remove e and all other activities it overlaps with;
6 repeat the process While there are remaining activities.
cl 51 , E :2 Wwv
Greedy Algorithms AD 2022 32/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:33**************
'"te'va'Sched"""g
Interval Scheduling - Implementation
l /* Input : n natural number of activities
2 s[O..n-1], f[O..n-1] start and end times
3 Output: SEL = maximum cardinality set of
4 non-overlapping activities*/
5 sortActivities(); //ascending by finish time
6 SEL = emptySet; //Selected activities
7 finish = O; //latest finish time
8 //can start another from this time
9 for (i = O; i < n; i++) {
10 if (s[i] >= finish) {//available for activity i
11 SEL = SEL U {i}; //include activity i
12 finish = f[i]; //mark busy until it ends
13 }
14 }
m a e E s oqo
Greedy Algorithms AD 2022 33/1

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
'"te'va'Schedu'i"g

Interval Scheduling - Implementation, Complexity

l /* Input : n natural number of activities

2 s[O..n-1], f[O..n-1] start and end times

3 Output: SEL = maximum cardinality set of

4 non-overlapping activities*/

5 sortActivities(); // 0(N log N)

6 SEL = emptySet;

7 finish = O;

8

9 for (i = 0; i < n; i++) { // 0(N)

10 if (s[i] >= finish) {

11 SEL = SEL U {i}; // 0(1) or 0(logN)

12 finish = f[i];

13 }

14 } // Overall complexity: 0(NlogN).

cl a] e E :5 oqo

Greedy Algorithms AD 2022 34/1

***************Ending Page***************


***************Beginning Page***************
***************page number:35**************
What is a Spanning Tree?
Spanning Tree
If G : (V, E) is a connected graph, then T : (V, E’) is a spanning tree
of G if it is a subgraph of G which:
o is a tree (connected with no circuits)
o contains all the nodes of G
El r51 i E :5 ‘)QQ
Greedy Algorithms AD 2022 35/1

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
“Mm SW“ Tree
Spanning Tree - Example: Graph G
El r51 i E :5 V’) (KG
Greedy Algorithms AD 2022 36/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:37**************
“Mm SW“ Tree
One Spanning Tree Highlighted
El i5‘ i E :5 V’) (KG
Greedy Algorithms AD 2022 37/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
What is a Minimum (cost) Spanning Tree?
Minimum Spanning Tree or MST
If G : (V, E) is a connected graph, and c : E a 1R a cost function on its
edges, then T : (V7 E’) is a minimum spanning tree of G if it is a
spanning tree of minimum cost.

0 cost of a tree is sum of cost of edges: c( T) : Z C(e)

e€E(T)
0 let Tmin be a minimum spanning tree of G
othench- :min cT
< mm) m < )
o where 7'6 is the set of all spanning trees of G
Greedy Algorithms AD 2022 38/1

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
MST Example: G with costs on edges
For example, consider the graph below with costs on edges.
G G 4
2 3 Q
3
Q 4
6 1 g
w‘
G 5
1 G
El 5' i E :5 VA» ‘11ka
Greedy Algorithms AD 2022 39/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Minimum Spanning Tree
MST highlighted with cost of 24 I 2+3+6+1+5+3+4.
G G 4
2 3 Q
3
Q 4
6 1 g
1°‘
G 5
1 G
cl 51 i E :2 v?» ‘1x9
Greedy Algorithms AD 2022 40/1

***************Ending Page***************


***************Beginning Page***************
***************page number:41**************
MST Problem, formally.
For a graph G : (V, E) and a cost function on edges, find an MST of G.
Input: N : lVl, N G N: number of nodes: V : {1. .. N}; and edges
M I |El, E : {(e.x, e.y, e.cost) l (ex, e.y) € V2, e.cost € R}
E is an array of struct edges: endpoints .x7 .y and cost .cost
Output: T Q E a minimum spanning tree of G, with |T| : N i 1:
V(s, t) € V: El! sequence of nodes s : v17 v2, . . . vk_1, t : vk With:
VIQW: v,-€ Vand Vi€1,k-1 HeG Tsuch that
(VIN/1+1) I (exiey) 0r (VIN/+1) I (eyiex)
Z(e.cost) is the minimum of all the MSTs.
eET
Greedy Algorithms AD 2022 41/1

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
MST General Greedy Method
High-level description
0 start with an empty set of edges
9 add edges one by one such that:
o greedy criteria: smallest cost first
o validity: but such that no circuits are created
o stop when all nodes are connected, thus the edges form a tree
9 the set of edges dynamically connects nodes i
connected components, which in this case are trees
Greedy Algorithms AD 2022 42/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:43**************
Greedy Choice Proof
Greedy Choice Proof
If G : (V, E) is a connected graph with n nodes, then the final tree
constructed by the method above is an IVIST of G.
Let Ek be the first k edges added by the greedy strategy.
We can prove by induction on k that:
(*) there exists an MST of G, with edges TOPT such that TOPT Q Ek.
This will imply that for k : n — 1, we have TOPT I En_1, thus the
generated tree is one of the MSTs.
For k I O, there are no edges, and any MST contains the empty set of
edges, so (*) holds.

Greedy Algorithms AD 2022 43/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Proof continued
If (*) holds for k, then there is an MST:
TOPT With TOPT 2 Ek- I I I TOPT I I I
For Ek+1 : Ek U {emin} there are two cases:
0 if we have emin 6 TOPT then (*) holds.
9 else emin ¢ TOPT
and TOPT U {emin} has exactly one
circuit C which must contain another
edge f that is not in Ek+1 as Ek+1
has no cycles. Then, C(f) Z C(emfn)
by the greedy choice and
therefore TEXH I TOPT \ {f} U {em-n}
|s a tree of clost ‘at rnolst I I I Ek I I I
as TOPT which IS m|n|mum, therefore
TEXH is another IVIST, and (*) holds.
Greedy Algorithms AD 2022 44/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:45**************
Proof continued
If (*) holds for k, then there is an MST:
TOPT With TOPT 2 Ek- I I I TOPT I I I
For Ek+1 : Ek U {emin} there are two cases:
0 if we have emin 6 TOPT then (*) holds.
\
9 else emin ¢ TOPT
and TOPT U {6min} has exactly one
circuit C which must contain another
edge f that is not in Ek+1 as Ek+1 ‘
has no cycles. Then, C(f) Z C(emfn) v
by the greedy choice and L
therefore TEXH I TOPT \ {f} U {em-n}
|s a tree of clost ‘at rnolst I I I Ek+1 I I I
as TOPT which |s m|n|mum, therefore
TEXH is another IVIST, and (*) holds.
Greedy Algorithms AD 2022 45/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Proof continued
If (*) holds for k, then there is an MST:
TOPT With TOPT 2 Ek- I I I TOPT I I I
For Ek+1 : Ek U {emin} there are two cases:
0 if we have emin 6 TOPT then (*) holds.
\
9 else emin ¢ TOPT
and TOPT U {emin} has exactly one
circuit C which must contain another
edge f that is not in Ek+1 as Ek+1 ‘
has no cycles. Then, C(f) Z C(emfn) v
by the greedy choice and i
therefore TEXH I TOPT \ {f} U {em-n}
|s a tree of clost ‘at rnolst I I I Ek+1 I I I
as TOPT which IS m|n|mum, therefore
TEXH is another IVIST, and (*) holds.
Greedy Algorithms AD 2022 46/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:47**************
Proof continued
If (*) holds for k, then there is an MST:
TOPT With TOPT 2 Ek- I I I TOPT I I I
For Ek+1 : Ek U {emin} there are two cases:
0 if we have emin 6 TOPT then (*) holds.
\
9 else emin ¢ TOPT
and TOPT U {emin} has exactly one
circuit C which must contain another
edge f that is not in Ek+1 as Ek+1 ‘
has no cycles. Then, C(f) Z C(emfn) v
by the greedy choice and i
therefore TEXH I TOPT \ {f} U {em-n}
|s a tree of clost ‘at rnolst I I I Ek+1 I I I
as TOPT which IS m|n|mum, therefore
TEXH is another IVIST, and (*) holds.
Greedy Algorithms AD 2022 47/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Kruskal's Algorithm
0 the algorithm chooses the edge e of minimum cost, by whose addition
no circuits are created.
o the algorithm avoids circuits maintaining connected components
structure, by two operations:
o find(x) returns the connected component of node x
o union(x, y) connects the components of x and y are united
remark: two nodes x and y are connected ifF find(x) I find(y)
o disjoint set collections, also known as union-find data structure can be
used efficiently, i.e. near constant amortized time for both operations.
o the total time complexity is (9(lEl >< loglVl) because of the initial
sorting of the edges.
Greedy Algorithms AD 2022 48/1

***************Ending Page***************


***************Beginning Page***************
***************page number:49**************
Algorithm Kruskal
1: T <— 0; // initial tree is empty
2; edges[] <— E(G); // array with all the edges
3; sort(edges); // by increasing order of cost
4:
5: for e E edges d0
6; if (find(e.x) i find(e.y)) then
7: // different connected components
8: uni0n(e.x, e.y);
9: T.add(e);
10; // T is the MST
El r51 i E :5 QQQ
Greedy Algorithms AD 2022 49/1

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
Algorithm Union-Find
1: // x.parent is the parent of X
2: // r00t.parent = root for any root
3: function FIND(node x)
4; if (x. parent i x) then
5: x. parent <- find(x. parent)
6: return x. parent
7; else
8: return x
9; function UN10N(n0de X, node y)
10: x <— find(x);
11: y <— find(x);
12; if x i y then
13: y. parent <— x; // merge the connected components
III 5' i E :5 V’) Q (‘v
Greedy Algorithms AD 2022 50/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:51**************
Median Maximization - a less classical problem
Given two natural numbers n and s, ﬁnd the maximum possible median of
an array of n natural numbers, such that the sum of the n numbers is
equal to s. The median of an array of n numbers is the lglth element in
nondecreasing order, Where positions are numbered from 1.
Input: n € N, 5 € N
Output: m - maximum natural number such that:

El v[l], v[2] . . . v[n] with v[i] G N, V i G m and

n
Z(v[i]) : s, and
i:1
I7 i
vi iii] - m
Greedy Algorithms AD 2022 51/1

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
Median Maximization - Example
Input: n : 3,5 I 5
Output: 2
There are three elements. The median is on position lgl : l1.5l : 2.
One possible array is: v[1] : 1; v[2] I 2; v[3] : 2; 1 + 2 + 2 : 5 : s and:
if v[2] would be > 2 then v[2] Z 3 and in a nondecreasing arrangement of
v[] we must also have v[3] 2 v[2] Z 3 therefore v[3] 2 3 so
v[2] + v[3] Z 3 + 3 : 6 so clearly v[1] + v[2] + v[3] Z 6 since Vv[i] E N
and s : 5 so v[1] + v[2] —l— v[3] 75 s.
ln conclusion, 2 is the maximum median.

Greedy Algorithms AD 2022 52/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:53**************
Median Maximization - Solution
Hint l: What greedy strategy can we use for: v[l]7 v[2] . . . vi lg] — 1] ?
We want to leave as much of s as possible for positions starting at lgl,
there is no use to "consume" any of the sum s, and we can set all to O, it
is still non-decreasing and valid so why not?
Hint 2: How about for: vi lgl + 1] , vi lgl + 2] ...v[n] ?
—> must be Z v[lgl].

We only want to increase vi igl] but all values on the right must be Z
then the median. We can split s evenly between these elements. If there is
any reminder, we can add it only to v[n].

Greedy Algorithms AD 2022 53/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
Median Maximization - Example, Decisions
Input : n:7,$:19
Output: ?
i= 1,2,3,4,5,6,7
v= [:P, ?, ?, ?, ?, 1P, ?]
. I I 7 _
Medlan at p05|t|on [51 _ 4.
El 5' ' _= :E ‘)QG
Greedy Algorithms AD 2022 54/1

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
Median Maximization - Example, Decisions
Input: n : 7, s I 19
Output: ?
i= 1,2,3,4,5,6,7
V= [0, O, O, '?, '?, ‘.7, ?]
First, we can safely assign O to any position on the left.
\Il 5' i E :5 QQG
Greedy Algorithms AD 2022 55/1

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
Median Maximization - Example, Decisions
Input: n : 7, s I 19
Output: ?
i= 1,2,3,4,5,6,7
V = [0: O’ O: m,2m,2m,2m]
If we assign value m to v[4], all on the right must be Z m.
El i5‘ i E :5 QQG
Greedy Algorithms AD 2022 56/1

***************Ending Page***************


***************Beginning Page***************
***************page number:57**************
Median Maximization - Example, Decisions
Input: n : 7, s : 19
Output: ?
i= 1,2,3,4,5,6,7
v = [0, O, O, m,=m,=m,2m]
We prioritize on m, so the rest will be the same, eventually except for v[n].
El r51 i E :5 QQG
Greedy Algorithms AD 2022 57/1

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
Median Maximization - Example, Decisions
Input: n I 7,5 = 19
Output: ?
i= 1,2,3,4,5,6,7
v = [0, O, O, m,=m,=m,2m]
m can be l%l = 4. Generally, it can be lﬁl.
5 ‘l’
El r51 i E :5 QQQ
Greedy Algorithms AD 2022 58/1

***************Ending Page***************


***************Beginning Page***************
***************page number:59**************
Median Maximization - Example, Decisions
Input: n : 7, s I 19
Output: ?
i= 1,2,3,4,5,6,7
v = [0, O, O, m, m, m, m]
Add the remainder 19%4=3 only to the last number, no restrictions appear.
El 5' i E :5 QQG
Greedy Algorithms AD 2022 59/1

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
Median Maximization - Example, Decisions
Input: n : 7, s I 19
Output: 4
i= 1,2,3,4,5,6,7
V= [0, O, O, 4, 4, 4, 7]
An optimal solution. 4 + 4+4+ 7 : 19.
El i5‘ ' _= :E ‘)QG
Greedy Algorithms AD 2022 60/1

***************Ending Page***************


***************Beginning Page***************
***************page number:61**************
Median Maximization - Implementation

1 /*Input :n and s, natural numbers

2 Outputzm maximum value such that there is an array

3 of natural numbers of sum s and median m */

4 rightSize = n / 2 + 1;

5 print(s / rightSize);

6 // Complexity: 0(1).

cl 51 — -= :5 one

Greedy Algorithms AD 2022 61/1

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Median Maximization - Proof
0 There is a valid array with the median value of s/(n/2 + 1).
lt is always possible to build such an array:
0 assign 0 to first n — (n/2 —l- 1) elements.
9 assign s/(n/2 + l) to next (n/2) elements.
9 assign s/(n/2 -l— 1) + 5%(n/2 -l— 1) to the last element.
Proof of validity:
0 the elements are natural numbers in non-decreasing order.
9 median at position (n/2) has value s/(n/2 + 1).
9 sum of elements is:
O >< (n — (n/2 + 1)) + s/(n/2 + 1) >< (n/2) + s/(n/2 + 1) + 5%(n/2 + 1)
I s/(n/2 + 1) >< (n/2 + 1) + 5%(n/2 + 1) I s.

9 Proof of optimality: suppose there El array of median > s/(n/2 + 1).
i the median is Z s/(n/2 + 1) + 1. The (n/2) values on its right are
at least as big, so the sum of elements Z median is
2 (s/(n/2+1)+1) ><(n/2—l—l) I 5/(n/2+1)><(n/2—l—1)—l—(n/2+1) > 5
because the reminder 5%(n/2 + 1) < (n/2 + 1).

Greedy Algorithms AD 2022 62/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:63**************
Greedy - Conclusion
A greedy algorithm makes a locally optimal choice at each stage based on
a criterion.
Depending on the problem and the criterion, greedy may produce the
optimal result or not. In some cases, it is hard to ﬁnd an example in which
the studied greedy strategy produces a suboptimal solution.
Proving a greedy strategy is optimal can be even harder.
In practice, sub-optimal solutions can be useful, such greedy solutions are
called heuristics. Heuristics do not respect the definition of a problem
solved by an algorithm.
Sub-optimal greedy solutions can provide some approximation ratio
guarantees: how far from the optimal result their response is at most.

Greedy Algorithms AD 2022 63/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
Extra Problem - Boats
A group of n people goes rowing. There are enough
available identical boats that can take one or two persons.
Each person's weight is known W,- with i € ﬁ-
A|| boats have the following restrictions:
Q can only handle W total weight.
9 if two people get on a boat:
the absolute difference of their weights
must be at most B, to keep the boat balanced.
What is the minimum number of boats to take all people?
cl 51 t E :2 oqcv
Greedy Algorithms AD 2022 64/1

***************Ending Page***************


***************Beginning Page***************
***************page number:65**************
Boats - Example
For example, a group of six persons with weights 37,817 55,72,45, 32 goes
rowing. All boats can load at most a total weight of 100 and if two people
go on the same boat their weights should not differ by more than 10.
What is the minimum number of boats?
El i5] i E :5 ‘JQCV
Greedy Algorithms AD 2022 65/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Boats - Example

For example, a group of six persons with weights 37, 81, 55,72, 45, 32 goes

rowing. All boats can load at most a total weight of 100 and if two people

go on the same boat their weights should not differ by more than 10.

Possible with 4 boats: {37,32}, {55,45}, {81}, {72}.

(37 -l— 32 : 69) g 100 (55 + 45 : 100) g 100 81 g 100 72 5 100

(l37 — 32l I 5) g 10 (|55 — 45l I 10) g 10, all restrictions satisﬁed J
Greedy Algorithms AD 2022 66/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:67**************
Boats - Formal Deﬁnition
Input: n G N the group size;
W, B G N boats capacity and maximum unbalance.
W[i] g B G N, Vi G m the individual weights.
Output: boats G N - minimum number such that:
El 51,52 . . . Sboats with S,- G 79({1. . . n}) 73(5) : subsets of S
51U52U---U5boats:{l...n} all people aboard
I5,-l g 2 Vi G 1, boats at most two in each boat
(max p — min p) g B Vi G l, boats all boats balanced
P€5i P€5i
Z p g W Vi G 1, boats all boats within the capacity
P€5i
cl 51 t E :2 oqo
Greedy Algorithms AD 2022 67/1

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Boats - Strategy
Many possible strategies as we have more restrictions. Start with pairs
such as to leave as little unused capacity as possible, balance pairs as
well-balanced as possible, start with lightest/heaviest people...
Some certainties:
Person of weight W[i] > W-vLj] Vj G (ﬁ\ {i}) goes in a separate boat.
Similarly if (W[i] < W[j] — B and W[i] —l— B < W[i]) Vj 6 (ﬁ\ {i}).
An optimal strategy for the rest ? or ideally, for everybody.

Greedy Algorithms AD 2022 68/1

***************Ending Page***************


***************Beginning Page***************
***************page number:69**************
Boats - Sort Descending by Weight

Think of the person of maximum weight i. If it can be paired with some

other person, which one to choose as its pair?

The one with the maximum weight as well out of all possible valid pairs is

good if boat capacity would be the only restriction. Say this pair is j.

How about boat balance?

The same choice is also good from the perspective of boat balance

because a person with weight < WU] can also pair with potential other

persons of smaller weight: lighter with lighter, heavier with heavier.

If we sort the array decreasingly, we can design an efficient algorithm...
Greedy Algorithms AD 2022 69/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
Boats - Sorted Decreasingly
W1Zw22w32w42w5Zw62w72w82w92 an
Decide to pair or board alone, for elements wi in decreasing order.
El 5' i E :5 QQG
Greedy Algorithms AD 2022 70/1

***************Ending Page***************


***************Beginning Page***************
***************page number:71**************
Boats - Sorted Decreasingly - Boarding wi
W1Zw22w32w42w5Zw62w72w82w92...an
Z Wi Z Z W11
Suppose we reach element wi and all heavier on the left of wi are boarded.
El r51 i E :5 QQG
Greedy Algorithms AD 2022 71/1

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
Boats - Pair wi with some wj
W1ZWQZWSZWLZWS2W62w72w82w92...an
Z Wi Z Z W11
Z wi 2 Z Wj 2 Z wn
Think of pairs of wi as wj with i>j. What restrictions must wj meet?
El r51 i E :5 ‘)QG
Greedy Algorithms AD 2022 72/1

***************Ending Page***************


***************Beginning Page***************
***************page number:73**************
Boats - Pair wj Upper Bound
W1ZWQZWSZWLZWS2W62w72w82w92...an
z wi 2 z wn
Z wi 2 Z WJ' 2 Z wn
z wi 2 —
wi + wj g W => a valid pair wj must have W—wi Z wj.
El r51 i E :5 QQG
Greedy Algorithms AD 2022 73/1

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
Boats - Pair wj Lower Bound
W1Zw22w32w42w5Zw62w72w82w92...an
Z wi Z Z wn
Z wi 2 Z wj Z Z wn
[wi - wj‘ g B and wi Z wj :> a valid pair wj must have wj Z wi —B.
El 5' i E :5 QQG
Greedy Algorithms AD 2022 74/1

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
Boats - Valid wj Interval
W1ZWQZWSZWLZWS2W62w72w82w92...an
Z wi Z Z wn
Z wi 2 Z Wj 2 Z wn
z wi 2 —
All valid pairs wj should meet both criteria, so intersect the two intervals.
El r51 i E :5 ‘)QQ
Greedy Algorithms AD 2022 75/1

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
Boats - Maybe None
W1Zw22w32w42w5Zw62w72w82w92...an
Z wi 2 Z wn
Z wi 2 Z WJ' 2 Z wn
If the interval is empty, wi boards alone. There is no chance to do better.
El r51 i E :5 QQG
Greedy Algorithms AD 2022 76/1

***************Ending Page***************


***************Beginning Page***************
***************page number:77**************
Boats - Maybe Multiple wj - Which One?
W1Zw22w32w42w52W62w72w82w92...an
Z wi Z Z wn
Z wi 2 Z WJ' 2 Z wn
Else, choose to pair with the biggest (leftmost) wj in this interval... why?
cl 51 , E :2 QQG
Greedy Algorithms AD 2022 77/ 1

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
Boats - Next wi
W1ZWQZWSZWLZWS2W62w72w82w92...an
Z wi Z Z W11
2 wi 2 Z Wj 2 Z wn
Think of next wi, how do the interval ends change for potential pair wj?
cl 51 t E :2 QQO
Greedy Algorithms AD 2022 78/1

***************Ending Page***************


***************Beginning Page***************
***************page number:79**************
Boats - Next wi - New Pair wj Upper Bound
W1ZWQZWSZWLZWS2W62w72w82w92...an
2 wi z z wn
2 wi 2 Z Wj 2 Z wn
2 wi z —
wi decreased :> upper bound of W—wi 2 wj increased.
El 5' i E :5 QQG
Greedy Algorithms AD 2022 79/1

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
Boats - Next wi - New Pair wj Lower Bound
W1ZWQZWSZWLZWS2W62w72w82w92...an
2 wi z z wn
2 wi 2 Z Wj 2 Z wn
2 wi z— z z
wi decreased :> lower bound of wj 2 wi—B decreased.
El 5' i E :5 QQG
Greedy Algorithms AD 2022 80/1

***************Ending Page***************


***************Beginning Page***************
***************page number:81**************
Boats - Next wi - Intersection
W1Zw22w32w42w52W62w72w82w92...an
Z wi Z Z wn
2 wi 2 Z WJ 2 Z wn
Interval got wider at both ends. New wi can match more elements.
El r51 i E :5 0Q‘?
Greedy Algorithms AD 2022 81/1

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
Boats - Next wi - Intersection
W1Zw22w32w42w52W62w72w82w92...an
Z wi Z Z wn
2 wi 2 Z WJ 2 Z wn
Also, we already boarded all values bigger than wi.
cl 51 2 E :2 one
Greedy Algorithms AD 2022 82/1

***************Ending Page***************


***************Beginning Page***************
***************page number:83**************
Boats - Complexity
Even if we sort decreasingly and iterate from 1 to n for each wi, it is not
trivial to ﬁnd and delete the heaviest matching pair wj efficiently.
lterating over all left candidatesj again would result in (9(n2) complexity,
if a paired[] characteristic array is used - otherwise, even more
There is an efficient solution in (9(n) after sorting using double linked lists.
lt is also possible to keep all weights ordered decreasingly in a multi-set or
map, that can be implemented with a balanced binary search tree. To get
the biggest value lower than a given threshold, use methods like
upperBound(bound) that run in (9(log n), and delete(p) also in 0(log n).
Overall complexity (9(n log n).

Greedy Algorithms AD 2022 83/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:84**************
Algorithm Boats
1: // Input: n, W, B, W[l...n]
2: // Output: boats - the minimum number of boats
3: weights <— Q); // multi-set, ordered decreasingly
4: boats I 0; // number of boats used
5zf0ri=1t0nd0
6: weights.insert(w[i]);
7: Wi I weights.ﬁrst();
8: while (Wi I NULL) d0 // in decreasing order all heavier already boarded
9: Wj I weights.upperBound(W - Wi + 1); // largest value S W-Wi
10: if (Wi II Wj) then // can happen if wi 5 W/2
11: Wj I Wj.next(); // Wj cannot be Wi
12; if ((wj ¢ NULL) and (wi-wj g B)) then
13: weights.erase(wj); // board together
14: preWi I Wi;
15: Wi I wi.next();
16: weights.erase(prewi); // delete the Wi at the beginning of the loop
17: boats++;
cl a] , I :5 o q o
Greedy Algorithms AD 2022 84/ 1

***************Ending Page***************


***************Beginning Page***************
***************page number:85**************
Bibliography

Bibliography (links)

[ro] Lecture papers document.

Greedy Chapter of Jeff Erickson's book.

Try some CodeForces greedy problems.

Acknowledgment

Lecture professors of previous years, prof. D. Lucanu, conf. S. Ciobaca.

Contributors to the online resources available.

cl 51 r E :2 oqcv

Greedy Algorithms AD 2022 85/1

***************Ending Page***************


***************Beginning Page***************
***************page number:86**************
E1 ﬁ ' _= IE l) ‘k O
D. Lucanu, S. Ciobécé, P. Diac (FlliUAlC) Greedy Algorithms AD 2022

***************Ending Page***************

