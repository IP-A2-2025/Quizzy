[{content={parts=[{text=--FlashCardSeparator--
Single
--InteriorSeparator--
What is the total number of nodes in the exhaustive search tree for a formula with 4 variables?
--InteriorSeparator--
15
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What algorithmic paradigm can be used to solve the discrete knapsack problem by eliminating partial solutions that are unlikely to produce a better result?
--InteriorSeparator--
Branch & Bound
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
Name one problem for which you need to design a backtracking algorithm as mentioned in the provided text.
--InteriorSeparator--
Subset Sum Problem
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
In the backtracking algorithm design for the "subset sum" problem, which of the following needs to be specified?
--InteriorSeparator--
(right) How a solution is represented
(right) When a partial solution is viable
(wrong) The programming language used
(wrong) The current time complexity
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What problem is mentioned that involves designing a branch & bound algorithm?
--InteriorSeparator--
15-Puzzle
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is meant by 'designing' a backtracking algorithm in the context of the document?
--InteriorSeparator--
Specifying the representation of a solution, partial solutions, successors, and viability conditions.
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What are some key elements to specify when designing a branch & bound algorithm for the 15-puzzle problem?
--InteriorSeparator--
(right) Definition of a partial solution
(right) How to calculate the cost of a partial solution
(wrong) The current date
(wrong) The inventor of the puzzle
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
Besides the 15-puzzle, name another problem for which you need to design a branch & bound algorithm.
--InteriorSeparator--
Maximum Independent Set
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
For the discrete knapsack problem, what is one way to evaluate objects for which a partial solution has not yet made a decision?
--InteriorSeparator--
Calculate the sum of their values, ignoring weights.
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What can partial solutions be reduced to in the knapsack problem when using branch & bound?
--InteriorSeparator--
(right) Those where the sum of remaining values plus profit doesn't exceed the current maximum profit
(wrong) Those that include all objects
(right) Solutions where using greedy approach yields lower result
(wrong) Those that exclude all objects
--InteriorSeparator--
hard
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
For the knapsack problem, how can a more efficient evaluation be achieved for remaining objects?
--InteriorSeparator--
By running the greedy strategy as if solving the continuous knapsack problem.
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What needs to be demonstrated about the more efficient knapsack evaluation method to prove its correctness?
--InteriorSeparator--
That it does not eliminate partial solutions that could lead to a better result.
--InteriorSeparator--
hard
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
Regarding the greedy strategy for the knapsack problem, what needs to be shown to prove it's more efficient?
--InteriorSeparator--
(right) It eliminates at least one more partial solution than the first variant for some instances
(wrong) It has a lower time complexity.
(right) That it eliminates at least the same number of solutions as the first variant on any instance
(wrong) That it always finds the optimal solution faster.
--InteriorSeparator--
hard
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
How can the cost of a partial solution be calculated in a branch & bound algorithm for the 15-puzzle?
--InteriorSeparator--
The document doesn't specify how, but it requires defining how to calculate this cost.
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is meant by "bounding inferior cost" in the context of branch & bound for the 15-puzzle?
--InteriorSeparator--
It refers to finding a lower bound on the cost of extending a partial solution to a complete solution.
--InteriorSeparator--
hard
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What are 'direct successors' in the context of designing backtracking and branch & bound algorithms?
--InteriorSeparator--
They are the new partial solutions obtained by making one more decision from a given partial solution.
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
For the Maximum Independent Set problem, what type of algorithm should be designed according to the text?
--InteriorSeparator--
Branch & Bound
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What needs to be implemented when tackling the discrete knapsack problem using branch & bound with the improved evaluation function?
--InteriorSeparator--
(right) The algorithm itself
(wrong) A visual representation of the problem
(wrong) A user manual
(right) The greedy strategy for the remaining objects
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What kind of search does backtracking perform?
--InteriorSeparator--
Exhaustive Search
--InteriorSeparator--
easy
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What kind of condition needs to be specified for a backtracking algorithm?
--InteriorSeparator--
(right) viability condition for a partial solution
(wrong) the color of the background
(wrong) the type of the processor
(right) how to determine when a partial solution is not good
--InteriorSeparator--
medium
--InteriorSeparator--
1
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
In the context of branch and bound, what is the purpose of eliminating partial solutions?
--InteriorSeparator--
To improve efficiency by avoiding exploration of branches that are unlikely to lead to optimal solutions.
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What kind of method would be most efficient for estimating the value of unselected items in the knapsack problem?
--InteriorSeparator--
(right) A greedy method that treats all items as divisible
(wrong) a random number
(right)A value ignoring the weights
(wrong) a method that ignores all items
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
For the branch and bound 15-puzzle problem what properties need to be defined?
--InteriorSeparator--
(right) how to calculate the cost of a partial solution
(wrong) the ideal color of the puzzle
(right) the direct successors of a partial solution
(wrong) the manufacturing process
--InteriorSeparator--
medium
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
How can a Backtracking procedure improve effeciency when solving a problem?
--InteriorSeparator--
(right) eliminate partial solutions that can't lead to a solution
(wrong) printing messages
(right) reducing number of nodes to explore
(wrong) random number generation
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the ultimate goal when applying branch and bound or backtracking techniques?
--InteriorSeparator--
Finding an optimal or satisfactory solution while minimizing computational effort.
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
How does one improve efficiency in branch and bound?
--InteriorSeparator--
(right) eliminating unpromising branches
(right) prioritizing exploration of more promising branches
(wrong) using less memory
(wrong) by making code more readable
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What do backtracking and branch & bound have in common?
--InteriorSeparator--
(right) They both explore a search space.
(wrong) They both use dynamic programming.
(right) They both use partial solutions
(wrong) They both guarantee an optimal solution in polynomial time.
--InteriorSeparator--
medium
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
When designing a backtracking algorithm for a specific problem, what must one define in terms of solutions?
--InteriorSeparator--
How to represent a solution, what constitutes a partial solution, and when a partial solution is viable.
--InteriorSeparator--
medium
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
In designing a branch & bound algorithm, what aspects of 'cost' are essential to define?
--InteriorSeparator--
(right) How to calculate the cost of a partial solution.
(wrong) The monetary cost of running the algorithm.
(right) How to bound the cost of extending a partial solution.
(wrong) The cost of software licenses needed.
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
Why is the greedy strategy for the continuous knapsack problem useful as an evaluation function in the branch & bound approach for the discrete knapsack problem?
--InteriorSeparator--
Because it provides an optimistic estimate of the potential profit from the remaining objects, which can be used to prune unpromising branches.
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
What is the significance of proving that the more efficient knapsack evaluation method eliminates at least the same number of partial solutions as the first variant?
--InteriorSeparator--
It ensures that the improved method is never worse than the original method in terms of pruning the search space.
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
What is the main difference between backtracking and branch & bound?
--InteriorSeparator--
(right) Branch & bound uses bounding functions to prune the search space, while backtracking typically does not.
(wrong) Backtracking always finds the optimal solution.
(wrong) Branch & bound is only applicable to optimization problems.
(right) The bounding function helps to reduce the amount of nodes to explore
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Multiple
--InteriorSeparator--
When designing a branch & bound algorithm, what information does the cost of a partial solution provide?
--InteriorSeparator--
(right) A basis for comparing different partial solutions
(wrong) The exact solution to the problem
(right) An estimate of the quality of the solution that can be reached from this partial solution
(wrong) The current system uptime
--InteriorSeparator--
hard
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
Why is it important to define "direct successors" when designing backtracking or branch & bound algorithms?
--InteriorSeparator--
Because they define how the search space is explored and how partial solutions are extended.
--InteriorSeparator--
medium
--FlashCardSeparator--

--FlashCardSeparator--
Single
--InteriorSeparator--
How does the number of nodes increase in the exhaustive search tree?
--InteriorSeparator--
Exponentially
--InteriorSeparator--
medium
--FlashCardSeparator--
}], role=model}, finishReason=STOP, avgLogprobs=-0.33671748482131014}]