***************Beginning Page***************
***************page number:1**************
Limbaje formale, automate 5i
compilatoare

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
/i\
Recapltulare - Generare de cod
ll\lcr||\cdmm do mw] mlurmulmm dc mm .
HIHJCUE _ [mm
malt w -
Compilaloarele pot folosi multiple straturi dc
reprezentﬁri intermediate‘
Q /

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
K’ ‘\\
Recapltulare - Cod 1nterrned1ar
i Arbori sintaclici decoragi
. Cod cu trei adrese
~ X = y 0p z
° Cod intermediar
0 De nivel inalt
apropiagi de limbaju] sursé (arbori sintacxici)
Pmrivigi pemru sarcini de nive] imh (ex. veriﬁcare de lip)
~ De nivel jas
alocarea da memorie 5i regi$tri
selecgia de instrucgiuni

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Cod intermediar de nivel jos
i Compilatorul trebuie 55 implementeteze conceptele
abstracte deﬁnite de limbaj pentru magina ginté
~ Nume
' Domenii de vizibilitate
~ Asocieri
' Tipuri de date
0 Operatori
0 Instrucgiuni de control
I Proceduri/ funcgii
I Parametri

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Medlul de rulare
i Compilatorul creeazz'i §i folose§te un mediu de rulare
pentru programele in execugie, care are in vedere:
Gesliunea dispoziyiei 5i alocz'lrii de memorie penlru elememele
programului
Mecanisrnele de acces la variablle
Legéturile dinlre funcyii
Modul de lransmilere de parametri
Interfaya cu sislemul de operate
Inpul/ Output
Ahe programe
g ,

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Gestlunea memonel
i Un program ruleazé in propriul spagiu logic de
memon'e
. Referinyele citre componemele programului sunt in
raport cu spagiul logic folosit
- Controlul spagiului ﬁzic de memm'ie:
Magina ginté
Sistemul de operate
Compilator

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Gestlunea memonel
i Memoria este accesati in octegi
I U11 cuvént are 4 octeLi
- Tipurile dc date mai mari primesc numirul necesar de
octegi
Sun! referite prin adresa primului octet
0 Alocarea de memorie depinde de oonstréngerile
sistemului
Aliniere i ﬁecare secvenyﬁ de memorie alocalé lrebuie $5 ﬁe
multiplu de 4
- Padding i octegi suplimenlari Ia ﬁnalul secvengei de memorie
Packing i dmele nu sum smczne in secvenge de lungime muhiplu
de 4

***************Ending Page***************


***************Beginning Page***************
***************page number:8**************
y/Ki‘\
Gestlunea memonel

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Gestiunea memoriei
' Dimensiunea codului este ﬁxi, calculaté la compilare
I Codul este stocat 1a adresele de memorie mici
. Memon'a statici
0 Variabile statice globale
~ Constante
' informagii generate de compilator (ex, pentru curégarea
memoriei) etc,
0 La compilare sunt inlocuite in cod cu adresa

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
,/ Ki‘ \\
Heap $1 Stlva
i Memoria heap §i stiva incep de la marginile opuse ale
spagiului rimas
~ Memoria heap este alocaté crescﬁtor
0 Stiva este alocaté descrescitor

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Alocare staticé vs. dinamicé
i Alocare staticé i la momentul compilirii
I depinde doar de textul programului
- Cod $i memoria staticé
- Alocare dinamicé i la rulare
~ Depinde dc starea curenté a rulérii
' Stivé i pentru gestiunea apelurilor de funcgii
0 Heap i pentru date care pot exista 5i dupi incheierea
apelului care le-a creat

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
K’ ‘\\
Stlva
i Memoreazé
I Date dc activate
Generate 11 apeluri de {mm
Starea curenté a programului inzmiea apelului
~ Date care nu persisté dupé incheierea apelului

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
K’ ‘\\

Gestlunea stlvel
i La ﬁecare apel de funcyie

I Variabilele locale sun! puse in stivé

I La incheiere sum scoase din stivé

~ Permits folosirea aceluiagi spagiu pentru apeluri

neconcurente
Adresele relative penlru variabilele nelocale sum acelea$i

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Arbori de activare

i Apelurile de funcgii sunt imbricate in timp
I Gestiunea stivei nu este posibilé altfel

. O singurz'l funcgie deﬁne controlul execugiei la un
moment dal

' Exemplu: quicksort

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
‘ 1m arrav h ‘ 1m V: .nlru 1m nu mt n ‘
z." pivot z arrnyhﬂ, a Z (m 3,, M,
Mu | m we
m {m 1 r m. 1 - n, 1“; k
mt i, 14' (array 1' w pivot) I
w, m , (‘Aar'rav 1 -,, aux r array 1 ,
v array i V arr-iv i .
mm“- : M,
)
mm ‘Wyn m n. m m
HEW m“, 6",, Z WM. . 1.
" arra1‘1*arrarn‘
1va mm r w w,‘ in, M‘ max,“ in ‘[ 1
much" :(m 01%;‘th '
FINA“ 'KPWM“- I"): ‘aw-n Li ‘ Jr.
m
PeadL\\:‘{lLl‘
rim-H \.

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
‘ emu mun ‘
enter r-eadm ran'htl
A1b0r1 de actlvare >
Pentru§1ru12 5 l O 8 7 9 6 4 3, mh-r 1..“ Wm, 1
secvenga de actlvare at putea ﬁ 1me :artitmn('\, 1,
193w quitlsartl'h I‘!
10mm partithU. 7i

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Arbon de actlvare
' Apelurile de funcgii pot ﬁ reprezentale arborescent
I Parcurgerea in preordine —> secvenga dc apeluri
I Parcurgerea in poslordine —> secvema dc return
~ F ie 0 funcgie F, care degine controlul execugiei gi care
corespunde nodului N din arborele de activate. Atunci
apelun'le active sun! cele care corespund nodului N 3i
antecedentilor séi;
urdinea d: apel este reprezsmatz'i de drumul d: la rédécim'a la
nodul N;
nrdinea de return es\e drumul invers

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Arbori de activare
/ main \
rain/ 11019) \
p(0;9)/ q((:,2) \ / 11019) \
P(0!2) flak-IV q(l‘,l) \ M43) qUJZ/ ‘1(39) \
p(l,2)q(1,1) 11(33) P(6,9)q(6,‘7 q(t‘;,9) \
p(8,9) q(8,8) (100,9)

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
f ‘\
lnreglstran de actlvare
v Apelurile de funcgii sum gestionate de stiva de control
I Fiecare apel are 0 inregistrare pe stiva de control
Rédécina arborelui dc activare esie baza slivei
Secvenga d2 inregislrﬁri de aclivnre corespunde drumului de la
ridicina arborelui dc activare
Apelul cel mai recenl are inregislrarea in vérful slivei
I lnregistririle de activare pot cungine
Parametri
Valori de return
Legétura dc control
Legétura de acces
Siarea salvaté a sislemului
Dale locale
Date iempurare

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Gﬁstlunea stlvel
/ mam integers.“
1. incepulul programului '(10) "my"
2. reallAn'ay( 10) mm‘
II mam I’ \
r(10) q(0 9) integer m," l‘(10) ,x 11(03) quicksorl(0, 9)
’ quicksort(0_9) I + integzrpivol
inleger pivol p(0,9)/ q(0,2) Integer “In
g’ g quicksurlm, 2)
V ) ) '
1. reallAn'ay scos Aim-ma, P013) 0 1 ""‘prm
quicksorl(0,9)ml:odus ‘u F )
x. Conlrolul execulxei revine 1a
° quwksorqol)

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
Secvenga de apel

1. Apelantul evalueazé parametrii

2. Apelantul puns in vérful stivei adresa de return gi
adresa vﬁrfului vechi al stivei

3. Apelatul salveazi datele din regi§tri $i informatiile de
stare

4. Apelarul inigializeazi datele locale 5i incepe executia

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Secvenga de return

1. Apelarul pune valoarea de return léngi parametri

2. Apelatul decrementeazi virful stivei §i reface
regi§trii conform datelor de stare stocate pe stivé

3. Desi vﬁrful stivei este decrementat, apelantul
cunoaste pozigia relativi a valorii de return

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
Secventa de apel $1 return
i Secventele descrise anterior permit numér variabil de
paramelri de la apel la apel (ca pentru functia printf)
~ apelantul cunoa$te numérul 5i tipul de parametn' (deci
dimensiunea cémpului)
- Apelatul veriﬁci dimensiunea parametrilor 1a executie
Infon'natia care descrie parametrii trebuie a$ezaté léngé starea
salvatﬁ

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Secvenga de apel $1 return
I‘ arametri gi valoarea de return A
lnregismxrea de
Control link activare pentru
Link-mi gi slarea salvaui > _ apelam
Date temporare gi locale ResposablllaFea
apelamulw i
Paramctl'i 5i vuloarcu dc return .
Control link Imégﬁmea dc
_ _ _ V acuvare pemru
m ‘ Linkiun 51 starea salvala Rcspusabilia-m a p s1 at
Dale lemporare 5i locale apclawlw

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
Heap
' Spagiul de memorie uncle variabilele pot exista pe toaté
durala execugiei
~ Funcgiile pot declara date a ciror existenlé nu este legati
de activarea care le-a creat
I Gestionat de Memory Manager

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Memory Manager
' Gestioneazi spagiul disponibil in memoria heap, prin
alocare gi dealocare
~ Alocarea i un program soliciti memorie pentnl un obiect
Iivreazé c secvengé contigué de memorie
dacé nu existé spagiu, incearci s5 adauge memorie vinuali Ia heap
daci nu mai exislé spagiu, notiﬁcé progmmul
0 Dealocarea
memoria eliberaté este marcaté ca disponibilé pemru nui alociri
in general, dealocarea nu elibereazé memoria vinualé

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
y/Ki‘\
Gestiunea memoriei
i in mod ideal:
I Toate cererile de alacare solicit?! aceea§i cantitate de
memorie
~ Eliberarea memoriei este previzibilé (primul alocat este
primul dealocat)

***************Ending Page***************


***************Beginning Page***************
***************page number:28**************
Gestlunea memonel
i Atributele unui sistem de gesliune a memoriei
I Eﬁcienla folosirii spagiului
Minimizzrea memoriei heap necesare
Reducerez fragmemérii
~ Eﬁcienga programului
Fulosirea de subsistems de memorie
in general, programele acceseazé memoria nealeator, grupat
' Overhead scézut
Alocarea 5i dealocarea de memorie sun! frecvente
Coslul operagiilor trebuie 55 ﬁe cét mai mic
Q ,

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
Localitatea in pro grame
. Programele petrec mare pane din limp executind 0
purgiune mici de cod
~ Instrucgiuni care nu sum folosite deloc (ex. includerea de
biblioteci mari, deprecated code etc.)
I in mod cbignuit, doar o micé parte din cod esle executaté
(ex. cazuri limité, excepgii etc.)
0 in general programele executz'a bucle $i recursii de mici
dimensiuni
. lerarhia memoriei (nivele de caching) reduce timpul de
acces

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Reducerea fragmentérn
i Initial, memoria heap liberé este contigué
I Dupé alocéri $i dealociri repetate apar géuri
Spam de memorie libere inrre segmenle OCupatE
~ La ﬁecare noué solicitare, spagiul trebuie alocat intr-un
segment suﬁcient de mare
Dacia spaiiul liber gésil e mai mare deceit esle necesar, va ﬁ creatz'a
0 gaura 11131 mlca
0 La limité, memoria devine fragmentaté (multe spatii
libere prea mici pentru alocérile necesare)

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
K’ ‘\\
Reducerea fragmentanl
i F irsl-ﬁt
I Primul spagiu suﬁcient este folosit
I Eﬁcienlé redusé
- Best-ﬁt
~ Cauté cel mai mic spagiu suﬁcient dc mare pentru
solicitarea curentz'a
Binning
Mai multe bin-uri mici cresc eﬁcienya
I Next-ﬁt
~ A1005 spagiul in cel mai recent spagiu utilizat

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
,/ /i‘ \\

Reducerea fragmentérii
i Compunerea spagiului liber

I Uneori e mai eﬁcient ca segmentele libere adiacente 55

nu ﬁe unite

- Daci memoria heap este gestionati ca un intreg

I Boundary tags

~ Double linked, ebedded free list

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
y//i‘\
Bibliograﬁe
~ LA‘ V. Aho, M‘ S. Lam, R. Sethi, and J. D‘ Ullman,
Compilers.‘ Principles, Techniques, and Tuols, Second
Edition, Addison-Wesley, 2007

***************Ending Page***************

