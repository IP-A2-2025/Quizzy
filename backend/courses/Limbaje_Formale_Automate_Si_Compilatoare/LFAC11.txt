***************Beginning Page***************
***************page number:1**************
Limbaje formale, automate 5i
compilatoare

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
Unititi Arbors
Caractere . . ,
lexlcale slnlacllc
Cod Analllm Anahzor Anahzor
sursé mm Samamc semantic
Arbore
sintactic
decorat
GENEVBIOY
Cod ma iné de cad cm‘
§ intermediar
Asammare \nterpremre

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
,/ /i‘ \\
Recapitulare
i Analiza lexicalz'l
I Valideazé tokeni
. Analiza sintactici
0 Valideazé arborele sinlaclic
0 Analiza semanticé
0 Detecteazé mate celelalte erori
~ Ultimul pas de analizé

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Tipuri de date
i Veriﬁciri 5i lraduceri
I Veriﬁcarea are in vedere compatibilitatea dc tipuri
- Traducerea are in vedere spatiul necesar pentru
memorarea unei variabile
I Expresii pemru tipuri.

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Veriﬁcarea de tipuri de date
i Compilatorul asigneaza expresii de lip
I Compatibiliatea este calculatz'i pe baza sistemului dc
tipuri
~ Veriﬁcarea poate ﬁ fécuté:
dinamic, la runtime, sau
static. la compilare
' Un sistem este consistent dacé nu este necesaré
veriﬁcarea dinamicé de tipuri
I O implementare a unui limbaj este strongly typed dacé
accepte'l doa: programs care nu au erori de tipuri

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
,/ Ki‘ \\
Reguh pentru venﬁcarea tipunlor
i Sintezé de tipuri
I Tipul expresiei este construit din tipurile expresiilor
components
~ Identiﬁcatorii trebuie declaragi inaime de folosire
dacéfare lipul ng 5i a are tipul x
amnei expresia ﬂu) are lipul y
im ﬂﬂom a);
ﬂoat pi = 3'14;
in! rezulzaz : f(pi);

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
r/ K ‘ \\
Reguh pentru venﬁcarea tlpunlor
i Inferengé de tipuri
I Determiné tipul unei components dc limbaj pe baza
utilizérii acesteia
daciﬂa) este o expresie
numci exislé u, B =15. / are lipul “an 5i a are lipul u
pl : 3,14; //pl are tlpul ﬂoat
rezulm : ffpi); //f inmarce mt, decx rezulm are tipu] ml

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
y/Ki‘\
Reguli pentru veriﬁcarea tipurilor
i Veriﬁcarea de tipuri pentru instructiuni este similari cu
veriﬁcarea pentru expresii
~ if(C) S - apelul funcgiei ifpentm parametrii C, S
Tipul lui C esle boolean. Kipul lui S esle void
Tipul inmrs de r/v

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Conversia de tipuri
i Fie expresia a + i
I Ca expresia 55 ﬁe validé, tipul lui a trebuie 55 ﬁe
compatibil cu cel a1 lui i
Fie u dc tip/Inn! 5i ide tip inr
Mai e posibilé operagia?
- E necesar ca unul dintre operanzi sﬁ ﬁe convertit la
tipul celuilalt

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
y/Ki‘\
Conversia de tipuri
i Conversii de cregtere
I Conserve": informaﬁa
I Ex. char —> int
- Conversii dc ingustare
' Cu posibile pierderi dc informagie
' ﬂoat A int

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Conversia de tipuri - Exemplu
~ (Aho el aL, 2007)
. Reguli penlru cregterea tipun'lor sunt date in ﬁgura a)
~ Orice tip puate ﬁ crescut citre un tip care este mai sus in
arbor:
. Reguli penlru inguslarea tipurilor sunt dale in ﬁgura b)
0 U11 tip x poale ﬁ ingustat célre all tip t dacé existé un
drum in graf de la s la t

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
ri\
Conversia de tipuri de bazé in Java
double double
i +
ﬂoat ﬂoat
| +
long lung
1 +
int int
/ \ / § \
mm char char <-> show-t <—> byte
} \_/
byte
Q /

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
Generate de cod
i Transfonni analiza semanticé in cod executabil
. Limbajul trebuie lransformat diferit penlru orice sislem
~ Generate de cod intermediar i deta$eazé partea de
analizé §i interpretare de generarea de cod ma$in5

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
/i\
Generare de cod

Arbm qu-zqmm chrcninhur cm!

mlcrmcdmm dc mw] mlurmulmm dc mm .

HIHACUC _ [mm

malt w -
Compilatoarele pot folosi multiple straturi dc
reprezentﬁri intermediate‘

Q /

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Cod Intermedlar
i Arbori sintaclici decoragi
. Cod cu trei adrese
~ X = y 0p z
° Cod intermediar
0 De nivel inalt
apropiagi de limbaju] sursé (arbori simacxici)
Pmrivigi pemru sarcini de nive] inn]! (ex. veriﬁcare de tip)
0 De nivel jus
alocarea de memorie 5i regigtri
selecgia de instrucgiuni

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
K’ ‘\\
Grafun acmhce onentate
0 Gramatica de mai jos poate constwi arbori sintactici sau arbori
aciclici orientaﬁ
. Funcgiile Leaf§i Node vor crea noduri 110i dacé nu exist}: deja
noduri egale
- Daci nodul existé deja, va ﬁ returnat in locul unui nod nou
1) E -> E, + T E mule = new NML('+‘,E1vnnde,Txnmie)
2) E -» E, - T Emode = new NmU-Q E,md¢,T.mde)
a) E -* T Emode = 1mm
4) T -> ( E) T.nadn : Emmie
5) T -» id Tmorie = new lmf(id,id.ent1y)
5) T -+ num T.nude = new Lt'nflnum,nllm.vnl)

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Arbori sintactici abstracti
v Grafuri aciclice orientate
.a+a*(b-c)+(b-c)*d
/ + \
+ *
/ \ / \
* - d
a / \ / \
a / - \ b c
b c

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Arbori sintactici abstracti
v Grafuri aciclice orientate
.a+a*(b-c)+(b-c)*d
/ +
P \
a b/ \ d

***************Ending Page***************


***************Beginning Page***************
***************page number:19**************
/ \
Grafun ac1chce onentate
1) p1 : Leaf (id, emf/pa)
2) p2 = Lea/(id, entry“) : p‘
3) Pa = LEI/(id, WWII-b)
4) p4 I Leajﬂd, entry-c)
5) P5 = Node('—',m,P4)
6) m- = Nvd¢('*’,m,ps)
7) P1 = NMB('+'YF1,P6)
8) P3 : Luz/(id, entryAb) : p3
9) Pv = meﬁd‘ "mill-C) = P4
10) P10 = NMU-Hmm) = P5
11) p11 = Lea/(id, entryd)
12) P12 = Nﬂli¢('*/’P5,P11)
13) Pm = Nad¢('+',P1,mz)
Qi/

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
/ /i‘\
Grafuri aciclice orientate i reprezentare
tabelaré

I Nodurile arborelui sum reprezentate intr-un tablou
' F iecare rind reprezinté un nod
0 Prima celulﬁ reprezimé operatorul
0 Fiecare nod are 0 valoare asociaté (pointer sau constanté)
= 1 m entry
\ I‘: f0, i
1 m
+ 3-
/ \ 4
i 1o s »- >

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
/ Kie\
Grafuri aciclice orientate i reprezentare
cu tablouri
i Nodurile sunt referite prin indicele rindului
I lndicii nodului sau expresiei sunt numiti value number
I in practice‘ sum folositi pointeri
' Valorile numeric: pot ﬁ folosite pentru a construi grafuri
aciclice orientate

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Metoda value number de construcgie de
arbori orientayi
i Intrare: eticheta operatorului §i membrii operagiei
. legire: Valoarea numeﬂcé pentru nodul cu signatura
<0p, l, r>
I Algoritm
' Cautz'a in tablou nodul M cu eticheta op, §i ﬁii stﬁnga i
dreapta l 5i r
0 Dacé existé, return M
0 Altfel, creeazé un nou nod N, cu eticheta 0p 5i ﬁii 1 5i r;
return N

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
Coduri cu trei adrese
i Reprezentat ca 0 secvengi de maxim trei elemente
I Operator
- Operand stinga
~ Operand dreapta
0 Ex: a + b * c
ll I b * c
l2 I a + l1
. Poate ﬁ folosit pentru descompunerea de operagii
aritmetice, instruqiuni de control etc.
- Util pentru generare de cod $i optimizare

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Coduri cu trei adrese
I Este 0 descriere liniaré a unui arbore sintactic sau a unui
arbore orientat
0 Pentru graful discutat anterior, traducerea in cod cu trei
adrese este dati mai jos
/ + \ 11 = b - c
+ s= lz : a * t1
\* \/ ‘3 I a + t2
14 I t, * d
/ '\ 15 =13 +14
a b c '1

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
Adrese §i instrucpunl

i Codul cu trei adrese este construit pe baza a doui
concepte: adrese §i instrucgiuni

. O adresé poate ﬁ:
0 Nume (va ﬁ inlocuit cu 0 adresé de memorie la generare)
0 Constante (sunt necesare conversii de tip)
0 Variabile temperate generate de compilator (folosite in

general penlru optimizéri)

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Instrucgiuni pentru cod cu trei adrese

i Atribuiri de fonna c = a 0p b

. Atribuiri de forma a I 0p b

. Copiers: a I b

I Salt: goto L; insmlctiunea cu adresa L va ﬁ urmétoarea
executaté

0 Salruri conditionale: if a goto L sau if/lese a goto L

. Salturi condigionale: if a relap b goto L; daci a este in
relagia relop cu b, execute? instructiunea L, dacé nu
executi urmétoarea adresé dupe‘: instrucﬁunea curenté

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
y/Ki‘\
Instrucgiuni pentru cod cu trei adrese
i Apeluri de funcgii:
I param x1
I param x2
0 param xn
0 call p, n
. Copiers indexatﬁ: a I b[i] sau a[i] I b
0 a I b[z] modiﬁcé valoarea adresei care vine la i pozitii
dupa adresa lui b
0 Asignare de adrese sau pointeri: aI&b, aI*b, *aIb

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Exemplu
I Fie instruciiunea
- doi:i+ l;while(a[i]<v);
L: t1=i+1 100: t1=i+1
i = t1 101: i = t1
c2=i*8 102zt2=i*8
t3=a[t21 103: t3=a[t2]
if t3 < v goto L 104: if 1:3 < v goto 100

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
y//i‘\
Bibliograﬁe
~ LA‘ V. Aho, M‘ S. Lam, R. Sethi, and J. D‘ Ullman,
Compilers.‘ Principles, Techniques, and Tuols, Second
Edition, Addison-Wesley, 2007

***************Ending Page***************

