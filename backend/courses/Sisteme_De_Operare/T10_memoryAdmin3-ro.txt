***************Beginning Page***************
***************page number:1**************
Sisteme de Operate
Administrarea memoriei
partea a III-a
Cristian Vidrascu
htTps://profs‘infouaicxo/Nvidrascu

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
Cuprins
' Memoria Virtuali (continuare)
i Paginarea 1a cerere
i MMU
i Algorilmi de inlocuire a paginilor
i Fenomenul de trashing
i Segmentarea 1a cerere
' Concluzii legate de tehnicile de administrate a
memoriei
' Tehnici recente pentru administrarea memoriei
" Administrarea memoriei in Linux gi Windows
I (H

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
Paginarea 1a cerere /1
> Paginarea (cu inciircare) la cerere

: paginarea combinaté cu tehnica de swapping

i ldeea: aducerea paginilor dc pe disc in memorie doar
in momentul cénd sunt referite (“cénd e nevoie de ele”)

i Astfel se eliminé restricgia ca programul sé ﬁe prezent
in intregime in memorie pentm a putea ﬁ executat

i Motive de eliminare a acestei restrictii:

' programele congin zone dc cod ce trateazé cazuri mutual—exclusive
(in funcgie de datele de inlrare), sau zone care se executé la
moments de limp mutual-exclusive

' unele programe congin zone de dale f mari (5g. compilatoarele)

' Programele pot avea multe rutine de tratare a unor eron' posibile,
ce vor ﬁ apelate in timpul execuliei doar dacé apar acele erori

Y M

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Paglnarea la cerere /2
' Paginarea la cerere (c0nt.)
— Avantaje:
' programul este prezent doar panial in memorie
' mai pugine operaﬁi I/O deceit 1a transferul proceselor in
Tntregime (de 1a schema de administrare cu swapping pur)
' mai pugina memorie necesara la un moment dat
- mai multe procese 1a un moment dat
(creste gradul dc multi-programare)
' nu mai e nevoie de tehnica de programme a overlay-urilor,
efortul programatorului ﬁind preluat de SoO.
i Dezavantaje:
' complexitatea hardware si software a acestui mecanism de
gestiune a memoriei 4 m

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Paginarea la cerere /3
~ Paginarea la cerere (c0nt.)
i Cénd este referité 0 pagini, trebuie veriﬁcat dacé:
' Este 0 referinﬁl validﬁ?
Cu alte cuvinte, procesul are dreptul de a accesa
acea adresé?
' Pagina referité este in memorie?
Dacé nu, cauté un cadru de paginé liber gi incarcé
pagina de pe disc in e1.
5 M

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Paginarea la cerere /4
~ Paginarea la cerere (c0nt.)

i Pentru a péstra evidenga paginilor aﬂate in memorie,
se asociazﬁ, pentru ﬁecare paginé, un bit validé sau
invalidi in tabela de mapare a paginilor

Pagina Numérulcadrului Bil(in)validz'1
1 300 1
2 85 0
(v M

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Paginarea la cerere /5
' Erori de paginz'l
i Semniﬁcagia bitului: 1 i pagina este prezenté in
memorie; 0 i pagina nu este in memorie
i Eroare de paginﬁ (pagefault): atunci cind se incearcé
accesarea unei pagini marcate ca invalidé (bitul este 0);
pagina nu este in memorie §i va trebui adusi de pe disc
i Se genereazé 0 intrerupere dc paginé (PFI=page fault
interrupt), de tip sincron, care este transparenté pentru
utilizator §i are o prioritate superioaré celorlalte
intreruperi; ea va intrerupe execugia programului gi
S.O.—ul va exccuta handler-u] asociat acestei intreruperi
_ (H

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Paglnarea la cerere /6
> Erori de pagini (c0nt.)
i Rutina dc tratare a Tntreruperii dc paginé executé:
° Sc cxamincazé adrcsa solicitaté pcntru a vcdca dacé cstc 0
adrcsé pcrmisé; dacé nu cstc, proccsul va ﬁ tcrminat anormal
' Sc cauté un cadru dc paginé libcr in mcmoria principalé 5i sc
solicité 0 operagic l/O care va aducc pagina dc pc disc in cadrul
libcr gésit; pcntru accasta sc mai foloscstc 5i 0 tabelé de
mapare pe disc, cc conginc adrcsa dc pc disc a ﬁccérci pagini
vinuale
' Dupz'l incércarea paginii, se actualizeazé tabela de mapare a
paginilor pentru a indica faptul Ci pagina este validé
~ Apoi este reluaté execugia procesului i instrucyiunea oprité este
restartaté (toalé aceasté procedurz'i este transparemé pemm proces)
\‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Paglnarea la cerere /7
' Erori de paginz'l (c0nt.)

i Este posibil si aparé mai multe crori dc pagini 1a execugia unei
singure instrucgiuni i cazul extrem: codul instrucgiunii “cilare”
pe 2 pagini, cu 2 operanzi ﬁecare “cilare” pe Z pagini, cu
adresare indirecté/indexaté — pot apare 3 intreruperi PFI

— Inconvenientul acestei metode: overhead-ul implicat in cazul
erorilor de paginé (necesité accese la disc, plus folosirea CPU
pemru ajustarea tabelelor)

— O memorie ﬂzicé micé si prea multe process in sistcrn, ori cu o
localitate proasté a datelor si/sau codului, pot conduce la un
numér f mare de intreruperi PFI, deci la aparigia fenomenului
d6 trashing (Le. fcnomenul dc sufucare a SC-ului cu rczolvarca cmrilur
dc paginé, in 10c dc a-si folosi rcsursclc pcntru cxccugiajob-urilor utilc)

‘7 M

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Paglnarea la cerere /8
" Paginarea la cerere (c0nt.)
i O alté problemé: 1a o eroare de paginé, ce facem daci nu gésim
nici un cadru ﬁzic liber?
i Soluyia: sacriﬁcarea unei pagini din memorie i mutarea ei pe
disc pentru a elibera spaﬂu in memorie pt. pagina ce se incarcé
i Cum alegem victima pentru page swapping‘?
Existé mai multc criterii dc alcgcrc, mai mulgi algoritmi p0
care-i vom discuta pugin mai térziu
i ldcca: folosirca unui algoritm dc inlocuirc a paginilor care s51
minimizczc numérul dc crori dc paginé (i.c., dc intrcrupcri PFl)
i in plus, sc poatc prcvcni supra-alocarca dc mcmoric unui
anumit proccs i rutina dc tratarc a PFl poatc decide $5 facé
ni$te inlocuiri chiar dacé mai sunt cadre ﬁzice libere
10 M

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Paglnarea la cerere /9
, Paginarea la cerere (cont.)

i O altz'l problemi: pe lingé bitul de pagini (in)valid?1, mai este
nevoie de un bit de “tranzit” care 55 indice starea de pagini in
curs de incircare de pe disc in memorie

i Motivul: transferul de pe disc dureazi f. mult, timp in care CPU
executé alt proces, §i este posibil ca acesta s'Zl aleagi ca victimé
pentru sacriﬁciu tocmai pagina Tn curs de incércare

i Reguli: cénd aleg victima, evit paginile aﬂate in starea de tranzit

i Observaﬂe: tabela de mapare a paginilor unui proces este péstrati $i
ca in mcmoria acclui proccs; pagina cc conﬁne tabcla nu trcbuic
evacuatﬁ din memorie de cétre a1g4 de page swapping, Le. ea este
“incuiaté” pe toaté durata execugiei procesului, pe cénd paginile in
tranzit sunt “incuiate” dear temporar, pe durata incércirii

l \ M

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Paglnarea la cerere /10
' Paginarea la cerere (c0nt.)

i O alté optimizare: ﬁccérei pagini i se asociazi in tabcla de
mapare a paginilor un a1 3-lea bit, bitul dirty, care determini
dacé pagina a fost vreodaté modiﬁcaté de 1a ultima incércare
dc pc disc

— Iniyial, 1a incércare, bitul dirty este pus pc zero, iar apoi orice
scricre in acea paginz'i i1 seteazﬁ pc 1 (se face bit := bit or l)

i Rostul acestui bit dirty i optimizarea operagiilor I/O: dacﬁ
pagina nu a fosl modiﬁcalé dc la ultima incércare dc pe disc,
alunci ea nu mai trebuic transferalé pc disc atunci cﬁnd cste
aleasz'i drept victimé dc citre algorilmul dc page swapping

ll {vi

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
Paglnarea la cerere /1 1
' Concluzii — intrebiri legate de paginarea la cerere:

i Cum impiedicém utilizatorii s5 acceseze dalele protejale?

° drepluri de acces speciﬁcate 1a nivel de pagini
— Dacé 0 paginé este prezenté in memorie, cum 0 gésim?

' tabela de mapare a paginilor (in memoria ﬁzici)
i Daci 0 paginé nu este prezenté in memorie, cum 0 gisim?

' tabela de mapare (a paginilor) pe disc
i Cénd este adusé 0 paginé in memorie?

~ politici dc incércare i la cerere (atunci 05nd este nevoie de ea)
i Dacé o paginé este adusé in memorie, unde 0 punem?

' politici de plasare
i Dacé 0 paginﬁ este evacuatﬁ din memorie, uncle 0 punem?
i Cum decidem care pagini 551 ﬁe evacuate din memorie?

° politici de inlocuire i algoritmi de page xwapping

l1 M

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Paglnarea la cerere /12
' Mecanisme — pentru suportul paginﬁrii la cerere:

i Suportul hardware i pe léngﬁ translatarea dinamicﬁ a
adreselor necesaré pentm suportul paginérii sau
sﬁgmentﬁrii (c.g. tabclclc dc maparc):

' Mccanism dc gcncrarc a crorilor dc paginé (Le. PFI) in
situagia accesirii paginilor absente din memorie
' Instrucgiuni restartabile
— Suportul software:
° Slructuri de date pentru suportul politicilor de inlocuire,
incércare §i plasare a paginilor in memorie
° Structuri de date pentru localizarea in memoria secundaré
(i.e., pe disc) a paginii dorite
H M

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
MMU / 1
' MMU (= Memory Management Unit, located in the CPU)
i Input: adrese virtuale
i Output: adresele ﬁzice asociate, sau diverse situatii
exceptionale, de violare a accesului (diverse exceptii, care
intrerup pmcesorul, i.c. cxccutia instmctiunii ce cauzcazz't acca cxceptic)
— Situatii (tipuri de exceptii) de violare a accesului:
' paginé absenté din memorie (exceptie PFI)
' acces in mod utilizator vs‘ mod kernel
° lipsa dreptului de read a memoriei
' lipsa dreptului de write a memoriei
' lipsa dreptului de execute a memoriei (pt, paginile de cod)
° alte exceptii, e.g. guardpage $i COWpage (Copy-On-Wme)
15 M

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
MMU /2
' MMU (cont)
i SO-ul controleazé operarea MMU pentru a selecta:
l. Submulyimea de posibile adrese virtuale ce sum valide pentru
ﬁecare proces (i,e., spagiul virtual de adrese al procesului)
2. Traslatérile (mapérile) ﬁzice pentru acele adrese virtuale
3. Modurile de acces permis 1a acele adrese virtuale
(read/write/execute)
4. Setul speciﬁc de translatéri valabil 1a un moment dat (este
necesar un contextiswitch rapid de 1a un spagiu de adrese 1a altul)
i MMU ﬁnalizeazé un acces la memorie numai daci SO-ul spune
cé “referinga e OK” (altfel, MMU produce 0 excepgie)
H» {vi

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
> MMU — ﬁnalizarea unui acces la memorie:
pmhe mm mm;
sfarl‘ [mgll mm phy>ic=aL
here memory
I" probe ralie
TLE NCCPHD“
mm nllncme “° signal
fmln ‘M yes rm“- plncuasi
l7/6l

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Alg. de page swapping /1

' Algoritmi de inlocuire a paginilor

i Alg. d6 inlocuire a unei pagini neutilizate
recent: NRU

i Alg. de inlocuire in ordinea incz'lrcirii: FIFO

— Alg. de inlocuire a celei mai pugin utilizate
recent pagini: LRU

i Aproximéri LRU pentru implementéri

i Alte abordéri

i Implementéri reale

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Alg. de page swapping /2
' Politica de inlocuire a paginilor
i Cind nu mai sunt disponibile cadre de paginé libere,
SO-ul trebuie sé inlocuiascé 0 pagini (victima),
inliturind-o din memorie pentru a réméne rezidenté
doar pe disc (depozitul pentru copia de sigurangé) si
scriindu-i conginutul inapoi pe disc dacé fusese
modiﬁcaté dupé incﬁrcarea in memorie (pagina dirty)
— Algoritmul de inlocuire — are drept scop alegerea celei
mai bune victime, metrica utilizaté dc obicei pcntru
“cea mai buné” ﬁind reducerea ratei erorilor de paginé
(Lei, se urméreste minimizarea numérului de intreruperi PFI)
WM

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Alg. de page swapplng /3
* Intririle in tabela de mapare a paginilor
rub'd'lu't OS ‘cw Hm \uwll MMI
mu me n mum“ 1~ \ mu
lw-frrwumhlr' I N mushy ‘hm m milNc m
mm mm mum \m m" WWW.
-IIII
dim-MI m “hm '\ war» h wwmkl m Hm
W-rwqmgg l\ mmumu
rvjvrc'm v Mr w! \\ hm \\ rum-once \~
mm llnvnyll AIIL‘ prmg :0 m

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
Alg. de page swapplng /4
' Problema caching-ului paginilor (politica de inlocuire)
i Fiecare thread/proces “produce" un ﬂux de referinge 1a paginile
virtuale din propriul spagiu de adresare
' Vom modela execugia ca 0 secvengi de referinge la pagini:
cg. “1,2,3,1,2,3,4,2,3,5,..:’
i SO, incearcé sé minimizeze numérul de erori de paginé produse
' Mulgimea de lucru (working set) I mulgimea de pagini folosite
efectiv de ﬁecare proces, se modiﬁcé in limp relativ incet
' SO-ul inccarcé sé “aranjczc” multimca dc pagini rczidcntc in
memorie a ﬁecérui proces activ astfel Tncét sé aproximeze c511 mai
bine mulgimea sa de lucru
i Factorul determinant pt, succes este politica de inlocuire folosité
' Aceasta delermini mulgimea de pagini rezidente in memorie
I‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Alg. de page swapplng /5
' Algoritmul optim (inutilizabil)
i Réspunsul optim la intrebarea care pagini o aleg drept victimz'l?
este simplu, dar imposibil de realizat:
se alege acea pagind care vaﬁ solicitatd cel mai ldrziu in viitor
i Inutilizabil deoarece réspunsul nu poate ﬁ prevézut in avans i
evolugia unui program nu este previzibilé, ea depinde de datele
concrete asupra cérora opereazi
i Au existat incercéri, dar nu erau practice:
'66 LA‘ Belady i un model de evidengi slatisticé prin care se putea
prevedea cu 0 oarecare probabilitate care este pagina ce va ﬁ
solicitati eel mai térziu
II M

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
Alg. de page swapplng /6
' Algoritmi practici
i Metode folosite: NRU, FIFO, LRU 5i alte variants
i Observagie: indiferent de alg. de decizie folosit, trebuie avut
in vedere faptul 05, pentru implementare, gestiunea unei
structuri de date care si permité decizia, trebuie ficuté la
ﬁecare acces la memorie
i Prin urmare, nu este permisé nici mécar gestiunea unei Iiste
liniare simplu inlénguite (I), ci este nevoie de mecanisme mult
mai u$or de gestionat
i De multe ori aceste metode se implementeazé prin hardware,
ficéndu-se uneori anumite compromisuri
I‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Alg. de page swapplng /7
' Algoritmul NRU (= Not Recently Used)
i ldeea: inlocuirea unei pagini care nu a fost utilizaté recent
i Fiecare paginé ﬁzicé are asociaﬁ doi bigi in tabela de
paginare, folosigi penlru a decide ce paginé se va evacua
i Bitul de referire esle resetat (pus pe 0) 1a Tncércarea paginii
5i este setat (pus pe 1) 1a ﬁecare acces (referire) 1a paginé
i Periodic (dc obicci la 20ms) sc face opcraﬁa dc clearing bits,
prin carc bigii dc rcfcrirc ai tututor paginilor sunt rcsctagi
i Al doilca bit cstc bitul dc modiﬁcare (bitul dirty), cc cstc
rcsctat la incércarca paginii 5i sctat la scricrca in paginé
14 M

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
Alg. de page swapplng / 8
' Algoritmul N RU
i Paginile se impart 1a ﬁecare moment in patru clase, pe baza
acestor bigi:
° Clasa 0 i bigii:(0,0) : pagini nereferite §i nemodiﬁcate
° Clasa 1 i bigii:(0,1) : pagini nereferite (de 1a ultimul clear-
ing), dar modiﬁcate (de la incircarea lor)
° Clasa 2 i bigii:(1,0) : pagini referite, dar nemodiﬁcate
° Clasa 3 i bigii:(1,1) : pagini referite §i modiﬁcate
i Pagina “victimi” se alege din prima clasé nevidi (5e 021th intéi
in clasa 0, apoi in clasa l, $.adm.d.); daci pagina aleasé este din
clasa 1 sau 3, ea va ﬁ salvati pe disc inainte de a ﬁ inlocuité
i Avantaje: alg. f simplu; nu»i optimal, dar e eﬁcient in practicé
15 M

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Alg. de page swapplng /9
, Algoritmul FIFO (= First In First Out)

i ldeea: Tnlocuirea Tn ordinea incircérii paginilor

i lmplementarea este simpli: se gestioneazé o listé FIFO cu
paginile rezidente in memorie; actualizarea ei se face la
ﬁecare incércare de pagind (nu 1a ﬁecare acces 1a memorie!)

i A1egerea“victimei”: prima paginé din listé (i.e4 se va evacua
cca mai vcchc paginé din memoric)

i Bincingclcs, 5i aici sc folosc$tc bitul dc modiﬁcare (bitul dirty),
pcntru a $ti dacé pagina alcasé trcbuic salvaté pc disc inaintc
dc a ﬁ inlocuité

It» M

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
Alg. dc page swapping / 10
' Algoritmul FIFO
i Exemplu: un program cu 5 pagini vinuale, cu secvenga de referire
“l,2,3,4,1,2,5,l,2,3,4,5”, iar memon'a ﬁzicé: 3 cadre de paginé
Pagmasolicitatﬁ 1 2 3 4 1 2 5 1 2 3 4 5
—>
Paginaceamﬂirecenlé i l 2 3 4 l 2 5 5 5 3 4 4 [imp
ListaFlFO: *i12341222533
Paginaceammvevche - - - 1 2 3 4 1 1 1 2 5 5
inlocuiredwﬂginMPFl): Da m Da m Da n11 Lu, Nu Nu m Da Nu
lFrach i111444555555
Yam“ Framel ii22211111333
Frach iii3332222244
Rata crorilur dc pagini: PFIiratio = 9/12 = 75%
TM

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Alg. dc page swapping /11
' Algoritmul FIFO
i Exemplu: acelasi program cu 5 pagini virtuale, cu aceea§i secvenlé
de referire “1,2,3,4,1,2,5,1,2,3,4,5”, dar memoria ﬁzicé: 4 cadre
Paginasolicima 1 2 3 4 l 2 5 l 2 3 4 5
—>
Paginaceamairecemé i 1 2 3 4 4 4 5 1 2 3 4 5 timp
. **12333451234
lenro; v***1222345123
Paginaceamaivcche i i i i I 1 I 2 3 4 5 1 2
inlocuirvdvvﬂgiWPFl): Da Da Da Da Nu Nu Da Da Da Da D3 Da
Memoria RAM: Twnu‘ penrru acasd: complelari diagrama limp pl. memoria RAM!
Rata erorilor de paginé: PFliratio I 10/12 I 83,33%
NM

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
Alg. dc page swapping / 12
' Algoritmul FIFO
i Anomalia lui Belady: degi bunul sim; ne spune c5 gansa ca
0 paginé sa ﬁe inlocuité scade pe misura ce crews
numarul de cadre ﬁzice, totusi nu se intﬁmpli a$a in cazul
alg. FIFO, dupa cum rezulta 5i din exemplul anterior
i All dezavantaj: (spre deosebire de LRU) algoritmul FIFO
dezavantajeaza paginile “esengiale” (Le. utilizate frecvent),
cc vor ﬁ in mod periodic evacuate pc disc si rcincércatc
curénd dupz'i cvacuarc
2*Hvi

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Alg. de page swapp1ng/13
, Algoritmul LRU (= Least Recently Used)

i ldeea: inlocuirea paginii cel mai pugin folosite in ultimul timp

i Cum? Se va folosi Iocalitatea temporalé/spagialé a programului
pentru a inlocui pagina cel mai pugin utilizaté recent
[principiul localitigii: o paginz'i ce a fest accesati des (rar) de citre
ultimele instrucgiuni, probabi] va ﬁ accesati des (rar) $i in continuare]

i Pentru implementare este nevoie s5 se giné evidenga utilizérilor
paginilor, adicé s5 ordonim paginile dupi timpul celei mai
receme referinte la ele i necesité deci gestiunea informagiei la
ﬁecare acces la memorie §i hardware f, costisitor

i Teorelic, gestionarea informagiei referiloare la utilizarea paginilor se
poate face cu o coadé FIFO, cu observagia 051a accesarea unei pagini, ea
este scoasé din coadé $i mutati in vﬁrful cozii, dar nu-i eﬁcient practie0M

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
Alg. de page swapping / 14
' Algoritmul LRU
i Exemplu: ace1a$i program cu 5 pagini virtuale, cu aceeasi
secvenyi de referire “1,2,3,4,1,2,5,1,2,3,4,5”
memoria ﬁzici: 3 cadre de paginé
Pagimmlicixalé 1 2 3 4 1 2 5 1 2 3 4 5
—>
Pagma cu celmalrecemacces i l Z 3 4 l Z 5 1 2 3 4 5 (imp
ConclaLRU: fil2341251234
Pagina cu cclmaivthiacccs i i i 1 2 3 4 1 2 5 1 2 3
inlocuirc dc pagmMPl-‘D: Da Da Da Da Da Da Da Nu Nu Da Da Da
Memoria RAM: Temﬁpenzmamm‘:complclagidiagramalimppl.memoriaRAM!
Rata crorilor dc pagini: PFIiratio = 10/12 = 83,33%
31 111

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
Alg. dc page swapping / 15
' Algoritmul LRU
i Exemplu: ace1a$i program cu 5 pagini virtuale, cu aceeasi
secvenyi de referire “1,2,3,4,1,2,5,1,2,3,4,5”
dar memoria ﬁzicé: 4 cadre de paginé
Paginasolicilati 1 2 3 4 1 2 5 l 2 3 4 5
—>
PaginacucelmaireCBmaCCeSi l 2 3 4 1 2 5 l 2 3 4 5 timp
4412341251234
CHMLR“ v iii|234|25123
Paginacucelmaivechlacces — — — — 1 2 3 4 4 4 5 l 2
inlocuirc do paginé(PFI)I m m m m Nu Nu Da Nu Nu m m Da
Memoria RAM: Termi pentru acasﬁ: complelali diagrama limp pl. memoria RAM!
Rata erorilor dc paginé: PFIiratio : 8/12 : 66% x
31h

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
Alg. de page swapping / 16
' Algoritmul LRU
i Modalitéyi de implementare a alg. LRU:

' LRU cu contor de accese

' LRU cu stivi

' LRU cu malrice de referinte

i Multe SC-uri folosesc pentru paginare o aproximare a LRU
i Avamaj e:

‘ Nu pTCZimé'l anomalia [Mi Belady (se poate demonstra matematic
cé alg. LRU cu stivi are proprietatea de monotonic i nu funcgioneazé
mai réu dacé crew: numﬁml de cadre de pagini ale memoriei ﬁzice)

' spre deosebire de alg. FIFO, alg. LRU avantajeazé paginile
“esenyiale” (utilizate frecvent), ce vor ﬁ péstrate in memorie

31 M

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Alg. de page swapplng /17
I LRU cu contor de accese
i Se implementeazé hard. CPU are un registru (de obicei pe 64 bigi)
numit cantor cu rol de ceas logic i este incremental la ﬁecare
instrucgiune, sau acces 1a memorie
i in tabela de pagini existi un cémp rezervat pentru a péstra
valoarea acestui contor i 1a ﬁecare acces 1a 0 paginé, contorul
cstc mcmorat in spagiul corcspunzétor acclci pagini
i Cu ajutorul accstor valori salvatc, putcm §ti dacﬁ o paginé a fost
sau nu utilizaté dc la ultimul clear-ing a1 bigilor dc rcfcringé,
prccum $i in cc 0rdinc (aproximativé) au fost acccsatc paginilc
i Alcgcrca “victimci” pcntru cvacuarc consté in céutarca in
tabcla dc pagini a paginii cu cca mai micé valoarc a contorului
N M

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
Alg. de page swapplng /18
' LRU cu stivﬁ
i Se folosegte o stivé cu numerele de paginé
i Cénd este referité 0 paginé, ea este scoasé din stivé (doar daci
exista deja in stivé) $i apoi este pusé in vérful stivei
i in orice moment, pagina de 1a baza stivei este pagina cea mai
pugin utilizaté recent
i Alcgcrca “victimci” pcntru cvacuarc cstc simplé i pagina dc
1a baza stivci» nu prcsupunc o céutarc, dar in schimb la ﬁccarc
acccs cstc ncvoic dc céutarca paginii doritc in stivé pcntru a 0
muta in vérful stivci
35 M

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Alg. de page swapplng / 19
' LRU cu matrice de referinge
i Se folose§te 0 matrice binaré (cu 0 gi 1) de dimensiune n*n,
unde n este numirul de pagini ﬁzice ale memoriei SC-ului
i Inigial toate elementele matrieii se pun pe 0
i in momentul cénd se referé pagina k, se pune mai Tméi 1 peste
tot pe linia k, iar apoi se pune 0 peste tot pe coloana k
i in oriee moment numirul de eifre l de pe 0 linie l ne aratﬁ
ordinea de rcferire a paginii If ultima paginé referiti va avea
n-l cifre de l,penu1tima 11-2, $.a.m.d.
i Alegerea “vietimei” pentru evaeuarc se face eiutﬁnd linia din
matriee cu celc mai pugine eifre de 1 (eu eele mai multe Zero-uri)
i lmplementarea matrieei de referinge se face prin hard
U‘ M

***************Ending Page***************


***************Beginning Page***************
***************page number:37**************
Alg. de page swapping /20
' Algoritmul LFU (=Least Frequently Used)

i ldeea: inlocuirea paginii cel mai puyin folosite (per total, nu
doar in ultimul timp)

i Alg. actualizeazé la ﬁecare acces de paginé un contor al
numérului dc acccsc, pistrat in tabcla dc pagini (cantor ce nu
este resetat periodic ca la LRU cu contor de accese)

i “Victima”: sc alcgc pagina cu ccl mai mic cantor

i Dczavantaj: dacé 0 paginé cstc utilizaté f. dcs in faza inigialé
a unui proccs, iar apoi nu mai cstc utilizaté dcloc, ca riménc
totu$i in mcmoric pcntru c5 arc o valoarc f. mare a contorului

' Algoritmul MF U (=M0st Frequently Used)
— dualul alg‘ LFU; se alege pagina cu cel mai mare contor
1‘ m

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Alg. de page swapplng /21
' Alte abordﬁri:
i NRU combinat cu FIFO
' ldeea: se aplicé inléi NRU, iar la nivelul ﬁecéxei class se aplicé FIFO
i Metoda celei de-a doua $31156 (e.g. Mach OS)

° Ideea: Se aplici FIFO cu urmétoarea modiﬁcare: dacﬁ pagina cea mai
veche are bitul de referingé pus pe 1, atunci i se mai d5 o gansé i bitul
este pus pe 0 $i pagina este mutaté la sférsitul listei (astfel devine cea
mai recenté pagim'l); céutarea se rcia cu noua listé, pﬁné se gésegte 0
paginé cu bitul pus pe 0 i acea paginé este selectaté pentru inlocuire

i Algoritmi de inlocuire a paginilor bazaﬁ pe prioritatea
proceselor
i Algoritmi de inlocuire cu pagini de dimensiuni variabile
3% M

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
Alg. de page swapplng /22
, Implementﬁri reale: paged daemon
i Majoritatea SO-urilor au unul sau mai multe procese de
sistem responsabile cu implementarea politicii de inlocuire a
paginilor pentru memoria virtualz'i
' Un demon (daemon) este un proces de sistem autonmn care executé
periodic 0 anumiti sarcini de administrare a SC-ului
i Demonul de paginare pregéteete sistemul pentru evacuarea de
pagini inainte ca s5 aparé nevoia de evacuare
' Demonul se “trezegte” 05nd cantitatea de memorie liberé devine mici
' “Curégé” paginile dirty prin scrierea lor pe disc *prewrite sau pageout
' Administreazé liste ordonate cu candidagii pentru evacuare
' Decide cit de multi memorie sé aloce pentnl memoria virtual?!
Fwd

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
Memone v1rtual'Z1/5
' Fenomenul de trashing

i Trashing = fenomenul de “sufocare” a sistemului atunci 05nd
comportamentul swapping devine excesiv
(sistemul este ocupat predominant cu tratarea erorilor de pagini,
in loc de a-gi folosi timpul penmi execugiajob-urilor utile)

i Paginarea la cerere functioneazé datoritﬁ localitégii
(temporale $i spagiale) manifestate de programe, dar atunci
05nd ceringele minimale de memorie nu pol ﬁ satisficute,
apar numeroase operapii de swapping a paginilor

i Aceasta duce la o proaslé ulilizare a CPU 5i la f. multe
operagii I/O —> SO-ul poate incerca s5 imbunétigeascé
ulilizarea CPU prin mdrirea numirului dc procese

40 M

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
Memone v1rtual'Z1 / 6
' Fenomenul de trashing

i Multimile de lucru (working sets) i sunt 0 modalitate utilé
pentru controlul fenomenului de trashing

i O multime de lucru este multimea de pagini folosite de un
proces la un moment dat (luﬁnd in calcul localitatea)

i Fenomenul de trashing va apare dacé suma dimensiunilor
multimilor de lucru ale tuturor proceselor din sistem
depése$te limita impusé de cantilalea de memorie ﬁzicé din
acel sistem

i in caz dc nevoie, se pol suspenda uncle process pentru a se
coboré sub aceastz'i limilé

4‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Memorie virtualé /7
> Alte mecanisme de memorie virtualﬁ
— Segmentarea (cu incﬁrcare) la cerere
I Segmentarea combinaté cu tehnica de swapping
' Ideea: aducerea segmenlelor de pe disc in memorie doar
in momentul cénd sunt referite (“cénd e nevoie de ele")
' Ridicé probleme aseménitoare cu cele de 1a paginarea la
cerere
i Segmentarea paginatﬁ (cu incircare) la cerere
I chmcntarca paginati combinaté cu tchnica dc swapping
41 M

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
Concluzii /1
' Planiﬁcarea schimburilor cu memoria
i intrebﬁrile gestiunii memoriei: indiferenl de metoda de alocare
folosité, SO-ul trebuie sé rezolve 0 serie de probleme cum ar ﬁ:
' Cit? i problema cantitégii de memorie alocaté:
*Alocare slaticé i toatﬁ memoria la inceput (e4g4 alocarea pe partiyii)
"Alocare dinamicé i doar necesarul curent (6‘g‘ paginarea la cerere)
' Unde? i problema locului liber pe care va ﬁ plasat programul
(apare la, e.g., alocarea cu partilii variabile) —> Politici de plasare
' Cind? i problema momenlului de incércare a paginilor in cadre
fiZiCe (apare la alocarea cu paginare) —> Politici de incércare (fetch)
i problema momentului dc compaclare (apare la, e.g.,
alocarea cu partiyii variabile, sau la segmentarea nepaginalé)
' Care? i problema alegerii victimei 1a incércarea paginilor (apare
1a, e.g., alocarea cu paginare la carers) a Politici de inlocuire 4‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Concluzii /2
r Planiﬁcarea schimburilor cu memoria (cont.)
i Politici de schimb utilizate de gestiunea memoriei:
' Politici d6 plasare i utilizate de SO-uri $i/sau programs (malloc/free)
, algoritmii FFA, BFA, WFA
' Alacarea cu camarazi (a se vedea sludml dc Cal Linux), Googlek algorithm
PartitianAlluc (delalii: -), $4a.
' Politici de incﬁrcare (fetch)
r incircarca la inccpulul cxccugici
' incircarea la carers (ire, pe parcursul execugiei), cu varianta:
incircarea in avans (pe baza principiului localitégii)
' Politici de inlocuire (swapping)
r alg. NRU, FIFO, LRU, 5.21.
44m

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
Concluzii / 3
' Plamﬁcarea schlmburllor cu memorla (c0nt.)
i Tehnici de alocare utilizate:
Alocare conﬁguﬁ Alocare nccouligué Tap alocare
>
Alocarea unicé Pa inarea( uri)
Memnrie Alocarea cu panigii S g p .
realﬁ _ ﬁxc Segmentarea (pmia) t5 .
_ variabilc egmen area pagma (pura)
M . Paginarea la cerere
cmonc .
vimmla Alocarea cu swappmg Segmentarea la cgrere
SegmenlaIea pagmaté la cerere
. .v
TIP mcmonc 4; m

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Tehnici mai recente /1
' SC au evoluat pe parcursul anilor
i Au apérut noi arhitecturi hardware / noi vederi ale
“ierarhiei” de memorii
~ Memorie la distant?!
i NUMA (Non-Uniform Memory Access)
' lmplementatﬁ pe AMD Opteron i 2003, Intel x86 i 2008
(https://en.wikipedja.org/wiki/Non-uniformimemoryiaceess)
i DSM (Distributed Shared Memory)
i GMS (Global Memory Systems)
~ lmplementalé pe Digital UNIX Si FreeBSD ('98)
4PM

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
Tehnici mai recente /2
' Distributed Shared Memory (DSM)
i Permits utilizarea modelului de programars cu
memorie partajati (spagiu de adresare partajat)
intr-un sistcm distribuit (proccsoarc dotatc doar cu
memorie localé §i 0 regea de comunicagie)
111C111 fx 111cm
\ K1126) proc / ' ' "
_ / \__ network ,u/ ‘
\ 1mg “\“é .
X‘ llllllll llllllll
4‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Administrarea memoriei in Linux /1
' Planiﬁcarea memoriei
i Subsistemul de administrare a memoriei ﬁzice
din Linux are ca sarciné alocarea gi eliberarea
paginilor (ﬁzice), a grupurilor de pagini §i a
blocurilor mici de memorie
— Linux-ul are mecanisme suplimentare pentru
gestionarea memoriei virtuale, i.e. a memoriei
mapate in spagiile de adrese logice ale proceselor
aﬂate in curs dc execugic in sistcm
4k M

***************Ending Page***************


***************Beginning Page***************
***************page number:49**************
Administrarea memoriei in Linux /2
' Administrarea memoriei ﬁzice

i Alocatorul de pagini alocé 5i elibereazé toate paginile ﬁzice;
poate aloca la cerere intervale contigue dc pagini ﬁzice (Le,
grupuri contigue dc pagini), dar numai penlru cereri realizate
in kernel-mode (pentru necesitégile nucleului),

i Practic, se alocé memorie ﬁzicé in avans, sistemul menginﬁnd astfel
free-memmyprmls (i.c. intervals contiguc dc pagini ﬁzice), din care
poate satisface rapid cereri de alocare de diferitc dimensiuni, cereri
ficute de nucleu pentru a stoma structuri de date de diferite dimensium',
sau pentru zone tampon folosite pentru l/O prin DMA

i Politici de plasare utilizate pentru cererile nucleului:

' Alasatoru/powewofi i implementeazé alg. alacarea cu camarazi
' Alocatarul SLAB i cu diverse varianle de implementare
4W

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
Admlnlstrarea memonel in Llnux /3
' Administrarea memoriei ﬁzice (conn)
i Alocalorul buddy-system (alocarea cu camarazi)
' Ficcarc rcgiunc de memorie
alocabilé este asociati cu o
regiune parteneré adiacenté
“B “KB ' Ori dc célc ori doué rcgiuni
partenere alocate sunt eliberme,
1m ele sum combinate intr-o
singuré regiune liberé, dublé
u ' Dace] 0 cerere micé de memorie
m nu poate ﬁ satisﬁcuté prin
alocarea unei regiuni libere
u mici, o regiune liberé mai mare
se imparts in 2 regiuni panenere
pentru a salisface cererea
50 m

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
Admlnlstrarea memorwl 1n Llnux /4
° Administrarea memoriei ﬁzice (c0nt.)
i Alocatorul SLAB, cu variantele SLOB §i SLUB
kmvveihﬂlih m ﬂ ' Un slab : un interval contiguu de
I: — pagini ﬁzice
3 KB I IE|_=] ' Un cache I format din una sau mai
(mm I _ mulls unitali slab, este folosit pentru
I] a sloca loalc instanlclc unui lip dc
22(353P (hi utilizat de nucleu i obiecte
» I — “M5 M marcate drept ﬂee ﬁau med
I = '= - Avanlajc: nu cxlslé nsipé dc spauu
oniéf: I l=l ‘i prin fragmeniare inlemé (plenum la
|=| — pnglnzlrc, unlizaié pcmru user-mode);
I ‘—| — salisfaccrca rapidé a ccrcrilor dc
alocare, din slab-urile prealocate
Nari: penlru delalii Snplimenlarev ciliii §IO.8.2 din [OSCIO], q H

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
Administrarea memoriei in Linux /5
' Administrarea memoriei virtuale
i Nucleul Linux rezervé 0 zoné de lungime constanté,
dependentﬁ de arhitectura SC, din spagiul virtual de
adresare a1 ﬁecérui proces, pt. propriul siu uz intern
i Aceastﬁ zoné rezervatﬁ de nucleu conﬁne 2 regiuni:

° O zonz'i staticé cc congine 0 tabelz'i de pagini cu referinge la
ﬁecare paginé ﬁzicé disponibilz'i in sistem, astfel incﬁt sé
exists 0 translagie simplé de la adrese ﬁzice la adrese
virtuale atunci cénd se ruleazé codul nucleului

° Restul secgiunii rezervate nu este rezervalﬁ pentru un scop
anume; inlririle sale din labela paginilor pot ﬁ modiﬁcale
pentru a indica spre orice alte zone din memorie

51 M

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
Administrarea memoriei in Linux /6
m"
q
- Componente: ‘_
1.1.1“ " ' =
:
'- -- 51m

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
Administrarea memoriei in Windows /1
' Administrarea memoriei - Windows NT (2k/XP/.,./10)
i Administratorul de memorie lucreazi cu process, nu cu threads
i Spagiul de adresare virtual este paginat cu incércare 1a cerere,
cu pagini de dimensiune ﬁxi i 4 KB (max 64 KB pt. ltanium)
i SO-ul poate folosi si pagini mari (cu dimensiunea de 4 MB)
pentru a reduce spagiul ocupat de tabelele de paginare
i Fiecare paginé vinualé poate ﬂ: liberé (“neutilizaté”), rezervaté
sau “angajaté” (committed)
i Paginile libere si cele rezervate au pagini shadow pe disc, iar
referirile (accesul) 1a ele provoacé intotdeauna eroare de paginé
i Se pot folosi maxim 16 ﬁsiere de swap
i Segmentarea nu este suportaté
i Tabelele de paginare sunt pe 2 nivele (1a Windows pe 32 bigi)
54 M

***************Ending Page***************

***************Beginning Page***************
***************page number:55**************
Administrarea memoriei in Windows /2
' Administrarea memoriei (com. i Windows pe 32 biis)
i Adresele virtuale sunt pe 32 de bigi (H spaiiu virtual de 4 GB)
i Vérful (primii 64 KB) §i baza (ultimii 64 KB) spagiului de
adrese virtual al ﬁecérui proces, in mod normal nu sunt mapate
i incepénd de la 64 KB de la baza spagiului §i péné aproape de
jumitate (2 GB) este zona utilizator privali i coniine codul 5i
datele programului
— Ultima porgiune din jumétatea de jos congine date de sistern
(contoare 5i timer-e) partajate read-only de togi utilizatorii
— Jumétatea de sus (2 GB) a spagiului virtual congine SO-ul,
inclusiv codul séu, zona de date §i diverse regiuni (pools),
paginate 5i nepaginate (contigue), utilizate pentru obiectele
sistemului; aceasti poriiune nu poate ﬁ scrisé §i, in cea mai
mare pane, nici citité, de eétre procesele utilizator 55 M

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
Bibliograﬁe
' Bibliograﬁe obligatorie

capitolele despre gestiunea memoriei din
i Silberschatz : “Operating System Concepts”

(capJU, prima pane: §10.1*s, din [0300])
sau
i Tanenbaum : “Modern Operating Systems”

(capj, ‘534-6. din [M0841]
Suplimentar: capitolele studii de caz (despre Unix/Linux 5i
respectiv Windows NT) din cele doué céﬂi de mai sus

5i‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
Exerciyii dc seminar
' Aphcayn 1a: Alocarea paglnaté 1a cerere
i EX. I) Enunrj Considerém un sistem cu paginare la cerere, cu slralegia de
swapping LRU, 5i un program ce trebuie rular pe acest sistem, céruia SO-ul Ii
acordé 4 cadre (pagini ﬁ7icc) pc loalé durata excculici sale.
Spagiul virtual a1 prugramului are 5 pagini, iar secvenga de acces la ele pe
parcursul execugiei sale cite urmﬁtoarea: l,2,3,4,2,3,5,l,2,3,4,5.
Caro cslc rata intrcrupcrilur dc paginé oblinulé Ia cxcculia accstui program‘?
Justiﬁcagi réspunsul, desenénd diagrama limp a evoluliei cozii LRU pentru
acest program, precum 5i cea a ocupérii cadrelor alocate acestui program, pe
parcursul cxccurici sale.
i Rezolvare: 7
Pagina solicitaté 1 2 3 4 2 3 5 l 2 3 4 5
—>
Pagiua cu cel mai recent acces i [imp
Cuada LRU: i
Pagina cu cel ma! ve'chi acces i
inlocuire de paginﬁ (PFI): ‘Z ‘7 1' 5‘ M

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
Exercigii dc seminar
' Aplicayii 1a: Alocarea paginaté 1a cerere
i EX.2) Enunt: Considerim un sistem cu paginare la carers, cu strategia dc
swapping LRU. Fie fragmentul de program aléturat, care inigializeazé
clcmcnlclc unci malrici A dc dimcnsiunc l000 >< [000.
Spagiul vinual a1 programului are 1001 pagini: cite l paginz'l vinualﬁ pentru
ﬁecare linie a matricii A, plus l paginﬁ pentru instrucgiuni 5i variabilele i $1 j.
La un moment dat memoria disponibili este de 101 pagini ﬁzice.
Cite PFI (Intreruperi de paginé) vor ﬁ necesare penlru execuﬁa acestui
program, in cele doué varianle a) 5i, respectiv, b) 7
Justiﬁcagi réspunsurile.
a) b)
fuz(i=0; muse; ++i) {Dru-=0; j<1DOﬂ; ++j)
for(j=D; j<1000; ++j) for(i=0; i<1000; +4)
A1i1[:'|1= 0; Ali11j1= 0
i Rezolvare: ‘I
50m

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
Sumar
' Memoria virtualé
i Pn'ncipiul localitigii
i Paginarea la cerere
i MMU
i Algoritmi de Inlocuire a paginilor
~ Fenomenul de trashing
i Segmentarea 1a cerere
' Concluzii
' Tehnici mai recente pentru administrarea memoriei
' Administrarea memoriei in Linux 5i Windows
intrebiri ?
M M

***************Ending Page***************

