***************Beginning Page***************
***************page number:1**************
Chapter 9: Main Memory
—

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
W Chapter 9: Memory Management
I Background
I Contiguous Memory Allocation
I Paging
I Structure ol the Page Table
I Swapping
I Example: The Intel 32 and 64-bit Architectures
I Example: ARMvB Architecture
ammsrﬂmmmuwwe.“ ,1 “mam-trMariam

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
F . .
“W Ob jectlves
I To provide a detailed description oi various ways of
organizing memory hardware
I To discuss various memory-management techniques,
I To provide a detailed description 01 the Intel Pentium,
which supports both pure segmentation and segmentation
with paging
Wm", swim. Cum,“ 7 w mm s a Sllhvumu. Bllvln "a m". mu

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
r‘
W Background
I Program must be brought (lrorn disk) into memory and
placed within a process for il lo be run
I Main memory and registers are only storage CPU can
awess directly
I Memory unit only sees a stream of:
. addresses + read requests, or
' address + data and write requests
I Register access l5 done in one CPU clock (or less)
I Main memory can take many cycles, causing a stall
I Cache sits between main memory and CPU registers
I Protection of memory required to ensure correct operatlon
om“.“amamawimdm ,. “imam-vi“Mariam

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
W Protectlon
I Need lo ensure that a process can only access those addresses in it
address space.
I We can provide (his protection by using a pair of base and limit
registers deﬁne the logical address space of a process
Human
- WW?’
aaoooo
420940 u
100010 u m
256000 u
“-
0mm", slim... mm“ a 1M Wm s s sun-“me um“ m a-vnl mu

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
W‘ Hardware Address Protectlon
I CPU must check every memory access generated in user
mode to be sure it is between base and limit (or that user
m
addreu e yrs o m
I.» no
tranlonwalingwﬂem
illegal 11.1an error memury
I The instructions to loading the base and limit registers are
privileged
Wm", sh"... Cum,“ 7 w Wm s e Sllhvuzhlu. Bllvin m m". mu

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
t‘
‘4} 7“ Address Binding
I Programs on disk, ready to be brought into memory to execute (orrn an
Input queue
. Wrthout support, musl be loaded into address 0000
I lnconvenientm have ﬁrst user process physical address srwsys at
D000
' How can it no! he7
I Addresses represented in drrrereru ways e1 diﬂereru siages of a
programs \ife
' Source eede addresses usuaHy symbolic
' Compiled code addresses bind to relocalable addresses
r r e. “14 nyres rrorrr begmning OHhiS modme"
. Linker or loader wrll hind relocatable addresses to absolute
addresses
> rs. 74014
I Each bindmg maps one address spade m another
Wm, em WWW We 91 sums W“ .r. swim!“

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
A
W Binding of Instructions and Data to Memory
I Address binding oi instructions and data lo memory addresses
can happen at three diflerent stages
° Compile time: ll memory location known a prion, absolute
code can be generated; must recompile code if slarting
incation Changes
' Load time: Must generate relocatable code il memory
iocation is not known at compile time
' Execution time: Binding delayed until run time if lhe process
can be moved during its execution lrom one memory segment
to another
> Need hardware support lor address maps (e.g., base and
limit registers)
Wm.“ 5m... Cum,“ e m» mm u Sllhvumlu. em m m“- mm

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
a}; Multistep Processing ofa User Program

(:3
m\

@Q\Eé
K. M

Q MD m

n» |:|

E

w a w

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
t‘
W Loglcal vs. Physlcal Address Space
I The concept of a logical address space that is bound to a
separate physical address space is central to proper memory
management
' Logical address — generated by the CPU; also relerred to
as virtual address
' Physical address — address seen by the memory unit
I Logical and physical addresses are the same in compile»lime
and load-time address-binding schemes; logical (virtual) and
physical addresses differ in execution-lime address-binding
scheme
I Logical address space is the set of all logical addresses
generated by a program
I Physical address space is the set of all physical addresses
generated by a program
om",5,...mmmemm em Slim-a summawiw.

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
“ﬂy Memory-Management Un It (MMU)
I Hardware device that maps virtual to physical address at
runtime
\oglat Pthkal
M.“ .m
I— Er m1
I Many methods possible, covered in the rest of this chapter

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
A
W Memory-Management U n|t (Cont.)
I Consider a simple scheme, which is a generalization of the
base-register scheme
I The base register now called relocation register
I The value in the relocation register is added to every address
generaled by a user process at the time it is sent l0 memory
I The user program deals with logical addresses; it never sees
the real physical addresses
° Execution-time binding occurs when reference is made to
localion in memory
. Logical address bound to physical addresses
Wm.Synmmmmmemdm w gimme-w“denim.

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
w Memory-Management U n|t (Cont.)
I Consider a simple scheme, which is a generalization of the
base-register scheme
I The base register now called relocation register
I The value in the relocation register is added lo every address
generaled by a user process H\ (he (ime i\ iS sent \0 memory
m
mum
323:2‘. 2251'?!‘
H m a m
mu
om“, 5"..." Emmy w Em g u Slim-e W“ m W‘. W.

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
my‘? Dynamic Loading
I The entire program does need to be in memory to execute
I Routine is not loaded until it is called
I Better memonj-space utilization; unused routine is never
loaded
I All routines kept 0n disk in relocatable load iormat
I Uselul when large amounts 0f code are needed l0 handle
inirequently occurring cases
I No special support from the Operating system is required
Q Implemented through program design
' OS can help by providing libraries to implement
dynamic loading
Wm,§,...mcm.m.wmm an SIMMMM.mqnimm

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
ego‘ Dynamic Linking
I Static linking — system libraries and program code combined by
me loader into me binary program image
I Dynamic linking — linking postponed until execution time
I Small piece cl code, stub, used to locate the appropriate
memory-resident library routine
I Stub replaces itself with trie address oi the routine, and executes
the ruuiine
I Operating system checks if routine is in processes‘ rnernciy
address
' If it's riOl in address space, add ll IO address SpaOe
I Dynamic linking is particularly useful for libraries
I Sysiem also known as shared libraries
I Consider applicabiliiy id patching sysiem libmries
i VerSlﬂrtlﬂg may be needed
era-aim, Syn-m eamaa e in?‘ mm s i5 Silhvmhlu. Bllvlli "a an". am

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
A
W Contiguous Allocation
I Main memory must support both OS and user processes
I Limited resource, must allocate efficiently
I Contiguous allocation is one early melhod
I Main memory usually into two or more partitions:
o Residenl Operaling syslem, usually held in low memory
with interrupt vector
0 User processes lhen held ih high memory
Q Each process contained in single contiguous section of
memory
om".5,...MWBMPWGW we Sllhvuzh-msulvlnnude-“£82m:

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Fe
W Contlguous Allocat|on (Cont.)
I Relocation registers used to protect user processes lrorn each
other, and from changing Operaling-syslem Code and data
' Base register contains value of smallest physical address
0 Limit register contains range of logical addresses i each
logical address must be less than the limit register
. MMU maps logical address dynamically
. Can then allow actions such as kernel oode being
transient and kernel changing size
om“,Swammemm 9w alumna-n“mania“.

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
u$$J§Hardware Support for Relocation and Limit Registers
iimii leiocaiion
f5gi515i vegyster
ioqical DhySical
addiess yes , address
CPU < W memory
\,
no
ﬂap addiessing ennr
om", 5"..." BMW w Em g i. “mm W“ m WNW.

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
‘W Variable Partition
I Multiple-partition allocation
. Degree of mulliprogramming limited by number of panilions
I Variable-partition sizes for emsieney (Sized re a given process’ needs)
' Hole — block cl available memory; holes of various size are scaltered
lhroughoul memory
' When a process arrives, it is allocaied memory lrum a hole lerge enough l0
accommodale ii
0 Process exmng irees is partition, adiacenl iree peniiiens are combined
I Operating system maintains inlormalion about:
a) allocated panilions b) free panmens (hole)
"13.?" m OS
—
I) - D D puke“ g
“m” - -
"“ @
we»,
we.“ e...“ “were em i i. new“ W“ .n uni-em

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
t‘
“W Dynamlc Storage-Allocatlon Problem
How to satisfy a request oi size n from a list oi free holes?
I First-fit: Allocate the first hole that is big enough
I Best-ﬁt: Allocate the smallest hole that is big enough:
must search the entire lisl, unless ordered by size
Q Produces the smallest leftover hole
I Worst-fit: Allocate the largest hole; must also search the
entire lisl
° Produces the largest leftover hole
First-iii and besl-fil behave beller lhan worst-ﬁt in lerrrls bl speed
and storage utilization
Wm, 5"..." “WP m» mm g m sum»; W“ m W‘. W.

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
y‘
W Fragmentat|on
I External Fragmentation — total memory space exisls l0
satisfy a request, but |t |s not contiguous
I Internal Fragmentation — allocated memory may be slightly
larger than requested memory; this size difference is memory
internal to a parlition, but not being used
I First fit analysis reveals lhal given N blocks allocated, 0.5 N
blocks iost to lragmentation
i 1/3 may be unusable -> 50-percent rule
OM",=y....nc.m.,m.em.,.m m “mam-vi“.mqniem

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
t‘
W Fragmentatlon (Cont)
I Reduce external fragmentation by compaction
° Shufﬂe memory contents to place all free memory
together in one large block
' Compaction is possible only if relocation is dynamic,
and is done at execution time
' l/O problem
t Latch job in memory while it is involved in IIO
> Do l/O only into OS buffers
I Now consider that backing store has same fragmentation
problems
om",“animunamdm 91, “mum-vi“mania,“

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
K‘ .
he?‘ Pag mg
I Physical address space of a process can be non-conliguous;
process is allocated physical memory whenever ihe laller is
available
0 Avoids external fragmenialion
' Avoids the problem ol van/mg sized memory chunks
I Divide physical memory inlo fixed»sized blocks called frames
. Size is power 012, belween 512 by\es and 16 Mby\es
I Divide logical memory into blocks ni same size called pages
I Keep track ofall lree frames
I To run a program of size N pages, need to ﬁnd Nlree frames and
load program
I Set up a page table lo translate logical to physical addresses
I Backing store likewise splil inlo pages
I Slill have inlemal lragmenlalion
OM",smﬂeﬂwmmm m smash-Win“nae-aim“

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
A
“$9 Address Translatlon Scheme
I Address generated by CPU is divided into:
° Page number (p) — used as an index into a page table which
Contains base address 0f each page in physical memory
° Page offset (d) — combined with base address to deﬁne the
physical memory address lhai is serii l0 \he memory urlii
page number page offset
m in n
. For given logical address space size: 2"v and page size: 2'-
ommﬂynmmmmpwarm g,‘ inhmmﬂm“denim.

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
W Paging Hardware
Mumm- MYIMINM I mun
d
.-
— DWIIIWI'M'Y
m..."

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
\qu Paging Model of Logical and Physical Memory
(rams
number
@-
0 I
‘u I
- 2 a -
B e2 2
P 9 a
loglca‘ 4-
memory
5-
6-
I
phySlCa\
memory
0mm sh..." BMW” mm . m mm.‘ W“ m “Mm

***************Ending Page***************

***************Beginning Page***************
***************page number:27**************
W Paging Example
I Logical address: n = 2 and m = 44 Using a page size of4 bytes and a
physical memory of 32 bytes (B pages)
o o
;H I
, . v s
. z ‘ .
H MW.
12H " I
I; .
WWW u
" H
MW A
0mm, sh..." mm‘. 7 w mm . 2'1 “mm-m 81M“ m GIIIII mu

***************Ending Page***************


***************Beginning Page***************
***************page number:28**************
r‘
W Paging -- Calculating internal fragmentation
I Page size = 2,049 bytes
I Process size = 72,766 bytes
I 35 pages + 1,086 bytes
I Internal fragmentation 0f 2,048 i 1 ,086 = 962 bytes
I Worst case fragmentation = 1 frame — 1 byte
I On average fragmentation = 1 [2 frame size
I So small frame sizes desirable?
I But each page table entry takes memory lo track
I Page sizes growing over time
' Solaris supports twp page sizes e 8 KB and 4 MB
. Windows on x86/x64 supports two page sizes — 4 KB and 4 MB
Wm,5,...MMMWAMGM m “imam-vi““minim”

***************Ending Page***************

***************Beginning Page***************
***************page number:29**************
W Free Frames
hoe-Iran‘: lxsl ﬁes-frame ||s1
14 15
.3 .3 ‘3
18
20 14 u
15
- ‘5 - '5
m0 0 1s w o 1s
m. 1 w 1
W0 Z l7 W Z 17
w 9 w a
‘ ' ' ’ 18 ’ ' ' 18
19 n m 19
1 [k]
20 2 [E 20
3 EH
21 nw-prwisi pm 1am 21
Ill lb)
Belore allocation After allocalion H

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
y‘
‘W Implementatlon of Page Table
I Page table is kept in main memory
. Page-table base register (PTBR) points t0 the page table
. Page-table length register (PTLR) indicates the size of the
page table
I In this scheme every data/instruction access requires two memory
awesses
. One icr the page table and one for the data / instruction
I The two memory access problem can be solved by the use 0f a
special fast-lockup hardware cache called translation look-aside
buffers (TLBs) (also called associative memory).
Wm, 5"..." “We raw a.“ g an Siam-a W“ m a‘; my.

***************Ending Page***************

***************Beginning Page***************
***************page number:31**************
t‘
W Translatlon Look-Aslde Buffer
I Some TLBs store address-space identiﬁers (ASIDs) in each
TLB entry — these uniquely identifies each process io provide
address-space protection for that process
' Otherwise need to ﬂush at every context switch
I TLBs typically small (64 to 1,024 entries)
I On a TLB miss, value is loaded into the TLB for faster access
next time
' Replacemeni policies musi be considered
' Some entries can be wired down for permanent fast access
om".5,...MWMW7WGW sat “mum-m“minim.

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
qfr Hardwa re
I Associative memory i parallel search
Page a: Frame x
I Address translation (p, d)
i ll p is in associative register, get frame # out
' Otherwise get frame # from page table in memory
Wm", sh"... Cum,“ 7 w Wm s a: sllhmmu. Bllvln "a an". mu

***************Ending Page***************

***************Beginning Page***************
***************page number:33**************
*4}; Paglng Hardware Wlth TLB
Wm.
mm
page m
"--
___
.—— Tmml my,“
__
:—— addvess
I'—— nu
m
p{E
m.“
-
E WSW
W»,
mm»

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
r‘
W Effective Access Time
I :litéaiio — percentage oi times that a page number is found in the
I An 80% hil ratio means lhal we ﬁnd lhe desired page number in
the TLB 80% of the time
I Suppose that 10 nanoseconds to access memory
t Ii we ﬁnd the desired page in TLB then a mapped-memory
access take 10 ns
t Otherwise we need two memory access so it is 20 ns
I Effective Access Time (EAT)
EAT 1 0.80 x 10 + 0.20 x 2U = 12 nanoseconds,
implying 20% slowdown in access time
I Consider a more realisiic hit ratio 0199%,
EAT = 0.99 X10 + 0.01 X 20 =10.1nS.
implying only 1% slowdown in access time!
Wm,mamamxmiqmm w Slim-e “MMHNNJW.

***************Ending Page***************

***************Beginning Page***************
***************page number:35**************
r‘
‘43$; Memory Protectlon
I Memory protection implemented by associating protection bit
with each irarne t0 indicate if read-Only 0r read-write access is
allowed
' Can also add more tails to indicale page execute-only, and
so on
I Valid-invalid bit attached to each entry in the page table:
° “valid” indicates that the associated page is in the process‘
logical address space, and is thus a legal page
° “invalid” indicates that the page is not in the process‘ logical
address space
° Or use page-table length register (FTLR)
I Any violations result in a trap to the kernel
Wm, 5"..." “We w a.“ g as Slim-e W“ m W“. W.

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
Mfr Valid (v) or Invalid (i) Bit ln A Page Table
"-
'-
=|=u
000w lumn mmbw ‘MB-1m.“ bil
m an 4m
m an ‘m
m a: 5-
m gg s-
m! BE 1m
121223“ M...» "m
“m
n
M
Wmmﬂhummwi'mm m 5mm.‘ BMW-mm

***************Ending Page***************

***************Beginning Page***************
***************page number:37**************
t‘
MW S hared Pages
I Shared code
' One copy of read-only (reentrant) code shared among
processes (i.e., lexl editors, compilers, window systems)
' Similar to multiple threads sharing the same process
space
' Also useful for interprocess communication ii‘ sharing of
read-write pages is allowed
I Private code and data
' Each process keeps a separate copy 01 the code and data
' The pages for the pnvate code and data can appear
anywhere in the logical address space
OM",mummmmqmm n1 “imam-vi““Mimi

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
“W; Shared Pages Example
E a "-
m n
m '-
— "2?." HI n =m
WM, m u n

BI s-
m m mm ‘u
m E h" ‘-
m ' --
ll MW

***************Ending Page***************

***************Beginning Page***************
***************page number:39**************
A
‘43$’ Structure of the Page Table
I Memory structures for paging can get huge using slraighl-lorwald
methods
' Consider a 32-h“ logical address space as 0n modern
compulers
I Page size 0M KB (2w)
I Page iabie wouid have 1 million ermies (212/21)
. If each emry is 4 bytes -) each process needs 4 MB cl
physical address spacefur the page lable aiene
> Don'l wanl lo allocate lhatoonliguously in main memory
' one simple SONAR)" i5 to divide the page lable into smaller
unils
v Hierarchicai Paging
' Hashed Page Tables
> Inverted Page Tables

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
W Hierarchical Page Tables
I Break up me logIcal address space Into multiple page tables
I A simple technique is a two-level page (able
I We men page the page table

“ -
ul n
m -
_ > I
‘E'- -
I
El
— 7°'-
ﬂ > I
m ‘a
M-aa. n

***************Ending Page***************

***************Beginning Page***************
***************page number:41**************
y‘
W Two-Level Pagmg Example
I A logical address (on 32-bit machine with 4K page size) is divided into:
' a page number consisting ol 20 bits
i a page offset consisting of 12 bits
I The page number i5 further divided into:
l a 10-bit outer page number
i a 10-bit inner page number
I Thus, a logical address is as follows:
page number page olfset
1U ID 12
I where p, is an index into the outer page table, and p2 is the
displacement within the page of the inner page table
I Known as forward-mapped page table I
0M",enumemmwemmm 541 “Mme-vi“wee-“km

***************Ending Page***************


***************Beginning Page***************
***************page number:42**************
my‘? Address-Translation Scheme
logicmaddress
BIIZIIEI
“{-
- P2 -
pageol —
paw“, -

***************Ending Page***************

***************Beginning Page***************
***************page number:43**************
A
W 64-blt Loglcal Address Space
I Even two-level paging scheme not sufficient
I If page size is 4 KB (2v)
. Then page table has 25? entries
° If two level scheme, inner page tables could be 2m 4-byte entries
' Address would look like
outer page inner page oﬂset
42 to l2
i Outer page table has 2‘2 entries or 2M bytes
o One solution is to add a 2m outer page table
' But in the following example lhe 2'»1 outer page table is still 234
bytes in size
> And possibly 4 memory access to gel to one physical memory
location A
om“. 5"..." Ema.’ w mm an Slum-a W“ m a“; my.

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
“)Fr Three-level Paging Scheme
outer page inner page offset
u-u
42 10 12
2nd outer page outer page inner page oiisei
u“.-
32 10 1U 12
' Windows on Itanium used a three-level paging scheme
~ Windows on x64 use a four—|eve| paging scheme
om.",=,...mc.,wmmm .4. mmmm“minim.

***************Ending Page***************

***************Beginning Page***************
***************page number:45**************
r‘
W Hashed Page Tables
I Common in address spaces > 32 bits
I The virtual page number is hashed into a page table
' This page table contains a chain of elements hashing to the same
location
I Each element contains: (1) the virtual page number: (2) the value of the
mapped page irarne; (3) a pointer l0 the next element,
I Virtual page numbers are compared in this chain searching for a match
' If a match is found, the corresponding physical lrarne i5 extracted
I Variation for 64-bit addresses is clustered page tables
' Similar to hashed but each entry refers to several pages (such as
1s) rather than 1
. Especially useful tor sparse address spaces (Where memory
references are non-contiguous and scattered)
om",“amamumiamm 945 sum-a “laudawiw.

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
q}; Hashed Page Table
physical
logmal address address
nu III!
‘ “ah I physwal
\mém I mum-Twig“ memw
hashiable

***************Ending Page***************

***************Beginning Page***************
***************page number:47**************
r‘
W Inverted Page Table
I Rather than each process having a page table and keeping track of
all possible logical pages, track all physical pages
I One entry for each real page of memory
I Entry consists of the virtual address of the page stored in that real
memory location, with information aboul lhe process lhal owns lhal
page
I Decreases memory needed to store each page table, but increases
time needed to search the table when a page reference occurs
I Use hash table to limit the search to one — or at most a few —
page-table entries
' TLB can accelerate access
I But how to implement shared memory?
' One mapping of a virtual address to the shared physical address
Wm,WWWHWW 941 “imam-m“minim.

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
I “5?; Inverted Page Table Architecture
$22222 pggm'
mun nu a mg‘
mu
I pagevame

***************Ending Page***************

***************Beginning Page***************
***************page number:49**************
r‘
“W Oracle SPARC Solarls
I Consider modern, 64-bii operaiing sysiem example with tightly
integrated HW
° Gpals are efficiency, low overhead
I Based on hashing, but more complex
I Two hash tables
. One kernel and one for a|| user processes
' Each maps memory addresses from virtual to physical memory
. Each eniry represents a contiguous area of mapped virtual
memory,
> More eflicienl lhan having a separate hash-table eniry for
each page
. Each entry has base address and span (indicating the number
of pages ihe eniry represents)
om",snumcumamiemdm us Silhvmh-u. elm-"455%,"

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
r‘
“W Oracle SPARC Solarls (Cont)
I TLB holds translation table entries (TTEs) for fast hardware lookups
' A cache of ‘I'I'Es reside in a translation storage buffer (TSB)
> Includes an entry per recently accessed page
I Virtual address reierence causes TLB Search
° If miss, hardware walks the in-memory TSB looking tor the TTE
corresponding to the address
> If match found, the CPU oopies the TSB entry into the TLB
and translation compieles
> If no match found, kernel interrupted to search the hash table
a The kernel then creates a TTE from lhe appropriate hash
table and stores it in the TSB, Interrupt handler returns
oontrol to the MMU, which compietes the address
translation.
om", 5"..." Emmi“ m» am g so Siam-a W“ m a‘; W.

***************Ending Page***************

***************Beginning Page***************
***************page number:51**************
t‘ .
egyi Swappl n g
I A process can be swapped temEorarily out oi memory to a
backing store, and then brought ack into memory for
continued execution
' Total physical memory space oi processes can exceed
physical memory
I Backing store — fast disk large enough to accommodate
copies of all memory images or all users; must provide
direct access to these memory images
I Rull out, roll in - swapping variant used for priority-based
scheduling algorithms; lower-priority process l5 swapped out
so higher»priority process can be loaded and executed
I Major part of swap time is transfer time; total transfer time is
directly proportional to the amount of memory swapped
I System maintains a ready queue of ready-to-run processes
which have memory images on disk
om“.Spammmmemdm as! Mamas-m“minim;

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
A
W Swapplng (Cont.)
I Does the swapped out process need lo swap back into the same
physical addresses?
I Depends on address binding method
. Plus consider pending l/O to / from prooess memory space
I Modiﬁed versions of swapping are lound on many systems (i.e_,
UNIX, Linux, and Windows)
0 Swapping normally disabled
' Started il more than threshold amount of memory allocated
° Disabled again onoe memory demand is reduced below
threshold
om".“emamumismdm w Siam-a WMHNNJW.

***************Ending Page***************

***************Beginning Page***************
***************page number:53**************
W Schematlc Vlew of Swapplng
7/ i \\\
QDQVEUHQ \'\ 4
system
O) mp m" process P‘
pvmess PZ
user \\y
“a” backmg slave
m mm,

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
ﬁe
W Context Switch Time including Swapping
I If next processes to be put on CPU is not in memory, need to
swap out a process and swap in target process
I Context switch lime cart lhen be very high
I 100MB process swapping to hard disk with transfer rate of
SOME/Sec
. Swap out time of 2000 ms
i Plus swap in of same sized process
. Total context switch swapping component time ol 4000ms
(4 seconds)
I Can reduce il reduce size oi memory swapped — by knowing
how much memory really being used
. System calls to inform OS of memory use via
request_mem0ry(l and release_mert\oryl)
Wm.Synmmmprmm 954 “hm-m WWNNJW.

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
~
‘W Context Switch Time and Swapping (Cont.)
I Other constraints as well on swapping
' Pending l/O — can't swap out as l/O would occur i0 wrong
process
' 0r always transfer l/O to kernel space, then to l/O device
> Known as double buffering, adds overhead
I Standard swapping not used in modern operating systems
. But modiﬁed version common
> Swap only when free memory extremely low
Wm,“amammwsmﬂm as! illhvuzh-msulvlnnude-“£82m:

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
ﬁe
W Swapping on Mobile Systems
I Not typically supported
. Flash memory based
> Small amount of space
t Limited number of wrlte cycles
> Poor throughput between ﬂash memory and CPU on mobile
platlorm
I Instead use other methods to free memory il low
. iOS asks apps l0 voluntarily relinquish allocated memory
> Read-only data thrown out and reloaded from ﬂash il needed
t Failure to free can result in termination
. Android terminates apps if low free memory, but first writes
application state to ﬂash for fast restart
. Both OSes support paging as discussed below
Wm,5y....nc.m.,,\.sm.,.m use Momma-m“minim.

***************Ending Page***************

***************Beginning Page***************
***************page number:57**************
Mfr Swapping with Paging
-
— -
wmess pageant a 1 z 3
A a” I] I] I] I]
% BB QDIDUIIU
VJ” IZDIQDUUISD
IGUWIIIBWII
Process W’, pigem
B I A mmz'mnmnu
I.
% baikingﬂove
main
MW

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
Mgr Example: The Intel 32 and 64-bit Architectures
I Dominant industry chips
I Pentium CPUs are 32-bit and called lA-32 architecture
I Current Intel CPUS are 64-bit and Called lA-64 architecture
I Many variations in the chips, cover the main ideas here
0mm, sh"... Cum,“ 7 w mm s s: Sllhvmnlu. Bllvin m m". em

***************Ending Page***************

***************Beginning Page***************
***************page number:59**************
~
we?) Example: The Intel lA-32 Architecture
I Supports both segmentation and segmentation with paging
. Each segment can be 4 GB
Q Up lo 16 K segmenls per process
° Divided into two partitions
> First partition pl up to 8 K segments are private to
process (kept in local descriptor table (LDT))
> Second panilion ol up to 8K segments shared among all
processes (kept in global descriptor table (GDT))
em.".=,i..mem.mewmm esa Sllhvuzh-msulvinnude-“£82m:

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
M Example: The Intel lA-32 Architecture (Cont.)
I CPU generates logical address
. SeleClDr given (D segmentation unit
> Which produces linear addresses
I n r
If! r 2
° Linear address given i0 paging unil
> Which generates physical address in main memory
> Paging units form equivalent of MMU
> Pages sizes can be 4 KB or 4 MB
OM",mummmmmmmm m “mam-m“la-“RM

***************Ending Page***************

***************Beginning Page***************
***************page number:61**************
W Logical to Physical Address Translation in lA-32
\oglcm hneal physlcal
addvass address mm address
UH" um! MMDIY
page number page oﬂsel
——-
10 1O 1 2
0mm, sh“... CW,“ 7 w Wm . n 5mm.‘ BuMn m Glilll mu

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
“ﬂy; lntel lA-32 Segmentation
logicaiaddress selector
descrlptor tabie
seg men! descrlptor o
32-bii linear address

***************Ending Page***************

***************Beginning Page***************
***************page number:63**************
My’; Intel lA-32 Paging Architecture
"malaemwﬂ
"mm Wu». m
‘ W. w
MW
mm, 9.9.
WWW M

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
“ﬂy Intel lA-32 Page Address Extensions
I 32-bit address limits led irriel m create page address exiensidn (PAE),
allowing 32-bit apps aeeess m more than 4GB of memory space
' Paging weni l0 a 3-level scheme
° Top Mu bits referm a page dire-scary ppimenaple
° Page-direclory and page-cable entries moved w 64-bits in size
. Nei eifecz is increasing address space id as bits e 6465 of physical
memory
me direclory page 1m smer
3‘ ﬂ
- - -
- - - m
- Base
CR3 -
‘we’ page dwwwy page we
Pmmeilable dlieclnry iapie A
em“, sh..." “mania ea.“ s 54 Sllhvuzhu. We “a Glinlﬁﬂil

***************Ending Page***************

***************Beginning Page***************
***************page number:65**************
A
W Intel x86-64
I Current generation lniel x86 architecture
I 64 bits is ginormous (> 1e exabytes)
I In practice only implement 48 bii addressing
' Page sizes 0M KB, 2 MB,1GB
. Four levels of paging hierarchy
I Can also use PAE so virtual addresses are 48 bits and physical
addresses are 52 bits
page map page dlreciory page page
unused level 4 poinler (able dlreciory table alisel
63 4B 47 39 38 3O 29 21 20 12 ll (I
0pm", Syn-m Cam,“ e w ea.“ s vs sllhmenlu. Bllvln "a em. em

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
~
“W Example: ARM Archltecture
I Domlnam momle pmmum chip
(Apple ios and Google Andvoid 11p“
devices m: examme) }—{
I Modem‘ energy emmem, azpn WW’ ‘Wm’ ‘M
CPU
I 4 KB and 15 KB pages - “I
I 1 MB and we MB pages (termed - “3G
sections) - - W
I One-lave‘ paging lor sections. m- -
\evel lar smaHer pages
I TWD IEVQS 0' TLBS - HA!
. Outer \EVE‘ has \WCI II'HCM 1W!
TLBs (one data, one m
msiruclion)
' Inner \s smg\e mam TLB
. Firsl ilmef iS checked, I)"
miSS DUlEIS are CHBCde,
and on mlss page (able
wak peﬂnrmsd py cpu
Wm, m... “"5.me mm , se mm.‘ W“ m mum“

***************Ending Page***************

***************Beginning Page***************
***************page number:67**************
End of Chapter 9
—

***************Ending Page***************

