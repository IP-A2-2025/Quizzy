***************Beginning Page***************
***************page number:1**************
Practicé SGBD

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
http://use-the-index-Iuke.com/
SQL \
PERFORMANCE

***************Ending Page***************


***************Beginning Page***************
***************page number:3**************
Performanta - Volumul de date
00,”
The , aS/faDB
V I/e been kjoto he/p Yo
W” to drag move fUr
tab/es“ nitUre_

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Volumul de date

' O interogare devine mai lenta cu cat sunt mai
multe date Tn baza de date

' Cat de mare este impactul asupra
performantei daca volumul datelor se
dubleaza ?

' Cum putem Tmbunatati ?

***************Ending Page***************


***************Beginning Page***************
***************page number:5**************
Volumul de date

' lnterogarea analizata:

SELECT count (*) FROM scale_data
WHERE section = ? AND id2 = ?

' Section are rolul de a controla volumul de
date. Cu cat este mai mare section, cu atat
este mai mare volumul de date returnat.

' Consideram doi indec$iz index1$i index2

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Volumul de date
' lnterogarea analizaté:
SELECT count (*) FROM scale_data
WHERE section = '? AND id2 = '?
' Section mic —index1$iapoi indexZ
0-10 Perfurmance 0-10
E 0-00 0-00 E
E 0-00 0-00 E
E 0.04 0.04 E
0 0
g 0.02 0.02 g
EL’ EC
III-CID Iii-CID
fast slnw
0.0295 [1.0555 6

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
Volumul de date
' Scalabilitatea indicé dependenta performantei
Tn functie de factori precum volumul de
informatii.
1-2 Ecalahility by Data volume ‘Elﬂw — fﬂﬂt —-— _ 1-2
E 1-0 1-0 E
E IlB llB g
g 0-5: r16 EH
g [1-4 r14 g
E 0-2 0-2 E
EL’ II
0-0 0-0
u 2:: m1 an an mu
Data. volume [secti-un]

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Volumul de date

' indexl — timp dublu fata de cel initial

' indexZ — trimp x20 fata de cel initial

1E Eaalahility by Data ‘ifaluma ‘slaw — faﬂt —-— _ 1E
g 1-D 1a g
E Ila llB E
g aa ila 5g
E 0-4 r14 E
E aa 0-2 a
EL’ EL’

an [Li]

a a: an aa aa iaa
Data. valuma [aaatian]
8

***************Ending Page***************


***************Beginning Page***************
***************page number:9**************
Volumul de date

' Réspunsul unei interogéri depinde de mai
multi factori. Volumul de date e unul dintre ei.

' Dacé o interogare merge bine Tn faza de test,
nu e neapérat ca ea sé functioneze bine $i Tn
productie.

' Care este motivul pentru care apare diferenta
dintreindex1$i indexZ ?

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Ambele par Identlce ca executle:
| Id | Operation | Name | Rows | Cost |
| G | SELECT STATEMENT | | 1 | 972 |
| 1 | SORT AGGREGATE | | 1 | |
|* 2 | INDEX RANGE SGAN| scALE_SLON | SGGG | 972 |
| Id Operation | Name | Rows | Cost |
| e | SELECT STATENENT | | 1 | 13 |
| 1 | SORT AGGREGATE | | 1 | |
|* 2 | INDEX RANGE SGAN| scALE_FAST | SGGG | 13 |
10

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
Volumul de date

' Ce influenteazéi un index ?
> table acces
> scanarea unui interval mare

' Nici unul din planuri nu indicéi acces pe baza
indexului (TABLE ACCES BY INDEX ROW ID)

' Unul din intervale este mai mare atunci cand e
parcurs.... trebuie séi avem acces Ia "predicate
information" ca séi vedem de ce:

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
| Id | Operation | Name | Hows | CoSt |
| G | SELECT STATEMENT | | 1 | 972 |
| 1 | SGRT AGGREGATE | | 1 | |
|* 2 | INDEX RANGE SGAR| SGALE_SLow | SGGG | 972 |
Predicate Information (identified by operation id):
2 — acoeSS("SECTION"=T0_NUMBEH(:A))
filter("IDZ"=T0_HUHBER(:B))
12

***************Ending Page***************


***************Beginning Page***************
***************page number:13**************
| Id Operation | Name | Hows | Coat |
| G | SELECT STATENENT | | 1 | 13 |
| 1 | SGRT AGGREGATE | | 1 | |
|* 2 | INDEX RANGE SGAN| SGALE_FAST | SGGG | 13 |
Predicate Information (identified by operation id):
2 - access("SEGTIGN"=TG_NUNSER(:A) ANo "Ioz"=To_NUNSER(:S))
13

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
Volumul de date
' Puteti spune cum a fost construit indexul
avénd planurile de executie ?

***************Ending Page***************


***************Beginning Page***************
***************page number:15**************
Volumul de date
' Puteti spune cum a fost construit indexul
avénd planurile de executie ?
' CREATE INDEX scale_slow ON
scale_data (section, idl , id2) ;
' CREATE INDEX scale_fast ON
scale_data (section, id2 , idl) ;
Campul idl este adaugat doar pentru a pastra
aceeasi dimensiune (sa nu se creada ca indexul
scale_fast e mai rapid pentru ca are mai putine
campuri in el). 15

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
lncarcarea SlStemU|Ul
' Faptul ca am definit un index pe care TI
considerém bun pentru interogérile noastre
nu TI face sé fie neapérat folosit de Q0.
' SQL Server Management Studio-
oar ca un tooltlp
_';'-;| Messages 2'“ Execution plan |
Query 1: Query CD51; (relative tn the batch]: llIlElE's
DECLARE @sec numeric: DECLARE EiEiE numeric: SELECT cauntﬁ]...
+
l6

***************Ending Page***************


***************Beginning Page***************
***************page number:17**************
lncarcarea SlStemU|Ul

' De regulé, Tmpreuné cu numérul de
anegistréri, cre$te $i numérul de acceséri.

' Numérul de accesari este alt parametru ce
intré Tn calculul scalabilitétii.

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
lncarcarea SlStGmU|Ul
' Dacéi initial era doar o singuréi accesare,
considerénd ace|a$i scenariu dar cu 1-25
interogéiri concurente, timpul de raspuns
cre$tez
_5l|::|w ——— faat — _
‘F 3E! #_H_ EFF-P“ BU E
E 25 If! 5 25 E
E EH ,FJPH’ E“ E
E 15 I?!’ 15 E
E 1n {if "3* E
El _———— U‘
El 5 1l'_'|I 15 Elli 25
Luaﬁ [mncurrent queries] 18

***************Ending Page***************


***************Beginning Page***************
***************page number:19**************
lncércarea sistemului

' Asta Tnseamné c5 $i dacé avem toata baza de
date din productie $i testém totul pe ea, tot
sunt $anse ca Tn realitate, din cauza numérului
mare de interogéri, sé meargé mult mai greu.

' Noté: atentia daté planului de executie este
mai importanté decét benchamarkuri
SU perficia Ie (gen SQL Server Management Studio).

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
lncércarea sistemului

' Ne-am putea a$tepta ca hardwareul mai puternic
din productie $5 ducé mai bine sistemul. In fapt,
Tn faza de development nu existé deloc latenté —
ceea ce nu se Tntémplé Tn productie (unde accesul
poate fi Tntérziat din cauza retelei).

' httgzﬂblogfata|mind.com[2009[12[22[|atency-
security-vs-Qerformancez

' httgzmamesgolick.com[2010[10[27[we-are-
exgeriencing-too-much-Ioad-Iets-add-a-new-
server..htm|

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
Timpi de raspuns + throughput

' Hardware mai performant nu este mai rapid
doar poate duce mai multa incarcare.

' Procesoarele single-core vs procesoarele
multi-core (cand e vorba de un singur task).

' Scalarea pe orizontala (adaugarea de
procesoare) are ace|a$i efect.

' Pentru a Tmbunatati timpul de raspuns este
necesar un arbore eficient (chiar 5i Tn NoSQL).

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Timpl de réspuns

' Indexa rea corectéi fac céiuta rea intr-un B-tree in
timp logaritmic.

' Sistemele bazate pe NoSQL par sé fi rezolvat
problema performantei prin scalare pe orizontaléi
[

].

' Aceastéi scalabilitate este totu§i limitatéi la
operatiile de scriere intr-un model denumit
"eventual consistency” [Consistency / Availability
/ Partition tolerance = CAP theorem]
httgﬂen.WikigediaorgZWikiZCAP theorem

***************Ending Page***************


***************Beginning Page***************
***************page number:23**************
Timpi de réspuns

' IVIai mult hardware de obicei nu
Tmbunététe$te sistemul.

' Latency al HDD [problema apare cand datele
sunt culese din locatii diferite ale HDDqui — de
exemplu Tn cadrul unei operatii JOIN]. SSD?

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
“Facts”
' Performance has two dimensions: response

time and throughput.
' More hardware will typically not improve

query response time.
' Proper indexing is the best way to improve

query response time.

I

***************Ending Page***************


***************Beginning Page***************
***************page number:25**************
Join

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Jom
An SQL query walks into o bor and sees two tables.
He walks up to them and asks ’Con I join you?’
— Source: Unknown
' Join-ultransformé datele dintr-un model
normalizat Tntr-unul denormalizat care
serve$te unui anumit scop.
' Sensibil Ia latente ale discului (5i fragmentare).

***************Ending Page***************


***************Beginning Page***************
***************page number:27**************
Join

' Reducerea timpilor = indexarea corecta @

' Toti algoritmii de join proceseazé doar doué
tabele simultan (apoi rezultatul cu a treia, etc).

' Rezultatele de la un join sunt pasate Tn
urmétoarea operatie join féré a fi stocate.

' Ordinea Tn care se efectueazé JOIN-ul
influenteazé viteza de réspuns.[10, 30, 5, 60]

' Q0 Tncearcé toate permutérile de JOIN.

' Cu cét sunt mai multe tabele, cu atét mai multe
planuri de evaluat. [céte ?]

***************Ending Page***************

***************Beginning Page***************
***************page number:28**************
Jom

' Cu cét sunt mai multe tabele, cu atét mai
multe planuri de evaluat = n!

' Nu este 0 problemé cénd sunt utilizati
parametri dinamici [De ce ?]

' Nested Loops

' HashJoins

' MergedJoins

***************Ending Page***************


***************Beginning Page***************
***************page number:29**************
Join — Nested Loops (anti patern) f

' Ca si cum ar fi doué interogéri: cea exterioaré
pentru a obtine o serie de rezultate dintr-o
tabelé si cea interioaré ce preia fiecare rénd
obtinut si apoi informatia corespondenté din
cea de-a doua tabelé.

' Se pot folosi Nested Selects pentru a simula
algoritmul de nested loops [Iatenta retelei,
usurinta implementérii, Object-relational
mapping (N+1 selects)].

***************Ending Page***************

***************Beginning Page***************
***************page number:30**************
Studiu de caz...
select scholarship from
fg join students on
fg.lnamea=students.lname
where fg.lnamea like 'A%';
' Care credeti c5 va fi tabela interioaré si care
cea exterioaré ?

***************Ending Page***************


***************Beginning Page***************
***************page number:31**************
Studiu de caz...
select scholarship from
fg join students on
fg.lnamea=students.lname
where fg.lnamea like 'A%';
' fg — cea exterioaré pentru c5 "speré" ca dupé
filtrare sé aibé putine rénduri (cu Iname like
' students — cea interioaré

***************Ending Page***************

***************Beginning Page***************
***************page number:32**************
I Uf U A o 0 p
Ce a ege sa aca cand nu sunt IndecSl .
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| 8 | SELECT STATEMENT | | 283 | 8773 | 13458 (1)|
|* 1 | HASH JOIN_ | | 283 | 8773 | 1 : (1)|
|* 2 | TABLE ACCESS FULL| STUDENTS | 27 | 594 | 5 (8)|
|* 3 | TABLE ACCESS FULLI FG | 544 | 4896 | 13452 (1)|
Predicate Information (identified by operation id):
1 - access("FG"."LNAMEA"="STUDENTS"."LNAME")
2 - filter("STUDENTS"."LNAME" LIKE 'A%')
3 - filter("FG"."LNAMEA" LIKE 'A%')

***************Ending Page***************


***************Beginning Page***************
***************page number:33**************
Putem forta tipul joinului:
select /* hint */sch01arship from
fg join students on
fg.1namea=students.lname
where fg.1namea like 'A%';
' Hint:
+ USE_N L(students fg) - nested loops
+ use_hash — hash joins
+ use_merge(fg,students) para||e|(fg, 4)
para||e|(students, 4) — merge joins 33

***************Ending Page***************

***************Beginning Page***************
***************page number:34**************
Nested loops fortat (iese mai rau):

| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| 8 | SELECT STATEMENT | | 283 | 8773 | 15375 (1)|
| 1 | NESTED LO0PS_ | | 283 | 8773 | 15375 (1) |
|* 2 | TABLE ACCESS FULLI FG | 544 | 4896 | 13452 (1)|
|* 3 | TABLE ACCESS FULL| STUDENTS | 1 | 22 | 4 (8)|
Predicate Information (identified by operation id):
|

2 - filter("FG"."LNAMEA" LIKE 'A%')

3 - filter("STUDENTS"."LNAME" LIKE 'A%' AND

"FG"."LNAMEA"="STUDENTS"."LNAME")
INTERESANT: filtrul LIKE ’A%' a fost pus peste fg.lnamea — puteti observa cum il
aplica si in students (cand ii cauta pe cei care se “potrivesc”) 34

***************Ending Page***************


***************Beginning Page***************
***************page number:35**************
Cum ati construi indecsii ?

' $tiind cum functioneazé nested loops, indexul
firesc este Tn tabela din LOOP-ul interior, pe
cémpul peste care se face join-ul.

' Din cauzé c5 students era tabela interioaré, sé
facem indexul peste students.|name:

create index idx_students_1name on
students(1name);

***************Ending Page***************

***************Beginning Page***************
***************page number:36**************
| Id | Operation | Name | Rows | Bytes | Cost (%
| 8 | SELECT STATEMENT | | 283 | 8773 14548
| 1 | NESTED LOOPS | | |
| 2 | NESTED LOOPS | | 283 | 8773 | 14548
|* 3 | TABLE ACCESS FULL | FG | 544 | 4896 | 13452
|* 4 | INDEX RANGE SCAN | IDx_STUDENTS_LNAME | 1 | | 1
| 5 | TABLE ACCESS BY INDEX RONID| STUDENTS | 1 | 22 | 2
Predicate Information (identified by operation id):
3 - filter("FG"."LNAMEA" LIKE 'A%')
4 - acceSS("FG"."LNAMEA"="STUDENTS"."LNAME")
filter("STUDENTS"."LNAME" LIKE 'A%')
Se foloseste indexul ca sa gaseasca studentii — si se vede ca se face access pe
criteriul de join; filtrul este peste like... [costul totusi e 14.5k ® ] 36

***************Ending Page***************


***************Beginning Page***************
***************page number:37**************
| Id | Operation | e | Rows | Bytes | Cost (%
| o | SELECT STATEMENT | | 283 | 8773 | 14540
| 1 | NESTED LOOPS | | |
| 2 | NESTED LOOPS | - 8773 | 14548
|* 3 | TABLE ACCESS FULL | FG 4896 | 13452
|* 4 | INDEX RANGE SCAN | IDX_S UDENTS_LNAME | 1
| 5 | TABLE ACCESS BY INDEX RowID| STUDENTS | 1 | 22 | 2
Predicate Information (identified by operation id): EStlmare
3 - filter("FG"."LNAMEA" LIKE 'A%')
4 - access("FG"."LNAMEA"="STUDENTS"."
filter("STUDENTS"."LNAME" LIKE '
SQL> select count(*) from fg where lnamea like 'A%';
COUNT(*)
_ _ _ _ _ _ _ _ _ _ In fapt I-ar ajuta foarte mult ca din cele
_ 5M linii din fg sa ajunga rapid Ia cele
133504 Reahtate 133k pe care Ie doreste.

***************Ending Page***************

***************Beginning Page***************
***************page number:38**************
Atunci cénd avem nested loops:

' lndexati criteriul dupé care se face joinul din
tabela interioaré. Dacé veti indexa 5i ceva Tn
tabela exterioaré (pentru a face mai rapid
accesul Ia liniile dorite, va fi perfect).

' Tn cazul de fate ar fi interesant sé facem acces
acolo unde este Inamea.

' Se poate schimba ordinea tabelelor Ia faza
asta... cea interioaré sé deviné exterioaré...

***************Ending Page***************


***************Beginning Page***************
***************page number:39**************
Sé-I ajutém a§adar....
create index idx_join_fg
on fg(1namea);

***************Ending Page***************

***************Beginning Page***************
***************page number:40**************
| Id | Operation | Name | Rows | Bytes | CoSt (%
| 8 | SELECT STATEMENT | | 283 | 8773 1825
| 1 | NESTED LOOPS | | 283 | 8773 1825
| 2 | TABLE ACCESS BY INDEX RDNID| STUDENTS | 27 | 594 | 4
|* 3 | INDEX RANGE SCAN | IDX_STUDENTS_LANME | 9 | | 2
|* 4 | INDEX RANGE SCAN | IDX_JOIN_FG | 18 | 98 | 38
Predicate Information (identified by operation id):
3 - acceSS("STUDENTS"."LNAME" LIKE 'A%')
filter("STUDENTS"."LNAME" LIKE 'A%')
4 - acceSS("STUDENTS"."LNAME"="FG"."LNAMEA")
filter("FG"."LNAMEA" LIKE 'A%')
40

***************Ending Page***************


***************Beginning Page***************
***************page number:41**************
Atunci cénd avem nested loops:

' Dacéi veti indexa criteriul exterior (dinafara
joinului), aveti §anse sé scédeti foarte mult
timpul operatiei join.

' HOWEVER, cénd sunt utilizate joinurile de
tipul nested loops, intotdeauna puneti index
pe criteriul de selectie din tabela interioaréi

***************Ending Page***************

***************Beginning Page***************
***************page number:42**************
Join — Cu doctrine putem vedea ce se
intémpla de fapt Ia nivel de cereri BD:
Doctrine
Only on source code level—don’t forget to dissble this for
production- Consider building your own conﬁgurable logger-
$1ogger = new \DoctrineRDBAL\LoggingREchoSqlLogger;
$config->set5QLLogger($logger);

***************Ending Page***************


***************Beginning Page***************
***************page number:43**************
Joln — Ce fac un|| "programatorl"...
$qb = $em->creeteQuePyBuildeP();
$qb-eselect('e')

—>Frem('Empleyees', 'e')
—>where("upper(e.1est_nsme) like :1est_nsme")
->setFePemeteP(‘lest_neme', ‘WIN%');
$P = $qb->getQuePy()->getHesult();
Fereech ($P ss $Pew) {
if process Employee
Fereech ($Pew—}get5eles() es $sele) {
if process Sale Fer Employee
1'
1'

***************Ending Page***************

***************Beginning Page***************
***************page number:44**************
Joln — Ce se Intampla In spate...
Deeirine 2-0-5 generates N+1 select queries:
SELECT eB_.empluyee_id AS employee_idO —— MORE COLUMNS
FROM employees eO_
NHEHE UPPER(eB_.1ast_name) LIKE P
SELECT tO.SalE_id MS SMLE_IO1 —— MORE COLUMNS
FROM sales tB
NHEHE tB.subsidiaPy_id = P
ANO tB.empluyee_id = P
SELECT tB.5F.|le_id MS SMLE_IO1 —— MORE COLUMNS
FROM sales tB
NHERE tB.subsidiaPy_id = P
ANO tB.empluyee_id = P
44

***************Ending Page***************


***************Beginning Page***************
***************page number:45**************
PRO TIP

' Daca aveti de facut nested loops, nu o faceti Tn
aplicatia PHP / Java / orice altceva... Faceti-o
direct Tn serverul de baze de date:

-Tn BD nu avem latenta din retea;

- Tn BD nu sunt transferate datele intermediare
(care sunt piped Tn BD);

- ORIVI-urile de obicei nu fac JOINuriIe Tn BD ®
(ci |e fac prin nested loops Tn interiorul app).

***************Ending Page***************

***************Beginning Page***************
***************page number:46**************
Join — nested selects

' eagerfetching — poate face un join automat
pentru a-mi da direct toate informatiile
(denormalizare)

' Totu$i eagerfetching nu este bun atunci cénd
este nevoie doar de informatii dintr-o tabelé.

' O configurare staticé (Tn genul celor eager) nu
este mereu 0 solutie buné.

' Cele mai multe ORIVI permit SQLjoins:

***************Ending Page***************


***************Beginning Page***************
***************page number:47**************
$qb = $em—>cPesteQueryBuilder();
$qb-sse1eet('e,s')
—§frem('Empleyees', 'e')
-}1eFtJein{'e.ss1es', 's'}
—>where("upper(e.1sst_nsme) like :1sst_nsme")
—>sethPsmeter('1sst_nsme', ‘WIﬂﬁ'J;
$r = $qb—>getQuery()—>getHesult();
Deetrine 21.1-5 generates the fellewitlg SQL statement:
SELECT eB_.empleyee_id AS employee_idﬂ
—— MORE CDLUMNS
FRUM employees eB_
LEFT JDIN sales s1_
DH eB_.subsidisPy_id = s1_.subsidisry_id
AND eE_.empleyee_id = s1_.empleyee_id
WHERE UPPER(eB_.1sst_nsme) LIKE P M

***************Ending Page***************

***************Beginning Page***************
***************page number:48**************
Join — nested selects

' Sunt bune dacé sunt Tntoarse un numér mic de
anegistréri.

' httgzﬂblogfata|mind.com[2009[121221|atenc
y-security-vs-QerformanceZ

***************Ending Page***************


***************Beginning Page***************
***************page number:49**************
MR1.
Jom — Hash Jom j:
SQLS er
\7"
' Evitéi traversarea multipla a B-tree din cadrul
inner-querry (din nested loops) construind céte
un hash pentru inregistrérile candidat.
' Dacéi una din tabele este foarte mare, cealaltéi
este incéircatéi in memorie, pe baza ei se
construieste un hash avénd ca si chei cémpurile
utilizate in join si ca valori restul réndului.
' Hash join imbunététit dacé sunt selectate mai
putine coloane.
' A se indexa predicatele independente din Where
pentru a imbunététi eficienta.

***************Ending Page***************

***************Beginning Page***************
***************page number:50**************
A I I I I I I
Avand Indecsn construltl anterlor...
I
| Id | Operation | Name | Rows | Bytes | Cost (%(
| 8 | SELECT STATEMENT | | 283 | 8773 | 127
|* 1 | HASH JOIN | | 283 | 8773 | 127
| 2 | TABLE ACCESS BY INDEX RDNIDI STUDENTS | 27 | 594 | 4
|* 3 | INDEX RANGE SCAN | IDX_STUDENTS_LANME | 9 | | 2
|* 4 | INDEX RANGE SCAN | IDX_JOIN_FG | 544 | 4896 | 122
Predicate Information (identified by operation id):
1 - acceSS("STUDENTS"."LNAME"="FG"."LNAMEA")
3 - acceSS("STUDENTS"."LNAME" LIKE 'A%')
filter("STUDENTS"."LNAME" LIKE 'A%')
4 - acceSS("FG"."LNAMEA" LIKE 'A%')
filter("FG"."LNAMEA" LIKE 'A%')
Am putea crede ca ambii indecsi participa "puternic" Ia realizarea JOIN-ului...
De fapt daca scapam de IDX_STUDENTS_LANI\/|E (sorry for typo)...
50

***************Ending Page***************


***************Beginning Page***************
***************page number:51**************
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| 8 | SELECT STATEMENT | | 283 | 8773 | 128 (1)|
|* 1 | HASH JOIN | | 283 | 8773 | 128 (1)|
|* 2 | TABLE ACCESS FULLI STUDENTS | 27 | 594 | 5 (8)|
|* 3 | INDEX RANGE SCAN | IDX_JOIN_FG | 544 | 4896 | 122 (8)|
Predicate Information (identified by operation id):

1 — access("STUDENTS" . "LNAME"="FG" . "LNAMEA")

2 - filter‘("STUDENTS" . "LNAME" LIKE 'A%')

3 — access("FG"."LNAMEA" LIKE 'A%')

filter("FG"."LNAMEA" LIKE 'A%')
Costul a crescut doar cu (era 127 Si acum este 128). Deci de fapt eficienta vine din
Indexarea conditiilor dinafara joinului.
51

***************Ending Page***************

***************Beginning Page***************
***************page number:52**************
Join — Hash join

' lndexarea predicatelor utilizate ‘in join nu
imbunététesc eficienta hash join !!!

' Un index ce ar putea fi utilizat este peste
fg.|name (care este Tn clauza Where)

***************Ending Page***************


***************Beginning Page***************
***************page number:53**************
Join — Hash join

° Ordinea conditiilor din join nu influenteazé
viteza deoarece oricum Q0 va Tncérca Tn
memorie tabela mai micé 5i Ti va face hash-ul
(Ia nested loops ar fi influentat).

***************Ending Page***************

***************Beginning Page***************
***************page number:54**************
AppliE-Etﬁ-
Join — Sort Merge 59
' Combina doua tabele preluand date fie mvm
dintr-unul, fie din celalalt, fie din ambele. SQLSJW
' Aceia$i indec$i ca 5i Ia hash-join (adica doar
pentru conditiile separate, nu $i pentru cele
din join).
' Ordinea joinurilor nu conteaza.
' Algoritm foarte util pentru outerjoins (in care
sunt intoarse inregistrarile care fac match in
ambele tabele) dar 5i pt L/R joins. .

***************Ending Page***************


***************Beginning Page***************
***************page number:55**************
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| 8 | SELECT STATEMENT | | 283 | 8773 | 128 (1)|
| 1 | MERGE JOIN | | 283 | 8773 | 128 (1)|
|* 2 | INDEX RANGE SCAN | IDX_JOIN_FG | 544 | 4896 | 122 (8)|
|* 3 | SORT JOIN | | 27 | 594 | 6 (17)|
|* 4 | TABLE ACCESS FULLI STUDENTS | 27 | 594 | 5 (8)|
Predicate Information (identified by operation id):
2 — acceSS("FG"."LNAMEA" LIKE 'A%')
filter("FG"."LNAMEA" LIKE 'A%')
3 - acceSS("FG"."LNAMEA"="STUDENTS"."LNAME")
filter("FG"."LNAMEA"="STUDENTS"."LNAME")
4 - filter("STUDENTS"."LNAME" LIKE 'A%')

***************Ending Page***************

***************Beginning Page***************
***************page number:56**************
5i aSa ar aréta fara nici un index

| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Ti
| O | SELECT STATEMENT | | 283 | 8773 | 13459 (1)| 88
| 1 | MERGE JOIN | | 283 | 8773 | 13459 (1)| 88
| 2 | SORT JOIN | | 27 | 594 | 6 (17)| 88
|* 3 | TABLE ACCESS FULLI STUDENTS | 27 | 594 | 5 (O)| OO
|* 4 | SORT JOIN | | 544 | 4896 | 13453 (1)| OO
|* 5 | TABLE ACCESS FULL| FG | 544 | 4896 | 13452 (1)| 88
Predicate Information (identified by operation id):

3 - filter("STUDENTS"."LNAME" LIKE 'A%')

4 - access("FG"."LNAMEA"="STUDENTS"."LNAME")

filter("FG"."LNAMEA"="STUDENTS"."LNAME")
5 - filter("FG"."LNAMEA" LIKE 'A%')

***************Ending Page***************


***************Beginning Page***************
***************page number:57**************
Join — Sort Merge
FULL UUTEH JOIN u§ing smrt-rrerge

***************Ending Page***************

***************Beginning Page***************
***************page number:58**************
5i un plan mai "exotic"

' Pentru:

select /*+ use_mehge(tg,students)
parallel(fg, 4) parallel(students,
4) */ scholarship from
fg full outer join students
on tg.lnamea=students.lname
where fg.lnamea like 'A%';

***************Ending Page***************


***************Beginning Page***************
***************page number:59**************
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time
| 9 | SELECT STATEMENT | | 1569 | 29397 | 26917 (1)| 99:95
| 1 | VIEN | | 1569 | 29397 | 26917 (1)| 99:95
| 2 | UNION-ALL | | | | |
| 3 | MERGE JOIN OUTER | | 544 | 16964 | 13459 (1)| 99:92
| 4 | SORT JOIN | | 544 | 4996 | 13453 (1)| 99:92
|* 5 | TABLE ACCESS FULLI FG | 544 | 4996 | 13452 (1)| 99 92
|* 6 | SORT JOIN | | 27 | 594 | 6 (17)| 99:99
|* 7 | TABLE ACCESS FULL| STUDENTS | 27 | 594 | 5 (9)| 99:99
|* 8 I FILTER | | | | |
|* 9 | HASH JOIN ANTI | | 1925 | 31775 | 13459 (1)| 99:92
| 19 | TABLE ACCESS FULL| STUDENTS | 1925 | 22559 | 5 (9)| 99:99
| 11 | TABLE ACCESS FULL| F6 | 4942K| 41M| 13439 (1)| 99:92
Predicate Information (identified by operation id):

5 - filter("FG"."LNAMEA" LIKE 'A%')

6 - acceSS("FG"."LNAMEA"="STUDENTS"."LNAME"(+))

filter("FG"."LNAMEA"="STUDENTS"."LNAME"(+))

7 - filter("STUDENTS"."LNAME"(+) LIKE 'A%')

9 - filter(NULL LIKE 'A%')

9 - access("FG"."LNAMEA"="STUDENTS"."LNAME")

***************Ending Page***************

***************Beginning Page***************
***************page number:60**************
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time
| 0 | SELECT STATEMENT | | 1569 | 20397 | 2183 (1)| 00:0
| 1 | VIEN | | 1569 | 20397 | 2183 (1)| 00:01
| 2 | UNION-ALL | | | | |
| 3 | MERGE JOIN OUTER | | 544 | 16864 | 127 (1)| 00:01
|* 4 | INDEX RANGE SCAN | IDX2 | 544 | 4896 | 122 (0)| 00:01
|* 5 | SORT JOIN | | 27 | 594 | 5 (20)| 00:01
| 6 | TABLE ACCESS BY INDEX RONID| STUDENTS | 27 | 594 | 4 (0)| 00:01
|* 7 | INDEX RANGE SCAN | IDX1 | 9 | | 2 (0)| 00:01
|* 8 | FILTER | | | | |
| 9 | NESTED LOOPS ANTI | | 1025 | 31775 | 2055 (0)| 00:01
| 10 | TABLE ACCESS FULL | STUDENTS | 1025 | 22550 | 5 (0)| 00:01
|* 11 | INDEX RANGE SCAN | IDX2 | 1 | 9 | 2 (0)| 00:01
Predicate Information (identified by operation id):
Aiciau fost
4 - acceSS("FG"."LNAMEA" LIKE 'A%') . d t
filter("FG"."LNAMEA" LIKE 'A%') m exae _
5 - acceSS("FG"."LNAMEA"="STUDENTS"."LNAME"(+)) campurlle din
filter( "FG" . "LNAMEA"="STUDENTS" . "LNAME" (+)) criteriul de join
7 - acceSS("STUDENTS"."LNAME"(+) LIKE 'A%') (darde fapt
filter("STUDENTS"."LNAME"(+) LIKE 'A%') - , o,
8 - filter(NULL LIKE 'A%') Inameal'k? A‘)
11 - access("FG"."LNAMEA"="STUDENTS"."LNAME") ece'fOIOS't---)-

***************Ending Page***************


***************Beginning Page***************
***************page number:61**************
Join — Sort Merge
' Destul de greoi de utilizat din cauzé c5 ambele
tabele trebuie sé fie sortate dupé cémpul
utilizat Tn join.
I

***************Ending Page***************

***************Beginning Page***************
***************page number:62**************
Clustering Data

***************Ending Page***************


***************Beginning Page***************
***************page number:63**************
Clustering Data
' Un cluster = serie de obiecte (de obicei de
aceea$i naturé) ce apar Tmpreuné.
' Un cluster de calculatoare este 0 grupare de
calculatoare care "se ajuté" simultan.
' Utilizate pentru
- a rezolva 0 problema complexa (high
performance clusters)
- a mari disponibilitatea (fai/over cluster)

***************Ending Page***************

***************Beginning Page***************
***************page number:64**************
Clustering Data

' Tn cazul calculatoarelor mai exista un tip de
cluster: Data Cluster

' Clustering data = asezarea datelor ce au
probabilitatea imediata de acces unele Ianga
altele (de exemplu atunci cand defragmentam
HDD-ul, facem acest tip de clusterizare).

' Computer cluster este destul de intalnit si
intre cele doua se face confuzie ("Let's use a
cluster to improve DB performance" ) g

***************Ending Page***************


***************Beginning Page***************
***************page number:65**************
CI usterl ng Data

1. Cel mai simplu tip de cluster este randulz
bazele de date stocheaza toate coloanele
dintr-un rand in acelasi block (DB block) daca
e posibil.

Column Stores

Column oriented databases, or column-stores, organize tab/es in
a columned way. This model is beneficial when accessing
many rows but only a few columns—a pattern that is very
common in data warehouses (OLAP).

***************Ending Page***************

***************Beginning Page***************
***************page number:66**************
Clusterlng Data
2. lndec$ii construiesc clustere de randuri —
frunzele B-tree-ului stocheaza coloanele
'intr-o maniera ordonata (valorile consecutive
sunt puse unele Ianga altele).
Si cum de obicei avem nevoie de valori apropiate,
Ie putem prelua mai multe dintr-o data.
' lndec§ii construiesc clustere de randuri cu
valori similare = second power of indexing.

***************Ending Page***************


***************Beginning Page***************
***************page number:67**************
Clustering Data- Index Filter Predicates

Used Intentionally

' Cénd apare "Indexfi/ter" de multe ori
Tnseamné c5 indexul nu a fost construit corect
5i c5 probabil existé o varianté mai eficienté (Tn
care ceea ce este filtrat este folosit de index).

' Index filtering poate fi folosit 5i Tntr-un scop
bun: pentru gruparea datelor ce sunt accesate
consecutiv.

***************Ending Page***************

***************Beginning Page***************
***************page number:68**************
Clustering Data- Index Filter Predicates
Used Intentionally
' Clauzele WHERE ce nu pot fi utilizate ca $i
predicate de acces sunt cele mai bune pentru
aceasté tehnicé:
SELECT lnameA, fnameA, dobA FROM fg
WHERE valueA = ?
AND UPPER(lnameA) LIKE '%ACK%' ,-
Indexul e inutil indiferent dacé e dupé lnameA sau dupé
upper (lnameA) . Dupa ce indexém ?

***************Ending Page***************


***************Beginning Page***************
***************page number:69**************
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time
| 9 | SELECT STATEMENT | | 2421 | 113K| 13454 (1)| 99:92:42
|* 1 | TABLE ACCESS FULL| FG | 2421 | 113K| 13454 (1)| 99:92:42
Predicate Information (identified by operation id):

1 - ‘FilteP("VALUEA"=9 AND UPPER("LNAMEA") LIKE '%ACK%')

***************Ending Page***************

***************Beginning Page***************
***************page number:70**************
Clustering Data- Index Filter Predicates

Used Intentionally

' Tabb/e acces nu este neapéirat 0 povaréi dacéi
inregistréirile ar fi stocate grupat in ace|a$i
block 5i BD ar putea sé Ie returneze intr-o
singuréi operatie de tip read.

' Dacéi réndurile sunt dispersate, BD va trebui séi
citeascéi din fiecare block in parte.

' Eficienta depinde de distributia fizicéi a datelor.

***************Ending Page***************


***************Beginning Page***************
***************page number:71**************
| Id | Operation | Name | Rows | Bytes | CoSt (%CF
| e | SELECT STATEMENT | | 2421 | 113K| 2317 <
|* 1 | TABLE ACCESS BY INDEX RONID| FG | 2421 | 113K| 2317 <
|* 2 | INDEX RANGE SCAN | IDX_VALUEA | 19369 | | 1439 <
Predicate Information (identified by operation id):

1 - filter(UPPER("LNAMEA") LIKE '%ACK%')

2 — acceSS("VALUEA"=9)

Avantajul este ca Ie gaseste pe toate cu valoarea 9 "dintr-un foc”.
71

***************Ending Page***************

***************Beginning Page***************
***************page number:72**************
Clustering Data- Index Filter Predicates

Used Intentionally

' Corelatia dintre ordinea din index si cea din
ta beléi se numeste index clustering factor.

(nr blocuri < ICF < nr rénduri)

' ICF = dacéi am un numéir de rénduri ce pot fi
stocate in nr blocuri, atunci putem sa le citim
din nr randuri accesari la HDD (dacéi nu géisim
niciodatéi douéi consecutive in acelasi bloc) sau
din nr blocuri (dacéi la o citire toate sunt
preluate corect si in ordinea dorité).

***************Ending Page***************


***************Beginning Page***************
***************page number:73**************
Clustering Data- lndex Filter Predicates

Used Intentionally

' Corelatia dintre ordinea din index si cea din
ta beléi se numeste index clustering factor.

(nr blocuri < ICF < nr rénduri)

' Este posibiléi imbunétéitirea eficientei re-
aranjénd réndurile din tabel (ce se intémplé
dacé avem doi indecsi diferiti ?)

' Chiar dacéi am face ordonarea dupéi un singur
index, si asa e complicat pentru c5 BD nu
permite decét un acces rudimentar Ia aceastéi
ordine (row sequencing).

***************Ending Page***************

***************Beginning Page***************
***************page number:74**************
Clustering Data- Index Filter Predicates

Used Intentionally

' Aici apare partea cu clusterizarea: utilizarea
unui index din douéi coloane pentru a fi
stocate intr-o ordine bine definité.

' Se va extinde indexul pentru a acoperi chiar 5i
coloana "neindexabilé":

***************Ending Page***************


***************Beginning Page***************
***************page number:75**************
Index on fg(va|ueA, Upper(|nameA))

| Id | Operation | Name | Rows | Bytes | Cost (%(
| o | SELECT STATEMENT | | 31187 | 1735K| 189

| 1 | TABLE ACCESS BY INDEX RONIDI FG | 31187 | 1735K| 189

|* 2 | INDEX RANGE SCAN | IDX_VALUEA_UPPLNAMEA | 968 | | 64
Predicate Information (identified by operation id):

2 — access("VALUEA"=9)
filter(UPPER("LNAMEA") LIKE '%ACK%')
De ce este mal blne aSa ?
75

***************Ending Page***************

***************Beginning Page***************
***************page number:76**************
Clustering Data- Index Filter Predicates
Used Intentionally
' Se observa ca filtrul este direct aplicat in pasul 2.
' De data aceasta pasul 2 returneaza doar 968
randuri (in cazul anterior erau 19369).

***************Ending Page***************


***************Beginning Page***************
***************page number:77**************
Clustering Data- Index Filter Predicates

Used Intentionally

' Aceasté abordare ignoré relevanta ordinii
coloanelor. De obicei, partea ce va fi filtraté
este bine sé fie pusé ultima (pentru ca indexul
sé meargé corect pe primele coloane — adicé
sé facé acces).

' Nu adéugati toate coloanele Tn index

***************Ending Page***************

***************Beginning Page***************
***************page number:78**************
Clustering Data- Index-Only Scan

' Una dintre cele mai puternice metode de
"tuning".

' Nu numai c5 evité evaluarea clauzei where dar
evité accesarea tabelei atunci cénd coloanele
selectate se gésesc chiar Tn index.

***************Ending Page***************


***************Beginning Page***************
***************page number:79**************
create index idx_only_scan on fg(lnameA,
fnameA, dobA);
select fnameA, lnameA, dobA from fg where
lnameA = 'Jackson';
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| 0 | SELECT STATEMENT | | 544 | 1904a | 110 (0)|
|* 1 | INDEX RANGE SCANI IDX_0NLY_SCAN | 544 | 19940 | 11a (0)|
Predicate Information (identified by operation id):
1 — access("LNAMEA"='Jackson‘)

***************Ending Page***************

***************Beginning Page***************
***************page number:80**************
Clustering Data- Index-Only Scan

' lndexul acoperé Tntreaga interogare $i din
acest motiv se mai nume$te "covering index"
(poate fi identificat prin faptul c5 nu este
accesaté deloc tabela ci doar indexul).

' Numérul mare de linii selectate poate avea un
impact negativ asupra eficientei (mai ales dacé
nu sunt Tn ace|a$i cluster — de exemplu dacé a5
céuta 5i dupé un anumit dob ar putea merge
mai greu decét dacé a5 céuta numai dupé
Inamea 5i fnamea). 80

***************Ending Page***************


***************Beginning Page***************
***************page number:81**************
plan for select fnameA, 1nameA, dobA from fg where 1nameA = 'Jackson' and fnamea='Michael';
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time |
| 0 | SELECT STATEMENT | | 404 | 16940 | 3 (0)| 00:00:01 |
|* 1 | INDEX RANGE scANl IDX_0NLY_SCAN | 404 | 16940 | 3 (0)| 00:00:01 |
Predicate Information (identified by operation id):

1 — access("LNAMEA"='Jackson‘ AND "FNAMEA"='Michae1')
plan for select fnameA, 1nameA, dobA from fg where 1nameA = 'Jackson' and dobA=sysdate;
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time |
| 0 | SELECT STATEMENT | | 404 | 16940 | 110 (0)| 00:00:02 |
|* 1 | INDEX RANGE scAN| IDX_0NLY_SCAN | 404 | 16940 | 110 (0)| 00 00:02 |
Predicate Information (identified by operation id):

1 — access("LNAMEA"='Jackson‘ AND "DOBA"=SYSDATE@!)

filter("DOBA"=SYSDATE@!)

***************Ending Page***************

***************Beginning Page***************
***************page number:82**************
Clustering Data- Index-Only Scan

' Index-only este 0 strategie agresivé.

- Nu proiectati indexul ‘in acest scop pentru c5
e ca 5i cum ati copia tabela cu bucétile care v5
intereseazé — ocupé spatiu 5i timp pentru
operatii insert/edit/de/ete (reechilibra rea B-
tree).

***************Ending Page***************


***************Beginning Page***************
***************page number:83**************
Clustering Data- Index-Only Scan

' Index-only scan poate cauza suprize neplécute

select fnameA, lnameA, dobA from fg
where lnameA = 'Jackson' AND valueA
between 4 and 10;

' Ce se Tntémplé ?

***************Ending Page***************

***************Beginning Page***************
***************page number:84**************
|* 1 | TABLE ACCESS BY INDEX RONIDI FG | 121 | 5888 | 239 (8)|
|* 2 | INDEX RANGE SCAN | IDX_JOIN_FG | 19369 | | 38 (8)|
Predicate Information (identified by operation id):
1 - filter("VALUEA">=4 AND "VALUEA"<=18)
2 — acceSS("LNAMEA"='Jackson‘)
' Din cauza Ca se face acces Tn tabela, costul a
CFESCUt. Accesarea oricarei coloane care nu
este Tn index va avea acest efect.

***************Ending Page***************


***************Beginning Page***************
***************page number:85**************
Clustering Data- Index-Only Scan

' Scrieti comentarii cand folositi selecturi de
tipul Index-Only scan pentru a va asigura ca nu
adaugati din greseala noi predicate ce vor
Tmpiedica accesul Tn stilul index-only scan.

' Scrieti comentarii cand doriti sa faceti
selecturi cu index only scan (Tn php/java/etc)

***************Ending Page***************

***************Beginning Page***************
***************page number:86**************
Clustering Data- Index-Only Scan

' Alté problemé poate sé aparé de Ia FBI.

' UPPER(fnameA) nu poate fi folosit Tn Index
Only Scan dacé se dore§te selectarea coloanei
fnameA (pentru c5 indexul tine minte valoarea
functiei §i nu valoarea coloanei) —Tncerca’§i sé
indexati valoarea originalé dacé §ti’§i c5 0 veti
folosi tot pe ea.

' Nu se va aplica 0 functie pe un cémp din
index.

***************Ending Page***************


***************Beginning Page***************
***************page number:87**************
Clustering Data- Index-Only Scan

' IVIereu selectati doar coloanele de care aveti
nevoie. Dacé selectati de genul "select * ..." Tn
nici un caz nu veti folosi Index-Only Scan.

' Existé anumite limitéri Tn ceea ce prive§te
dimensiunea indexului (deci nu puteti pune
tot Tn index pentru a face numai Index-only
Scan):

***************Ending Page***************

***************Beginning Page***************
***************page number:88**************
Limitations of Index-Only Scan

' The maximum index key length depends on the
block size and the index storage parameters (M
ofthe database block size minus some overhead).
A B-tree index is limited to 32 columns.

' When using Oracle 11g with all defaults in place
(8k blocks), the maximum index key length is
6398 bytes. Exceeding this limit causes the error
message "ORA-01450: maximum key length
(6398) exceeded.”

***************Ending Page***************


***************Beginning Page***************
***************page number:89**************
Clustering Data- Index-Only Scan

' lnterogérile care nu selecteazé nici 0 coloané
din tabel sunt executate cu Index-Only scans.
Puteti gési un exemplu ?

***************Ending Page***************

***************Beginning Page***************
***************page number:90**************
Clustering: Index-Organized Tables
' Index-Only Scan executé interogarea SQL doar
folosind informatiile redundante existente Tn

index.
' Dacé am pune toate informatiile Tn index, de
ce am mai avea nevoie de tabela originalé ?
' Tntr-adevér, existé aceasta abordare: index-
organized tab/es (IOT) sau clustered index.

***************Ending Page***************


***************Beginning Page***************
***************page number:91**************
Clustering: Index-Organized Tables
' Avantaje:
- nu se mai folose§te tabelul §i se poate
renunta Ia el;
- orice acces Tntr-un IOT este un index-only
scan.
' Ambele avantaje "suné bine" dar sunt greu de
obtinut Tn practicé.

***************Ending Page***************

***************Beginning Page***************
***************page number:92**************
Clustering: Index-Organized Tables

' Problema: cand se dore§te un nou index pe
aceea§i tabela: noul index va pointa prin
intermediul unei chei catre informatia logica
din indexul original (§i va face index unique
scan dupa aceasta cheie).

' Accesarea unui IOT dupa un al doilea index
este foarte ineficienta.

***************Ending Page***************


***************Beginning Page***************
***************page number:93**************
Secondary Index Index-Organized Table
(Clustered Index)
I d d 49 <<, <0
n ex este ” ate”
p .qp ﬁve? {3:33
4 <01 ~53‘ j} <01‘
‘ e- Eiq Q?‘ e-
‘? <0 <<, ‘a
T1
4 I, ??.i?ﬁi.3.:?_5!i.2.@_a_3:??:?_3_
2911-95-29155 555; “312514.9912311-95-23
I zall-es-zai 45 /
-as-2e _ 1
_____é I“11-95-23,?3 35: 1 _
19.5123? 'B' .
£545 211'95'2315? — - 4
1191.4:251215 12 \ BE
1611-6544556 3 ﬁiiFﬁE.-=::?_9.E.Z.B_¥l:@?:??t
i BB 114 l 2.4elZEET-es-25
ea
w‘
—1- INnEx RANGE SCAN — —:|- INDEX UNIQUE SCAN 93

***************Ending Page***************

***************Beginning Page***************
***************page number:94**************
Clustering: Index-Organized Tables

' Al doilea index péstreazé clustering keys
pentru fiecare anegistrare.

' Am putea de exemplu sé interogém doar ID-
urile (si accesul ar fi de tipul index-scan only):

***************Ending Page***************


***************Beginning Page***************
***************page number:95**************
Clustering: Index-Organized Tables

' Eficienta este pierduté atunci cénd este folosit
un al doilea index.

' Clustering key este de obicei mai lung decét
ROWID (deci §i indec§ii secundari vor ocupa
mai mult spatiu).

' Concluzia: DOAR tabelele ce folosesc un singur
index sunt cel mai bine sé fie implementate ca
un IOT.

***************Ending Page***************

***************Beginning Page***************
***************page number:96**************
Clustering: Index-Organized Tables
CREATE TABLE [
id NUMBER MDT NULL l1"llIl'-'l|||l'ull"lIF HEY,
[...]
J URGANIIATIUN INDEX;
96-

***************Ending Page***************


***************Beginning Page***************
***************page number:97**************
lndec§ii '|‘n sortare
(ORDER BY)

***************Ending Page***************

***************Beginning Page***************
***************page number:98**************
Sorta rea

' Sortarea este o actiune anevoioasa pentru
bazele de date, in principal pentru c5 toate
inregistrérile trebuie aduse intr-un buffer in
care sé se facé sortarea.

' lndec§ii retin informatiile ‘intr-o manieréi
ordonatéi — deci putem utiliza un index pentru
a u§ura munca operatiilor de tip "order by".

***************Ending Page***************


***************Beginning Page***************
***************page number:99**************
Sorta rea

' Un INDEX RANGE SCAN care Tntoarce multe
rénduri poate fi ineficient — pentru c5 timpul
necesar pentru row acces ar putea fi mai mare
decét dacé s-ar face FULL TABLE SCAN §i apoi
s-ar sorta rezultatele.

***************Ending Page***************

***************Beginning Page***************
***************page number:100**************
So rta rea

' Un index construit dupa criteriul ce este utilizat in
clauza ORDER BY va evita operatia de sortare si va
putea Tntoa rce foa rte rapid in registré rile dintr-un
anumit interval.

' Indexul face ca operatiile de tip ORDER BY sé fie
executate Tntr-o maniera pipelined = 3rd power of
index.

' Pipelining negates the need to build huge collections by piping rows
out of the function as they are created, saving memory and allowing
subsequent processing to start before all the rows are generated.

***************Ending Page***************


***************Beginning Page***************
***************page number:101**************
lndexarea pentru ORDER BY gar
PDSVQL
' lnterogérile SQL cu 0 clauza ORDER BY nu “QT
trebuie sé sorteze rezultatul dacé indexul deja
oferé aceasté ordine:
select 1nameA, fnameA, dobA
from fg
order by dobA;

***************Ending Page***************

***************Beginning Page***************
***************page number:102**************
lndexarea pentru ORDER BY
Féré index:
| Id | Operation | Name | Rows | Bytes |TempSpc| Cost (%
| 0 | SELECT STATEMENT | | 5102K| 136M| | 52994
| 1 | SORT ORDER BY | | 5192K| 136M| 195M| 52994
| 2 | TABLE ACCESS FULL| FG | 5102K| 136M| | 13342
Observati c5 de fapt sortarea face costul sé
”saré”u.

***************Ending Page***************


***************Beginning Page***************
***************page number:103**************
lndexarea pentru ORDER BY
' Pentru a scapa de sortare, ar trebui ca indexul
sa fie construit peste criteriul de ordonare:

create index idx_dobA on fg(dobA);
| Id | Operation | Name | Rows | Bytes |TempSpc| COST-EACRQST
| e | SELECT STATEMENT | | 5102K| lsSRi_______i_S;SSA___Ei;i
| 1 | SORT ORDER BY | | 5102K| 136ml 195m| 52994 (1)|
| 2 | TABLE ACCESS FULL| FG | 5102K| 136M| | 13342 (1)|

NU FOLOSESTE INDEXUL... DE CE?

***************Ending Page***************

***************Beginning Page***************
***************page number:104**************
lndexarea pentru ORDER BY
' Doua posibilitéti: interogém doar dob (ca sé
nu mai facé table access) sau introducem Tn
index si InameA, fnameA.
create index idx_dobA on
fg (deA, lnameA, fnameA) ;
| Id | Operation | Name | Rows | Bytes | Cost (%t
| e | SELECT STATEMENT | | 5162K| 136ml 26489
| 1 | INDEX FULL SCAN | IDX_DOBA | 51ezK| 136ml 26489

***************Ending Page***************


***************Beginning Page***************
***************page number:105**************
lndexarea pentru ORDER BY

' Sé Tncercém acum un index peste doué
cémpuri: valueA & dobA.

create index idx;vala_doba on fg(valuea,
doba);

Cum va fi executat urmatorul select:

select valuea, doba from fg where
valuea=9 order by doba;

?

***************Ending Page***************

***************Beginning Page***************
***************page number:106**************
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| e | SELECT STATEMENT | | 784K| 8424K| 2413 (1)|
|* 1 | INDEX RANGE SCANI IDX_VALA_DOBA | 784K| 8424K| 2413 (1)|
Predicate Information (identified by operation id):
1 — access("VALUEA"=9)

Se face access dupa VALU EA si apoi se citeste

lndexul pentru ca datele sunt deja sortate

Dupa cémpul dob.

***************Ending Page***************


***************Beginning Page***************
***************page number:107**************
lndexarea pentru ORDER BY
VALUEA DOBA

A!’ “i
7 i? Q
8% E? i
9 a a?‘ J Scanned

index range

10. I?‘

***************Ending Page***************

***************Beginning Page***************
***************page number:108**************
Llsta dubla Inlantulta
' Daca frunzele nu ar fi dublu inlantuite, atunci
nu am putea ca, utilizand ace|a§i index sa
cerem datele Tn ordine descrescatoare §i sa nu
apara sortare... sa vedem daca apare sort:
|* 1 | INDEX RANGE SCAN DESCENDINGI IDX_VALA_DOBA | 784K| 8424K| 2413
Predicate Information (identified by operation id):

***************Ending Page***************


***************Beginning Page***************
***************page number:109**************
lndexarea pentru ORDER BY

' Ce se Tntamplé dacé mérim intervalul céutat ?

select valuea, doba from fg where valuea
IN (8,9) order by doba;

***************Ending Page***************

***************Beginning Page***************
***************page number:110**************
lndexarea pentru ORDER BY

VALUEA DOBA

L A! ‘Q
7i i? i
8i E? i

Scanned
' indexrange

10- I?‘

***************Ending Page***************


***************Beginning Page***************
***************page number:111**************
| Id | Operation | Name | Rows | Bytes |TempSpc| Cost (%CPU
| 9 | SELECT STATEMENT | | 1522K| 15M| | 19929 (1
| 1 | SORT ORDER BY | | 1522K| 15M| 29M| 19929 (1
|* 2 | INDEX FAST FULL SCANI IDX_VALA_DOBA | 1522K| 15M| | 4274 (1
Predicate Information (identified by operation id):

2 - filter("VALUEA"=8 0R "VALUEA"=9)

Utilizeaza indexul pentru a gasi exact liniile ce trebuie

Tntoarse dar acestea vor fi reordonate.

(pentru ca Tn index nu sunt aSezate dupa doba).

111

***************Ending Page***************

***************Beginning Page***************
***************page number:112**************
A B

1 a CREATE INDEX exemplu ON tabel(A,B);

1 b

1 C SELECT * FROM tabel

1 cl WHERE A >1 AND A<4

1 a ORDER BY A,B;

z b

2 . .

2 s Merge pe Index pana gaseste Inceputul
3 a intervalului unde A>1 si A<4, ajunge la
a I} cuplul (2,a) dupa care continua pe lista
3 C dublu inlantuita pana ajunge la (3,d).

a {I

4 a

4 b

4 c

4 {I

***************Ending Page***************


***************Beginning Page***************
***************page number:113**************
A B

1 a CREATE INDEX exemplu ON tabel(A,B);

1 I}

1 C SELECT * FROM tabel

1 {I WHERE A >1 AND A<4

P- H ORDER BY A, B desc;

z I}

z . .

2 s Merge pe Index pana gaseste Inceputul
3 a intervalului unde A>1 si A<4, ajunge la
a I} cuplul (2,a). In continuare, daca ar merge
3 C pe lista dublu inlantuita nu ar putea

3 d furniza coloana B in ordine

4 a

descrescatoare.

a b

4 c

4 {I

***************Ending Page***************

***************Beginning Page***************
***************page number:114**************
A H- A B
1 {I CREATE INDEX exemplu ON tabel(A,B 4 E
1 C ﬁ desc) ; 4 I}
1 I} 4 c
1 5 Sau? 4 {I
I! {I 3 a
1 1: l 3 I}
P. I} iiiiEE)fNDEX exemp u ON tabel(A » 3 C
E a 3 {I
3 {I 2' a
3 1: 1 I}
3 I} 1 E
3 a SELECT * FROM tabel 1 d
I i WHERE A >1 AND A<4 1 z
4 b ORDER BY A,B desc; 1 C
11 5 1 {I 114

***************Ending Page***************


***************Beginning Page***************
***************page number:115**************
A E A H-
1 d CREATE INDEX exemplu ON tabel(A,B 4 E
1 C ﬁ desc) ; 4 I}
1 I} 4 c
1 5 Sau ? 4 {I
I! {I 3 a
E c 3 I}

CREATE INDEX exemplu ON tabel(A
2 b desc, B) ; » 3 C
E a 3 {I
3 {I 2' a
3 c Cand criteriul de ordonare este invers fata de 1 I}
3 I} ordinea existenta in index, acesta (indexul) este I! 1:
parcurs in sens invers...
3 5 1 {I
4 {I 1 H
4 c 1 b
4 I} 1 C
4 ‘a 1 {I 115

***************Ending Page***************

***************Beginning Page***************
***************page number:116**************
lndexarea pentru ORDER BY
' Dacé BD folose§te 0 operatie de sortare chiar
cénd v5 a§teptati Ia 0 executie pipe/ined,
motivul este unul din urmétoarele doué:
- Q0 consideré c5 executia este optimé in
acestfeL
- Ordinea indec§i|or nu corespunde clauzei
"ORDER BY"
' Puteti sé vé dati seama de motiv folosind unfu/l index definition in
clauza order by.

***************Ending Page***************


***************Beginning Page***************
***************page number:117**************
lndexarea pentru ORDER BY

***************Ending Page***************

***************Beginning Page***************
***************page number:118**************
:7

ASC/ D ESC/ N U LL FIRST, LAST Z;
' BD pot citi indec§ii Tn ambele directii. my:
' lndec§ii sunt folositi §i dacé ORDER BY trebuie

sé Tntoarcé rezultatul Tn ordine inversé.
' Modificatorii ASC/DESC pot schimba executia

de tip pipedline Tntr-una Tn care trebuie fécuté

sortarea.
' Avem indexul peste fg (valuea ,doba)
' dobA poate fi NULL...

***************Ending Page***************


***************Beginning Page***************
***************page number:119**************
ASC/ D ESC/ N U LL FIRST, LAST
select valuea, doba from fg where valuea
between 8 and 9 order by valuea,doba;

' In acest caz, planul de executie arata astfel:
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| 0 | SELECT STATEMENT | | 1522K| 15M| 4598 (1)|
| 1 | INLIST ITERATOR | | | | |
|* 2 | INDEX RANGE SCANI IDX_VALA_DOBA | 1522K| 15m| 4598 (1)|
Predicate Information (identified by operation id):

2 - access("VALUEA"=8 0R "VALUEA"=9)

***************Ending Page***************

***************Beginning Page***************
***************page number:120**************
VALUEA DOBA
8
i Scanned
'?€ index range
10- I?‘

***************Ending Page***************


***************Beginning Page***************
***************page number:121**************
ASC/ DESC/ NULL FIRST, LAST
select valuea, doba from fg where valuea
between 8 and 9 order by valuea desc,doba
desc;
' In acest caz, planul de executie arata astfel:
| 1 | INLIST ITERATOR | | | |
|* 2 | INDEX RANGE SCAN DESCENDINGI IDX_VALA_DOBA | 1522K| 15M| 4508
Predicate Information (identified by operation id):
2 - access("VALUEA"=8 0R "VALUEA"=9)

***************Ending Page***************

***************Beginning Page***************
***************page number:122**************
VALUEA DOBA
L A!’ ‘i
8 ‘
i Scanned
'fg index range
10 I?‘

***************Ending Page***************


***************Beginning Page***************
***************page number:123**************
ASC/ DESC/ NULL FIRST, LAST
select valuea, doba from fg where valuea
between 8 and 9 order by valuea asc,doba
desc;
' In acest caz, planul de executle arata astfel:
| Id | Operation | Name | Rows | Bytes |TempSpc| Cost (%C
| 9 | SELECT STATEMENT | | 1522K| 15M| | 19929
| 1 | SORT ORDER BY | | 1522K| 15M| 29M| 19929
|* 2 | INDEX FAST FULL SCANI IDX_VALA_DOBA | 1522K| 15M| | 4274
Predicate Information (identified by operation id):
2 - filter("VALUEA"=8 0R "VALUEA"=9)

***************Ending Page***************

***************Beginning Page***************
***************page number:124**************
i 5?‘?
i E?€ TE Impossible
a iii ET index jump

***************Ending Page***************


***************Beginning Page***************
***************page number:125**************
ASC/DESC/N U LL FIRST, LAST

' Este crucial ca indexul sé fie EXACT
- Tn aceea§i ordine cu ce se cere Tn ORDER BY
- Tn ordine inversé faté de ce se cere Tn clauza
ORDER BY!

***************Ending Page***************

***************Beginning Page***************
***************page number:126**************
ASC/DESC/N U LL FIRST, LAST

' Pentru cazuri ca cel precedent, cele mai multe
BD oferé posibilitatea de a crea indec§i Tntr-o
anumité ordine.

***************Ending Page***************


***************Beginning Page***************
***************page number:127**************
ASC/DESC/N U LL FIRST, LAST
create index idx;vale_doba on ‘Fum“3555
fg(valuea desc ,doba asc); 'Hmmemmﬂa
SAU
create index idx;vale_doba on
fg(valuea asc, doba desc);
' [IVIySQL ignora ASC/DESC din definitia indec§i|0r]
®
' Noua definitie nu afecteazé céutarea Tn clauza
WHERE.

***************Ending Page***************

***************Beginning Page***************
***************page number:128**************
select valuea, doba from fg
where valuea between 8 and 9
order by valuea desc, doba asc;

***************Ending Page***************


***************Beginning Page***************
***************page number:129**************
ASC/ D ESC/ N U LL FIRST, LAST
' Dupa crearea noului index, se va evita
sortarea (din nou):
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)|
| 0 | SELECT STATEMENT | | 1522K| 15m| 76 (e)|
|* 1 | INDEX RANGE SCANI IDX_VALA_DOBA | 1522K| 15M| 76 (0)|
Predicate Information (identified by operation id):
1 - access(SYS_0P_DESCEND("VALUEA")>=HEXTORAN('3EF5FF') AND
SYS_0P_DESCEND("VALUEA")<=HEXTORAN('3EF6FF') )
filter(SYS_0P_UNDESCEND(SYS_0P_DESCEND("VALUEA"))>=8 AND
SYS_0P_UNDESCEND(SYS_0P_DESCEND("VALUEA"))<=9)

***************Ending Page***************

***************Beginning Page***************
***************page number:130**************
ASC/ D ESC/ N U LL FIRST, LAST

' ASC/DESC sunt utilizate pentru a inversa
ordinea anumitor coloane. Nu este nevoie sé
Ie sortam pe toate DESC. De ce ?

***************Ending Page***************


***************Beginning Page***************
***************page number:131**************
ASC/DESC/N U LL FIRST, LAST

' lnafara de ASC/DESC, SQL permite Tnca doi
modificatori pentru ORDER BY (NULL FIRST sau
NULL LAST).

' Problema apare din cauza ca nu se poate
specifica ordinea pentru NULL (Tn index).

' Nu este implementata nici de SQL server 2012
§i nici de |V|ySQL 5.6.

' Oracle SQL suporta sortarea NULL-urilor
Tnainte sa fie introdus Tn standard dar nu
permite indexarea Ior nici macarTn llg.

***************Ending Page***************

***************Beginning Page***************
***************page number:132**************
ASC/DESC/N U LL FIRST, LAST

' Oracle nu va permite pipeline atunci cand se
va face sortare cu NULLS FIRST.

' PostgreSQL suporta (din ver 8.3) modificatori
NULLS atét Tn ORDER BY cét §i Tn definirea
indec§i|or.

***************Ending Page***************


***************Beginning Page***************
***************page number:133**************
ASC/ D ESC/ N U LL FIRST, LAST
a 3a 5}
Q3» £30’ a“? 0&9 O? 6;?
Q é‘ O Q ‘To ‘To
Read index backwards
Order by ASUDESc
Index ASC/DESC
Order by NULLS FIRST} LAST
Default NULLS erder
Index NULLS FIRST} LAST
ldee de studiu individual: demonstrati ca Oracle indexeaza default NULL la sfér§it. 133 I

***************Ending Page***************

***************Beginning Page***************
***************page number:134**************
lndec§ii '|‘n grupare
(GROUP BY)

***************Ending Page***************


***************Beginning Page***************
***************page number:135**************
lndexarea GROUP BY I;
' BD SQL folosesc doi algoritmi diferiti: MVQ
1) algoritm Hash care face agregare de WT
anegistrari Tntr-o tabela hash. Dupa ce toate
inputurile au fost procesate, se returneaza
tabela hash (nu si in IVIySQL 5.6)
2) sort/group: Tntai sorteaza datele dupa cheile
de grupare a.i. ele sa fie consecutive dupa
care |e face agregare.

***************Ending Page***************

***************Beginning Page***************
***************page number:136**************
lndexarea GROUP BY

' Ambii algoritmi au pa§i intermediari
(construire de hashuri / sortarea) §i din acest
motiv nu pot fi executati Tn maniera pipe/ined.

' Totu§i, algoritmul sort/group (al doilea) poate
utiliza un index pentru a evita sortarea, Tn
acest fel dénd posibilitatea de efectuare a
pipeline chiar §i Tn cadrul grupérilor.

***************Ending Page***************


***************Beginning Page***************
***************page number:137**************
lndexarea GROUP BY

' Pentru a se produce un piped/ined group by,
trebuie sé fie indeplinite acelea§i conditii ca §i
Tn cazul Iui order by.

' Aceea§i observatie pentru NULLS FIRST/LAST.
' Existé baze de date care nu pot procesa corect
ASC/DESC indexarea pentru a face pipe/ined
group by [In PostgreSQL trebuie adaugat un
order by pentru a face un NULLS LAST ce va fi

folosit in group by].

***************Ending Page***************

***************Beginning Page***************
***************page number:138**************
lndexarea GROUP BY

' Pentru a returna liniile Tn ordine inversé,
indexul putea fi parcurs invers (Tn cazul ORDER
BY).

' Tn Oracle nu se poate citi un index Tn ordine
inversé pentru a se executa un piped group by
dacé este urmat de un order by.

I

***************Ending Page***************


***************Beginning Page***************
***************page number:139**************
Primele n anegistréri

***************Ending Page***************

***************Beginning Page***************
***************page number:140**************
Rezultate partiale

' Uneori nu sunt necesare toate liniile unei
interogari SQL ci doar primele n (céteva) linii
[fie pentru 0 afi§are paginaté fie pentru un
"scroll infinit"].

' Asta ar putea crea probleme de performanté
dacé toate inregistrérile trebuie sortate pentru
a fi returnate doar primele n. Din acest motiv,
un "pipelined ordered by" este 0 optimiza re
puternicé.

***************Ending Page***************


***************Beginning Page***************
***************page number:141**************
Rezultate partiale

' Un pipe/ined ORDER BY nu este atat de
important din cauza ca poate sa returneze
randurile sortate, ci mai degraba pentru ca
poate sa returneze primele n randuri fara sa
treaca prin toate (pipelined ORDER BY are
cost mic de pornire).

***************Ending Page***************

***************Beginning Page***************
***************page number:142**************
Primele n inregistrari

' Atunci cand se doreste preluarea primelor n
inregistrari, Q0 nu isi da seama ca se doresc
numai acele n.

' Q0 ar trebui sa stie daca in final aplicatia va
prelua toate inregistrarile — atunci un full scan
urmat de sortare ar fi cea mai buna solutie.
Chiar si asa, un piped order by ar aduce un +.

' Tip: spune-i BD cand nu ai nevoie de toate
inregistrari/e - fetch first.

***************Ending Page***************


***************Beginning Page***************
***************page number:143**************
Primele n inregistrari
' fetch first — in SQL:2008, disponibil in IBIVI
DBZ, PostgreSQL, SQL Server 2012, Oracle 12c.
SELECT val FROM rownum_order_test
ORDER BY val DESC
FETCH FIRST 5 Rows ONLY;
[Oracle 12c]

***************Ending Page***************

***************Beginning Page***************
***************page number:144**************
Prlmele I’) lnreglstrarl
' In Oracle llg...
' Sa consideram urmatoarea interogare Oracle:
SELECT * FROM (
SELECT *
FROM fg WHERE valueaI9
ORDER BY dOba DESC )
WHERE rownum <= 10;

***************Ending Page***************


***************Beginning Page***************
***************page number:145**************
Si-a dat seama ca trebuie sa numere doar 10.

| Id | Operation - | Rows | Bytes |TempSpc| Cost (%+
| 8 | SELECT STATEMENT | | 18 | 98 | | 16781
|* 1 | COUNT STOPKEY | | | | |
| 2 | VIEW | | 784K| 6892K| | 16781
|* 3 | SORT ORDER BY STOPKEYI | 784K| 8424K| 15ml 16781
|* 4 | TABLE ACCESS FULL | F6 | 784K| 8424K| | 13352
Predicate Information (identified by operation id):

1 - filter(R0wNUM<=16)

3 - filter(R0wNUM<=10)

4 - filter("VALUEA"=9)

145

***************Ending Page***************

***************Beginning Page***************
***************page number:146**************
Primele n inregistrari

' BD poate optimiza interogarea doar daca stie
de |a inceput ce rezultat partial este asteptat.

' Va prefera sa utilizeze un pipelined order by:

' Utilizarea unei sintaxe corecte este numai
jumatate dinjob.

' Pentru ca sa poata numara doar primele 10
inregistrari, trebuie ca neaparat sa aiba un
order by ca re sa poata fi piped (altfel ar trebui
sa sorteze tot).

***************Ending Page***************


***************Beginning Page***************
***************page number:147**************
anele n |nreg|strar|
create index idx_doba on fg(va|uea,doba);
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Tim
| 0 | SELECT STATEMENT | | 1e | 99 | 3 (e)| ea:
|* 1 | COUNT STOPKEY | | | | |
| 2 | VIEN | | 1e | 99 | 3 (e)| ea:
|* 3 | INDEX RANGE SCANI IDX_DOBA | 1e | 110 | 3 (0)| 00:
Predicate Information (identified by operation id):
1 - filter(R0wNUM<=10)
3 — access("VALUEA"=9)

***************Ending Page***************

***************Beginning Page***************
***************page number:148**************
Daca ar fl nevolt sa la toate

|nreg|strar||e (5| nu doar prlmele 10):
| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time
| 0 | SELECT STATEMENT | | 784K| 8424K| 2413 (1)| 00:00
|* 1 | INDEX RANGE SCANI IDX_DOBA | 784K| 8424K| 2413 (1)| 00:00
Predicate Information (identified by operation id):

1 — access("VALUEA"=9)
Deci e clar ca Tn cazul precedent, a "gtiut" sa se opreasca dupa primele 10
Asta din cauza ca Tn timp ce face pipe, Ie §i numara.
148

***************Ending Page***************


***************Beginning Page***************
***************page number:149**************
Prlmele I7 lnreglstrarl

http://blog.fataImind.com/2010/O9/29/finding-the-best-match-with-a-top-n-query/

' Avantajul nu este numai Tn performanta
imediaté ci §i Tn scalabilitatea mérité. Féré
pipe/ined execution, timpul cre§te direct
proportional cu dimensiunea tabelei (cénd
sunt piped, timpul este aproape identic).

? Top-N Scaiability _rnaterialized— —PiPE-‘|I'I"IE‘EI f If
E '5" _.5 ‘E
‘5' 5" --5 i
.2 4 4 .2.
g 3 3 §
é 2 2 5-:
g 1-- ‘1 '3'?

D ‘20* ‘ _ 1m‘ e'o so 1000149 I

Data-volume

***************Ending Page***************

***************Beginning Page***************
***************page number:150**************
Paginarea rezultatelor

***************Ending Page***************


***************Beginning Page***************
***************page number:151**************
Paginarea rezultatelor
' Ce se Tntémplé dupé ce s-au Tntors primele n
rezultate ?
' Avem nevoie de rezultatele [n+1 .. 2n] (pentru
urmétoarea paginé).
' Existé doué metode:
- offset method (numara liniile de Ia inceput, filtreaza dupa row
number si face discard Ia ce e in plus)
- 566k method (cauta ultima intrare din pagina precedenta si preia
randurile urmatoare)

***************Ending Page***************

***************Beginning Page***************
***************page number:152**************
Paginarea rezultatelor - offset
' IVIetoda offset utilizeaza un cuvant special
“offset” — SQL Server standard ca si extensie
pentru fetch firstl
SELECT * FROM sales
ORDER BY sale_date DESC
OFFSET 10 ROWS
FETCH NEXT 10 ROWS ONLY;

***************Ending Page***************


***************Beginning Page***************
***************page number:153**************
Paginarea rezultatelor - offset
' Tn Oracle e putin mai complicat...
SELECT * FROM
(SELECT tmp.*, rownum rn FROM
(SELECT *
FROM fg WHERE valuea:9
ORDER BY doba DESC )
tmp WHERE rownum <= 20)
WHERE rn > 10;

***************Ending Page***************

***************Beginning Page***************
***************page number:154**************
| Id | Operation | Name | Rows | Bytes | Cost (
| 0 | SELECT STATEMENT | | 20 | 244a | 4
|* 1 | VIEN | | 20 | 244a | 4
|* 2 | COUNT STOPKEY | | | |
| 3 | VIEN | | 20 | 2189 | 4
| 4 | TABLE ACCESS BY INDEX RONID | FG | 784K| 47M| 4
|* 5 | INDEX RANGE SCAN DESCENDINGI IDX_DOBA | 20 | | 3
Predicate Information (identified by operation id):

1 - filter("RN">10)

2 - filter(R0wNUM<=20)

5 — acceSS("VALUEA"=9)

Va trebui Sé ia 20 de rénduri Si Sé arunce primele 10.

Pe pagina n va lua n*10 rénduri Siva arunca (n-1)*10.

154

***************Ending Page***************


***************Beginning Page***************
***************page number:155**************
Paginarea rezultatelor - offset
' Doué dezavantaje:

- pagina se shifteazd cénd sunt adéugate
anegistrari noi (pentru c5 o numéré 5i pe
cea nou adéugaté);

- timpul de réspuns este mare cénd se
acceseazé paginile cu numér mare.

***************Ending Page***************

***************Beginning Page***************
***************page number:156**************
Paginarea rezultatelor - seek

' IVIetoda seek utilizeaza valoarile din pagina
anterioaré ca punct de plecare si evité ambele
dezavantaje ale metodei offset.

' Cauté anegistrérile care urmeazé ultimei
anegistréri de pe pagina anterioaré (utilizénd
un simplu WHERE).

***************Ending Page***************


***************Beginning Page***************
***************page number:157**************
Paglnarea rezultatelor - seek
' Presupunénd c5 se pune o singuré noté pe zi
(deci data ar fi cheie unicé):
? = Ultimul sa|e_date de pe
pagina precedenta

SELECT * FROM fg

WHERE dcba < ?

ORDER BY doba

DESC FETCH FIRST 10 ROWS ONLY;

***************Ending Page***************

***************Beginning Page***************
***************page number:158**************
Paginarea rezultatelor - seek

' Problema este ca dacé nu avem 0 cheie unicé
Ia sfér§it de paginé, se poate Tntémpla sé nu
§tim de unde Tncepem pagina urmétoare.

' Trebuie ca order by sé fie determinist* altfel
se poate Tntémpla ca o noué executie sé facé
un shuffle a anegistrérilor (din cauzé c5 Q0 se
hotéré§te sé execute altfel interogarea §i
atunci putem sé ne trezim c5 s-a facut "swap"
Tntre ultima anegistrare de pe pagina
anterioaré §i prima de pe noua paginé).

*De exemplu nu ordonati dupa rownum care este o psudocoloana ce este construita de fiecare data la un nou apel.

***************Ending Page***************


***************Beginning Page***************
***************page number:159**************
Paginarea rezultatelor - seek

' Pentru a ne asigura c5 ORDER BY este mereu
determinist, am putea sé-I extindem
(adéugénd coloane) péné ajungem Ia unicate
(sau dacé nu se poate, se adaugé un cémp
unic) — vezi "cheie candidat" de Ia BD.

***************Ending Page***************

***************Beginning Page***************
***************page number:160**************
Scalabilitate offset vs seek
1_2_F’-=11¢;:|ir"|g Methods M1“ 1'2
E 0.3 0.5 E
E 0.6 as E
u: _ _ u:
1' D “IIMAMMLAHIMLLMD I
0 20 4n an so 100
Page
160

***************Ending Page***************


***************Beginning Page***************
***************page number:161**************
“I?
Functii Window -> paginare :53?
' IVIetoda flexibila, conform standardului. “7"”
' Numai SQL server 5i Oracle Ie utilizeazé pentru
un pipelined n-querry
' PostgreSQL nu se opre§te din scanat dupé ce a
preluat primele n linii ®
' |\/|ySQL nu are deloc implementaté 0 astfel de
functie ®

***************Ending Page***************

***************Beginning Page***************
***************page number:162**************
Functii Window -> paginare va'Pri'?dUpa
crlterlulde
ordonare

SELECT * FROM (

SELECT fg.* , ROW;NUMBER() OVER
(ORDER BY doba DESC ,
id DESC) rn
FROM fg) tmp
WHERE rn between ll and 20
ORDER BY doba DESC, id DESC;

***************Ending Page***************


***************Beginning Page***************
***************page number:163**************
Functii Window -> paginare

' ROW_NU|V|BER enumeré réndurile Tn functie
de ordinea de sortare definité Tn clauza over.

' Ultimul where folose§te valoarea Iui rn pentru
a prelua doaranegistrérile 11-20.

' BD Oracle recunoa§te conditia de oprire §i
utilizeazé indec§ii SALE_DATE si SALE_ID
pentru a produce un comportament pipe/ined

***************Ending Page***************

***************Beginning Page***************
***************page number:164**************
De§i costul calculat
. . . - este mare, timpul
Fu nctll WI ndow -> pagl na re 6666 6660
secunde!
Id | Operation | Name | Rows | Bytes | \ t (
O | SELECT STATEMENT | | 5162K| 593m| 67635
* 1 | VIEN | | 5102K| 593M| 67635
* 2 | NINDON NOSORT STOPKEY | | 5162K| 311M| 67635
3 | TABLE ACCESS BY INDEX RONID| FG | 5162K| 311m| 67635
4 | INDEX FULL SCAN DESCENDINGI IDx_DOBA | 5102K| | 17673
'redicate Information (identified by operation id):
1 - filter("RN">=11 AND "RN"<=20)
2 - filter(RON_NUMBER() OVER ( ORDER BY INTERNAL_FUNCTION("DOBA") DESC
,INTERNAL_FUNCTION("ID") DESC )<=20)

***************Ending Page***************


***************Beginning Page***************
***************page number:165**************
Operatie de tip NOSORT = pipelined
Id | Operation Ce 59 OPFESte cand 59 ajunge '30 ows | Bytes | Cost (
.______________________ anumitavaloare(stopkey) _____________________
O | SELECT STATEMEN 5162K| 593m| 67635
* 1 | VIEN | | 5102K| 593M| 67635
* 2 | NINDON NOSORT STOPKEY | | 5162K| 311M| 67635
3 | TABLE ACCESS BY INDEX RONID| F6 | 5162K| 311m| 67635
4 | INDEX FULL SCAN DESCENDINGI IDX_DOBA | 5102K| | 17673
‘Pedicate Information (identified by operation id):
1 - filter("RN">=11 AND "RN"<=20)
2 - filteP(R0w_NUMBER() OVER ( ORDER BY INTERNAL_FUNCTION("DOBA") DESC
,INTERNAL_FUNCTION("ID") DESC )<=20)
165

***************Ending Page***************

***************Beginning Page***************
***************page number:166**************
Functii Window -> paginare
' Ce Ie face pe functiile window sé fie
importante nu este neapérat paginarea ci mai
degrabé calculele analitice.
I

***************Ending Page***************


***************Beginning Page***************
***************page number:167**************
Insert, Update, Delete

***************Ending Page***************

***************Beginning Page***************
***************page number:168**************
Insert, Update, Delete

' Insert + Update + Delete = DIVIL (Data
Manipulation Language)

' Performanta acestor comenzi este influentata
(negativ) de prezenta indec§ilor.

' lndexul = date redundante. Cand sunt
executate comenzile sus mentionate, indec§ii
trebuie refacuti §i ei.

***************Ending Page***************


***************Beginning Page***************
***************page number:169**************
Insert

' lnsertul este influentat Tn primul rénd de
numérul indec§i|or.

' lnsertul nu are cum sé beneficieze de pe urma
indec§i|or deoarece nu are 0 clauza "where".

***************Ending Page***************

***************Beginning Page***************
***************page number:170**************
Insert

' lnserarea unui rand intr-o tabela presupune:
- gasirea unei locatii pentru stocare [in
tabelele fara indecsi, se cauta un block care
are suficient spatiu si este adaugat acolo]
- daca exista indecsi peste tabela, BD trebuie
sa se asigure ca noua inregistrare apare in
indecsi (va adauga cate 0 intrare in fiecare)

***************Ending Page***************


***************Beginning Page***************
***************page number:171**************
Insert
- adaugarea in index este mai costisitoare
pentru ca arborele trebuie rebalansat. Din
cauza existentei arborelui, inregistrarea nu
poate fi scrisa in orice block; ea apartine unei
anumite frunze din B-tree. Pentru a ajunge Ia
locatie trebuie traversat arborele

***************Ending Page***************

***************Beginning Page***************
***************page number:172**************
Insert
- dupa indentificarea frunzei BD confirma daca
mai exista spatiu in nodul respectiv. Daca nu
mai exista, nodul este impartit in doua si
distribuie intrarile intre vechiul si noul nod
(aici apar referinte noi si in nodul superior
care Ia randu-i poate fi impartit). Daca toate
nodurile pana Ia radacina sunt impartite,
arborelui i se mai adauga un nivel.

***************Ending Page***************


***************Beginning Page***************
***************page number:173**************
Insert
' Timpul unui insert in functie de numarul de
indecsi:
mu _lnsert Scaiahlllty £110
‘E’ 'E'
5; nus nus 5
i} ﬂi'
E {we we g
{I'll
E 0.114 EB’ um E‘
a E a
g 111:2 -- is --u.u2 g
LLI l LLI
um: nun
u 1 2 3 4 5
Indexes
173

***************Ending Page***************

***************Beginning Page***************
***************page number:174**************
Insert

' Primul index face cea mai mare diferenta

' Considerand ca intr-o tabela s-ar face numai
inserturi, e mai bine fara indecsi.

- Performanta fara indecsi este atat de buna ca
uneori are sens sa renuntam la indecsi atunci
cand incarcam cantitati mari de date (indecsii
nu trebuie refacuti in timpul incarcarii ci
numai o singura data la final).

174

***************Ending Page***************


***************Beginning Page***************
***************page number:175**************
Insert
' Cum s-ar proceda in cadrul unei "index
organized table" sau "clustered index" ?

***************Ending Page***************

***************Beginning Page***************
***************page number:176**************
Delete

' Delete are 0 clauza "where" care 0 face sa
beneficieze de pe urma indecsilor.
Funtioneaza ca un select urmat de stergerea
datelor.

' Stergerea unui rand este inversa fata de
inserarea unui rand.

***************Ending Page***************


***************Beginning Page***************
***************page number:177**************
Delete
' Eficienta operatiei delete este reprezentata in
tabelul:
Delete Sealebilit
0.12 y e12
E n.1e- 0.10 E
e. e
iD , _ ﬂi
.E ens one .E
g one nee 3;
PD .ﬁ
e 0.04 0.04 =5
U U
E 0.02 0.02 E
LLI LLI
0.00 nee
1 2 a 4 5
Indexes 177

***************Ending Page***************

***************Beginning Page***************
***************page number:178**************
Delete

' Daca nu exista index, BD trebuie sa faca full
tab/e scan pentru a cauta inregistrarea.

' Are sens sa stergem fara "where" atunci cand
sunt sterse foarte multe randuri.

' Operatiile delete si update au un execution
plan (incercati acasa).

***************Ending Page***************


***************Beginning Page***************
***************page number:179**************
Update

' O operatie de tip Update trebuie sa realoce
indexul (sa stearga vechea pozitie si sa realoce
informatia in alta pozitie).

' Update (Ia fel ca insert si delete) depinde de
numarul indecsilor peste tabela.

' Daca updateul nu modifica campurile din
indecsi, timpul este minim (pentru ca indecsii
nu trebuie refacuti).

***************Ending Page***************

***************Beginning Page***************
***************page number:180**************
Update
t cal ili
020 updae s ab ty 0'20
'E‘ all cnlumns _ 'E'
III ﬂJ
.E. 0-15 nneculumn — 0'15 E.
m a:
.E E
‘E 0.10 0.10 ‘E
D D
‘*5 ‘E
u 0.05 0.05
a i
LU LLI
0.00- 0.00
1 2 3 4 5
Index Count

***************Ending Page***************


***************Beginning Page***************
***************page number:181**************
Update

' Daca este afectat un singur index (prin afectat se
intelege ca trebuie sa fie re-aranjat), timpul
ramane acelasi chiar daca sunt mai multi indecsi
peste tabela.

' Cand se scrie comanda update, trebuie avut grija
sa fie modificate doar acele coloane care trebuie
modificate si nu toate coloanele (utilizand valori
vechi in update).

Ganditi-va la un caz cand insert sau delete nu afecteaza indexul peste o tabela.
Raspuns:
I

***************Ending Page***************

***************Beginning Page***************
***************page number:182**************
Bibliografie (online)

' httg:[[use-the-index-Iuke.com[
(puteti cumpara si cartea in format PDF — dar
nu contine altceva decat ceea ce este pe site)

***************Ending Page***************


***************Beginning Page***************
***************page number:183**************
Joins — INNER JOIN

' httg:Z[www.codegroiectcom[ArticlesZ33OSZZ
VisuaI-Regresentation-of-SQL-Joins

' Cel mai simplu tip de join, interogarea va
returna toate inregistrarile din A care au
inregistrari pereche in tabela B.

SELECT <select_list>
FROM Table_A A
INNER JOIN Table_B B
ON A.Key = B.Key

***************Ending Page***************

***************Beginning Page***************
***************page number:184**************
Joms — LEFT JOIN

' Returneaza inregistrarile din tabela A
indiferent daca au un match in tabela B. Daca
in tabela B sunt inregistrari care fac match, Ie
va potrivi.

SELECT <select_list>
FROM Table_A A
LEFT JOIN Table_B B
ON A.Key = B.Key

***************Ending Page***************


***************Beginning Page***************
***************page number:185**************
Joms — RIGHT JOIN
' Returneaza inregistrarile din tabela B
indiferent daca au un match in tabela A. Daca
in tabela A sunt inregistrari care fac match, Ie
va potrivi.
SELECT <select_list>
FROM Table_A A
RIGHT JOIN Table_B B
ON A.Key = B.Key

***************Ending Page***************

***************Beginning Page***************
***************page number:186**************
Joms — OUTER JOIN
' Va intoarce inregistrarile care se potrivesc in
ambele tabele (A si B).
SELECT <select_list>
FROM Table_A A
FULL OUTER JOIN Table_B B
0N A.Key = B.Key .

***************Ending Page***************


***************Beginning Page***************
***************page number:187**************
Joins — LEFT EXCLUDING JOIN
' Va intoarce inregistrarile din A care nu au un
match in B.
SELECT <select_list>
FROM Table_A A
LEFT JOIN Table_B B ON A.Key = B.Key
WHERE B.Key IS NULL .

***************Ending Page***************

***************Beginning Page***************
***************page number:188**************
Joins — RIGHT EXCLUDING JOIN
' Va intoarce inregistrarile din B care nu au un

match in A.
SELECT <select_list>

FROM Table_A A

RIGHT JOIN Table_B B

ON A.Key = B.Key

WHERE B.Key IS NULL

***************Ending Page***************


***************Beginning Page***************
***************page number:189**************
Joins — OUTER EXCLUDING JOIN
' Va intoarce inregistrarile din A si din B care nu
se potrivesc.
SELECT <select_list>
FROM Table_A A FULL OUTER JOIN Table_B B
ON A.Key = B.Key
WHERE A.Key IS NULL OR B.Key IS NULL

***************Ending Page***************

***************Beginning Page***************
***************page number:190**************
SEIECT 'Ks-elecLljs-t} SELECT {ﬁlecLlisth
FROM TableA 1i FROM Tabch A
LEFTJDIN TableB B RIGHTJOIN Tablcﬂ B
ON Aliey = Elie}: ON ELKcy = Elie}:
SELECT ﬂselchlzistI-‘I-
FROM TabIcA A
INNER JOIN Tabla-B B
ON Elie)! = BJCcy
SELECT {selectjist} ‘SELECT {selectjistb-
FRDI's-I TahlﬁA A FROM Tabltﬁ. A
LEFT JUI-N Tahch B RIGHT JOIN Tabch B
UN 11.qu = 13.va 0N LKL'}; = B,K¢y
WHERE Bliey IS NUTJ. WHERE iKey IS NULL
SELECT ﬁst-lectjist}
SELECT ‘ﬁsclltctJ-iat} FRDNI Tahluﬁ. A
FROM TableA A FULL OUTERJDIN TableB B
FULL OUTER JOIN Tableﬂ B ON Arley = Elie};
0H Alﬁe? = Elie}; WHERE AKey [S NUEEO
@1 CL. Muffatt, 2003 DR B-Kﬁir' l5 NULL

***************Ending Page***************

