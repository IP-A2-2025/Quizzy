***************Beginning Page***************
***************page number:1**************
g) Java"
Advanced Programming
Interfaces

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
What is an interface?
Webster: “a place at which independent and often
unrelated systems meet and communicate with
each other“, respecting a set of rules .
II

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
Contract, Protocol
- An interface describes a model, a contract.
- A class may implement that model, adhering to the
contract and strictly respecting its specifications.
lnterfaté '~ p Clasa
I ’ v Q
% b

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
[public] interface InterfaceName
[extends Superlnterfacel, Superlntex:face2...] {
/" Constant declaxations
Abstract methods
Default methods
Static methods */
)
Example:
public interface Student (
double MAXiGRADE : 5; *//publlc statJ: 51m)
vold sayHelloU; //;:ub1\r: ahatwct
double qetExamGrade (Exam exam);
)

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
class ClassName implements Interfacel, InterfaceZ, {
/* A concrete class that implements an interface
must specify code for all abstxact methods
declared by the interface */
)
Example:
publlc class CcmtherSclercEStLdEnt implements Student 4
private Strqu name;
pucllc coolean lSProgrsu'merU l return true; l
public VOld ssyl-lcllou 4
System.:>ut.prlntln("Eellc, 'ny ra'ne 15 " + neme);
l
public dOJble gelExame<xe<E><am exam) (
returr MAXiliRADE;
l
)

***************Ending Page***************


***************Beginning Page***************
***************page number:6**************
Common Denominator

~ Suppose we already have class hierarchies

i Person extends Entity

— Parrot extendsAnimal

i A|exa extends Robot public interface Talkative (
- All of them can “talk” > “1d talk";

— Person extends Entity implements Talkative

— Parrot extends Animal implements Talkative

— Alexa extends Robot implements Talkative
- Talkative[] noisy = (johnny, coco, alexa}

***************Ending Page***************

***************Beginning Page***************
***************page number:7**************
Interface — Reference Type
We may say that an ob'ect is of type X, where X is
an interface, if that object is an instance of a class
implementing the interface X.
Student student : new Computexsciencestudentﬁ;
stLdent.sayt-lello(); %bden%m¥reqmmmeH-H
Talkative Johnny : new PersonU; JUh'tny.'alk()7
Talkative coco : new Parker-f)? Coco.talkti?
qla-l-ka-El-v-eéaew—k—l—ka€—1—ve—t~)+
Autocloseable teaser : new FileReadert'TjsAxi/"M readernlnsei);
Autoclcseable con : DrlverManager.geiConnectiQnf)t can.close();
MEeHeseaei-HeaeeiérreWﬁKIu-Eeékeaiea-b-kaqwk

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Multlple Implementatlons
public interface Matrix (
vcld set(;nt row, lnt col, double value);
double gsuinr row, int cs1);
Matrix adtHMatrlx m);
Matrix mul1Matrlx m);
)
public class Defaulﬂllatrixlmpl implements Matrix t
pzlvate doubleU [1 data;
puDlJC DefaultMatrlxImplllnt rsws, Jnt eels) < .. )
)
public class Sparseblatzixhnpl implements Matrix (
prlvate inn] row;
prlvate lﬂtI] col;
pxlvate doubleH data;
puolic SparseMacrixImplunc rows, int cols) ( v >
)
public StatJC van main l String args [1H
Matrix a Z new DefaultkatrlxllrplUO, 1D); a.set(D,U, 123);
Matrix b Z new SparseMatrlxImpl (10, 10); b.5et(9,9, 456);
Matrix c Z a.add(b>:
)

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Interfaces and Abstract Classes

- Extending an abstract class imgoses a strong
relationship among two classes.

- Implementing an interface is much lighter: it only
specifies that a class is respecting a certain contract,
making sure it conforms to some specifications.

- Interfaces and abstract classes do not exclude each
other, they are used together in many situations:

~ List a the contract
¢ AbstractI-ist A the common behaviour
‘ LinkedList,

ArrayList a specific behaviour

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Evolving Interfaces
~ Add another abstract method to an interface —>
all classes that implement it will break.
public interface Matrix l
void resetO; /’wa add a new abstract method to the lﬂZEL'fJCQ
l
- Anticipate all uses for your interface and specify
it completely from the beginning!
- Create a new interface, extending the old one
— Old classes will use the old interface or upgrade to
the new interface.
- Use default methods.

***************Ending Page***************


***************Beginning Page***************
***************page number:11**************
Default Methods
- Default methods allow extending interfaces
without breaking existing implementations.
public interface Matrix (
default voxd tesetl) t
for (1"t 1 Z O,- 1 < roxvCountll; 1+7) [
for (1m 3 : c; 3 < wlmwwncn); 141 i
serll, II. 0);
l
l
~ Classes may override default methods
public class DefaultMacrixImpl mplemencs Maczix t
@Override
public void xesetO (
for l1n*[] raw: narnx)
Arrays.fllllrr)w, at;
l

***************Ending Page***************

***************Beginning Page***************
***************page number:12**************
Static Methods
- Static methods allow defining specific interface
methods and are identical with the ones defined
in classes.
- They belong to the interface/class only.
interface IA t
statue voxd £000 l Systu'vi.uut.prlntl"i"IA"l7 l
statue voxd barf) ( l
intexface IE extends IA (
statlc vcm £000 i Systemnzut‘prlnfinUIEWl; i
class E implements 15 4
statlc vold £000 l Syslem.ouL.pvint MW"); l
peleC sintl: ‘JOld mDJH(Strl“g argsﬂ)
1A.fc:>ilr JB.fool]; B.foo[i; Hrbn-H-r Brba-I-H-r
l

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Callback Methods
A callback is something that you pass to a method
as an argument (some piece of code).
Example: When a graph exp/oration algorithm
reaches a node, we want to execute some kind of
processing for that speciﬁc node.

,/ o
giﬂﬁ ,4 oiiiiifjg
If?“ ‘ ® ,f/fMj: :D
(£31 £051?) ‘@w +65%

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
public interface Nodeoncessing (
public void executeﬂlode u):
)
public =1“. Graph l
public void explozeﬂlodioncilsil-Ag E) (
if (exploration leached the node v1 <
fiexecutew);
)
)
)
//Implement various processing types - ,
class Print-30 iiwlemancs NodaProcassil-Ag 4
public void executemode v1 t
Systemxmtiprlntlrm"Nodul curent esce: " + v77
)
)
class PrlntEn implemnts NodeProcessing 4
public void executelNode v) (
System.out.pz1ntln("The current nude 15: " + v);
)
)

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Unstmq the ‘Yes from a folder
‘mm ,evamof;
publlc c1555 Llstflles (
puollc statlc vuld maZn l String [1 lrgs > \
F119 folder Z ~Zw F1;Z<".">:
Srnﬂqn 11er Z ioldez.1iut(new MyFiltex("nvp3"));
for (1n: 1 Z n; 1 < Llanlength ; 1 +Z> 4
Systemounpr'"Lan'st[v');
v
)
)
class MyFiltez implements FilenameFilter (
String extension;
puohr: MyFHter (Strwrvq extenswor] <
L"is.e><Lens\on Z exLensmn;
§
public boolean aecepnvne diz, String name) 4
return ndme.endsw;th["." + extension);
)
)

***************Ending Page***************


***************Beginning Page***************
***************page number:16**************
Anonymous Classes
Anonymous Class = Inner class used to create an object
of a specific type.
methcdmew Somelnterfaceﬂ l V

// Tvrplevrert \rtevface methods \
Example: ‘

WE ARE

foldez.list(new FilenameFilterO l ANONYMOUS

// Anorywous class

public boolean accept (File d;r, Str;ng name) 4

lerurn ( ndxne.ends'/\Iirh(".l>xr") );

l
l) r
Compile: U_t2:c‘l;13$$l.c1a55, U_t2:c‘las$$2.c1a55,

***************Ending Page***************

***************Beginning Page***************
***************page number:17**************
Comparlng Objects
=1“. Penen 4
privuti int code;
private String name:
puolxc Person Urvc code, String name ) l
tnisxode = code;
tnismame : name ;
>
puDlJc String tuStIlng 0 [
return code i " \t " + name;
)
)
class Sorting 4
public static v01d mam L Scrlng args [1» (
Person personsH e new PersonH];
parsonsIG] Z new Person (3, " Icnescu "I;
personsIl] Z new Persan (l, " VBSlJESCu "l;
persQnSIZ] e new Persan <2, " Georgescu "1,-
personsIB] Z new Person (4, " Popescu "I;
java.uti1.Arxays.soxt(pezsons) ; O
Systemmunprlntln ("The persons were sorted...">;
to: (mt i = o; 1 < persons. lenqth ; 1~+w
System_out.p11ntln (perssnshh;
)
)

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
lmposes a total ordering on the objects of a class (natural)
public interface Comparable (
int compareTQ (Object a);
)
class Person implements Comparable (
public int conlpazeTo (Object other) (
//returns: 0 if this=other, <0 if Lhis<other, >0 if this>other
lf (OLker :: 'lull ) erw rew NLllPolnLerExueleOnU;
1f (W other instanceof Persoana )>
throw new ClassliastXceptlon ("Uncomparahle Object51HH
Person pere e (Person) other;
reiJrn (thls.code e pers.code);
>
’ class Person lmplements Comparable<¥erson> l
@Overrlde
public lni c0mpareTu(Pezson o) ¢
)
)

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
A comparison function, which imposes a total ordering on some collection of
objects
imporL Javamulﬂ;
class Sorting (
public static VOld main ( Strlnq arqs [1) (
Person personsH s new Person [4];
personSHJ] , new Person <3, " lonescu "a;
personsU] : an Person 11, " Vasllescu "1;
personlel s new Person <2, " Georgescu "1;
personsm : new Person <4, " Popescu "b;
Arrays.sazt (persons, new Comparatoz<Pezson> () (
public int compare (Person p1, Person p2) (
return pl_getName() .compareTo(p2.qetName()1,‘
3
H;
Systemouppnncln("Orderd by name:");
System.out .prlntln (Arrays.toStrinq (persons) );
)
)

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Functional Interfaces

- Afunctional interface is any interface that
contains only one abstract method.

- Instead of using an anonymous class, you use
a lambda expression, omitting the name of the
interface and the name of the method.

Arraysrsort (persons, (Person pl, Person P2) -> l
return pl ‘getName () tamparete (pxgetwame () ) ;
l) r
@PunctionalInterface
public interface Comparator ( ...)

***************Ending Page***************


***************Beginning Page***************
***************page number:21**************
Method References
~ Sometimes a lambda expression does nothing
but call an existing method.
(‘lass Person i
eiihllc smut: 1r: LompareByAqeGerson a, Person b) r
return d.b1:ti\uay.compdrerrc(bmlniiddy):
i
1 Arraystsortwersons, (a, b) —> Persontcompareﬁthe(a,b))i
- In those cases, it's often clearer to refer to the
existing method by name:
Arrays v sort (persona , Person : :compazeique) ;

***************Ending Page***************

***************Beginning Page***************
***************page number:22**************
Marker Interfaces
- Interfaces that do not define any method.
interface Serializable {)
interface Cloneable f}
~ Their role is to associate some metadata to a
class, that will be useful at runtime.
class Person
implements Serializable, Cloneable f l
- A modern alternative: annotations
@Entityltable:"persons")
class Person ( l

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
Conclusions

~ An interface defines a set of specifications

- They are essential in seoarating the model from
the implementation.

- An interface is a common denominator between
unrelated classes.

~ Can be used as Reference Data Types

- Can be used to implement M

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Interface Naming
- Main indea: Interfaces describe app data types:
a Interfaces get the “best” name:
Service, List
— Classes get “implementation” names:
Servicelmpl implements Service i
ArrayList implements List
- Other idea:
— Interfaces get “I” names: lSen/ice, lList
— Classes get the “best” names:
Sen/ice implements lService,
ArrayList implements lList
- If describing abilities, they should be named using “able”
convention: Comparable, Iterable, Runnable, etc.

***************Ending Page***************

