***************Beginning Page***************
***************page number:1**************
Limbajul de asamblare.
F amilia Intel

***************Ending Page***************

***************Beginning Page***************
***************page number:2**************
Arhiletlllrl calcullloirelor 5i sixtelnﬂ d: operlre - ASM
Elemente de bazé (1)
' ﬁecare instrucgiune - 0 singuré operagie
— unei instrucgiuni intr-un limbaj de nivel inalt ii
corespund in general mai multe instrucgiuni in
limbaj de asamblare
- operanzi
i constante
— locayii de memorie
i regi$tli ai procesorului
1

***************Ending Page***************

***************Beginning Page***************
***************page number:3**************
Arhilectllra calcullloarelor 5i sixteme a: upmn - ASM
Elemente de baza (2)
~ variabilele sunt accesate prin speciﬁcarea
adresei lor in memorie
' regigtrii procesorului nu sunt accesibili din
limbajele de nivel inalt
i dar compilatorul ii poate folosi temporar in
locul vaﬂabilelor
i avantaj - vitezé de acces mai mare
—3

***************Ending Page***************

***************Beginning Page***************
***************page number:4**************
Arllilectura calcullloarelor 5i sisteme do 0pm“ - ASM
Procesoare Intel (32 bl'gl) - reg1§tr1
31 IS R 7 0
EDX _—— DX

t

***************Ending Page***************

***************Beginning Page***************
***************page number:5**************
Arhilectllra calcullloarelor 5i sixteme a: upmn - ASM
Dimensiunea regi§trilor
° EAX, EBX, ECX, EDX, ESI, EDI, EBP,
ESP - 32 biﬁ
' AX, BX, CX, DX, SI, DI, BP, SP - 16 bigi
i ﬁecare reprezinté jumétatea mai pugin
semniﬁcativi a registrului corespunzitor pe 32
bigi
° AH, AL, BH, BL, CH, CL, DH, DL - 8 bigi
i jumétz'lgile unor regi§tﬂ pe 16 bigi

***************Ending Page***************

***************Beginning Page***************
***************page number:6**************
Arhiletlllrl calcullloirelor 5i sixtelnE d: operlre - ASM
Reg1§tr1 spec1a11
' ESP
i reﬁne adrcsa vérfului stivci programului
i actualizat prin instrucgiunile dc lucru cu stiva
' EBP
i folosit de compilatoare in apelurile de funclii
' ace$ti regi§tri in general nu sunt utilizagi
deceit pentru scopurile mengionate mai sus
—6

***************Ending Page***************


***************Beginning Page***************
***************page number:7**************
Arhilectura calcullloarelor 5i sixteme a: upmn - ASM
Utlllzarea reg1§tr110r

~ memorarca de valori numerice - la fel ca

variabilele de memorie

i togi registrii anteriori
- formarea adreselor de memorie

i doar registrii pe 32 bigi

i in expresii mai complexe, care pot conﬁne mai

mulﬁ regi§tri $i constante

—7

***************Ending Page***************

***************Beginning Page***************
***************page number:8**************
Arhilectura calcullloarelor 5i sixteme a: 0pm“ - ASM
Formarea adreselor - variante (1)

' constanté

i ex‘: [ l O O 1
' valoarea unui registru

— ex; [EAX]
' suma dintre valoarea unui registru §i 0

constanté

*ex; [EBX+5]
—8

***************Ending Page***************

***************Beginning Page***************
***************page number:9**************
Arhilectura calcullloarelor 5i sixteme a: upmn - ASM
Formarea adreselor - variante (2)
' suma dintre valorile a doi regigtri
i ex‘: [ECX+ESI]
' suma dintre valorile a doi regigtri 5i 0
constanté
i 6X42 [EDX+EBP+1 4]
- un registru poate ﬁ inmultit cu 2/4/8
*6X.Z [EAX+EDI*2 ] , [ECX+EDX*4+5]
—9

***************Ending Page***************

***************Beginning Page***************
***************page number:10**************
Arhilectura calcullloarelor 5i sixteme a: upmn - ASM
Indicatori de conditii (l)
- aduc informagii suplimentare despre
rezultatele operagiilor tocmai executate
i separat de rezultatul propriu-Zis
- valorile lor pot ﬁ testate prin program
- singura forrné de a implementa structuri de
control in lirnbajul de asamblare
—u|

***************Ending Page***************

***************Beginning Page***************
***************page number:11**************
Arhilectura calcullloarelor 5i sixteme a: 0pm“ - ASM
Indicatori de condigii (2)

~ cel mai des utilizagi
Carry (C)
Overﬂow (O)
Zero (Z)

i 1 dacé rezultatul ultimei operagii este O; altfel O
Sign (S)

i 0 - rezultat pozitiv; 1 - rezultat negativ

***************Ending Page***************


***************Beginning Page***************
***************page number:12**************
Arhileclllrl calcullloarelor 5i sistelne d: operlre - ASM
Visual C++

' mediu de programare in care se pot intercala
u$0r instructiuni in limbaj de asamblare
i doar pentru programe pe 32 bigi

' programul in ansamblul séu este scris in
C/C++

- instrucgiunile in limbaj de asamblare pot
accesa regi§trii procesorului, dar gi
variabilele declarate in C/C++

.1

***************Ending Page***************

***************Beginning Page***************
***************page number:13**************
Arhilectura calcullloarelor 5i sixteme a: open“ - ASM
Sintaxé
' cuvint-cheie: iasm
' poate ﬁ urmat de
i 0 singuré instrucgiune
i un bloc dc instrucgiuni
i delimitarea blocurilor — la fel ca in C/C++
i separatorul intre instrucgiuni in blocuri
- linie nouﬁ (recomandat pentru claritate)
' caracterul "7 ”
—\_1

***************Ending Page***************

***************Beginning Page***************
***************page number:14**************
_asm mov eax,5;
int a;
_asm {

mov eax,5

mov a,10

***************Ending Page***************

***************Beginning Page***************
***************page number:15**************
Instructiuni aritmetice

***************Ending Page***************

***************Beginning Page***************
***************page number:16**************
Arhilectura calcullloarelor 5i sixteme a: 0pm“ - ASM
Operanzi (1)

- 3 categorii

i regigtri de uz general

— locaﬁi de memorie (variabile)

i constants
- reguli generals (pot exista exceptii)

i operanzii au aceea§i dimensiune

— primul/singurul operand este 5i destinayia unde

se depune rezultatul
\6

***************Ending Page***************


***************Beginning Page***************
***************page number:17**************
Arhilectura calcullloarelor 5i sixteme a: open“ - ASM
Operanzi (2)
' operagii binare
— primul operand nu poale ﬁ 0 constant?!
' deoarece nu ar putea memora rezultatul
— nu este permis ca ambii operanzi sé ﬁe locayii
dc mcmoric
' 1a procesoarele Intel
- se foneazé utilizarea regi$trilor
' vitezé mai mare
l7

***************Ending Page***************

***************Beginning Page***************
***************page number:18**************
Arhileclun calcullloarelor 5i sineme a: open" - ASM
Atribuire

' sintaxa

mov destina tie, sursa

' exemple

mov eax,ebx

mov CX , 5

mo v b l , [ e ax 1

mov [esi] , edx
—m

***************Ending Page***************

***************Beginning Page***************
***************page number:19**************
Arllilectura calcullloarelor 5i sisteme m 0pm“ - ASM
Dimensiunea operanzilor (l)
- un registru are mereu aceea§i dimensiune
- dar aceea$i constanté poate ocupa 1/2/4
octegi
i in funcgie de context
- 1a fel $1 un operand adresi de memori6
- regulﬁ: dacé unul din opsranzi este un
registru, celélalt are aceea§i dimensiune
—w

***************Ending Page***************

***************Beginning Page***************
***************page number:20**************
Arhilectura calcullloarelor 5i sixteme a: upmn - ASM
Dimensiunea operanzilor (2)

- dacé nici un operand nu este registru,

trebuie precizaté explicit dimensiunea lor
' cuvinte cheie

— byte ptr - operand pe l octet

, word ptr - operand pe 2 octep'

— dword ptr - operand pe 4 octegi
—zu

***************Ending Page***************

***************Beginning Page***************
***************page number:21**************
Arhilecturl calcullloarelor 5i sixleme a: openre - ASM
Exemple
mov al, 5 // 1 octet - dimensiunea
registrului al
mov bx, [esi] // 2 octeti - dimensiunea
registrului bx
mov byte ptr [ecx] , 5 // 1 octet
mov word ptr [ecx] , 5 // 2 octeti
mov dword ptr [ecx] , 5 //4 octeti

***************Ending Page***************


***************Beginning Page***************
***************page number:22**************
Arhilectllra calcullloarelor 5i sixteme a: upmn - ASM
Dimensiunea operanzilor (3)

- Visual C++z dacé locayia dc memorie este o
variabilé declaraté in C/C++, nu mai trebuie
precizaté explicit dimensiunea

i compilatorul 0 cun0a$te din declaragie
i §i deci poate genera instrucgiunea corecté
' atengie
— regula operanzilor de dimensiuni egale rimine
valabili
—u

***************Ending Page***************

***************Beginning Page***************
***************page number:23**************
Arhileclun calcullloarelor 5i sineme a: 0pm“ - ASM
Exemple
int a;
_asm mov a, 3;
' compilatorul va genera
mov dword ptr [.. .],3
int a;
_asm mov cx, a; //er0are, cx are 2 octegi
—1_1

***************Ending Page***************

***************Beginning Page***************
***************page number:24**************
Arhilectura calcullloarelor 5i sixteme a: upmn - ASM
Indicatori dc condigii
~ instrucgiunea de atribuire nu modiﬁcé
valorile indicatorilor de condigii
' acegtia igi péstreazé valorile pe care 1e
aveau dc la instrucgiunile anterioare
—u

***************Ending Page***************

***************Beginning Page***************
***************page number:25**************
Arhilectura calcullloarelor 5i sixteme a: open“ - ASM
Utlllzare practlca (1)

int a,b;

' cum se traduce linia de cod

a=b;

' varianta gregiti:

_asm mov a , b;

i ambii operanzi sunt locagii de memorie - eroare
—15

***************Ending Page***************

***************Beginning Page***************
***************page number:26**************
Arhilectura calcullloarelor 5i sixteme a: open“ - ASM
Utilizare practicé (2)
' varianta corecté:
_asm {
mov eax,b
[HOV a , eax
}
~ in general, pentm 0 instrucgiune C/C++ sunt
necesare mai multe in limbaj de asamblare
—zo

***************Ending Page***************

