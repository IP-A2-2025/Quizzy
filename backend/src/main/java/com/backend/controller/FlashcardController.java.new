package com.backend.controller;

import com.backend.dto.FlashcardResponseDTO;
import com.backend.model.Flashcard;
import com.backend.model.FlashcardProgress;
import com.backend.model.User;
import com.backend.service.FlashcardProgressService;
import com.backend.service.FlashcardService;
import com.backend.service.UserService;
import com.backend.utils.FlashcardImport;
import com.backend.utils.SpacedRepetitionAlgorithm;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.File;
import java.util.ArrayList;
// Calendar este folosit în SpacedRepetitionAlgorithm
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/Flashcard")
public class FlashcardController {

    private final FlashcardService flashcardService;
    private final FlashcardProgressService flashcardProgressService;
    private final UserService userService;

    @Autowired
    public FlashcardController(FlashcardService flashcardService,
                              FlashcardProgressService flashcardProgressService,
                              UserService userService) {
        this.flashcardService = flashcardService;
        this.flashcardProgressService = flashcardProgressService;
        this.userService = userService;
    }

    @GetMapping
    public ResponseEntity<List<Flashcard>> getAllFlashcards() {
        return ResponseEntity.ok(flashcardService.getAllFlashcards());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Flashcard> getFlashcardById(@PathVariable Long id) {
        Optional<Flashcard> flashcard = flashcardService.getFlashcardById(id);
        return flashcard.map(ResponseEntity::ok).orElseGet(() -> ResponseEntity.notFound().build());
    }

    @GetMapping("course/{courseId}")
    public ResponseEntity<List<Flashcard>> getFlashcardsByCourseId(@PathVariable Long courseId) {
        return ResponseEntity.ok(flashcardService.getFlashcardsByCourseId(courseId));
    }

    @PostMapping
    public ResponseEntity<Flashcard> createFlashcard(@RequestBody Flashcard flashcard) {
        return ResponseEntity.status(HttpStatus.CREATED).body(flashcardService.saveFlashcard(flashcard));
    }

    @PutMapping("/{id}")
    public ResponseEntity<Flashcard> updateFlashcard(@PathVariable Long id, @RequestBody Flashcard flashcard) {
        return ResponseEntity.ok(flashcardService.updateFlashcard(id, flashcard));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteFlashcard(@PathVariable Long id) {
        flashcardService.deleteFlashcard(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/user/{userId}")
    public ResponseEntity<List<Flashcard>> getByUserId(@PathVariable Integer userId) {
        return ResponseEntity.ok(flashcardService.getByUserId(userId));
    }

    @GetMapping("/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getByMaterialId(@PathVariable Long materialId) {
        return ResponseEntity.ok(flashcardService.getByMaterialId(materialId));
    }

    @GetMapping("/user/{userId}/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getByUserIdAndMaterialId(
            @PathVariable Integer userId,
            @PathVariable Long materialId) {
        return ResponseEntity.ok(flashcardService.getByUserIdAndMaterialId(userId, materialId));
    }

    @GetMapping("/page/{pageIndex}")
    public ResponseEntity<List<Flashcard>> getByPageIndex(@PathVariable Integer pageIndex) {
        return ResponseEntity.ok(flashcardService.getByPageIndex(pageIndex));
    }

    @GetMapping("/page/{pageIndex}/user/{userId}")
    public ResponseEntity<List<Flashcard>> getByPageIndexAndUserId(
            @PathVariable Integer pageIndex,
            @PathVariable Integer userId) {
        return ResponseEntity.ok(flashcardService.getByPageIndexAndUserId(pageIndex, userId));
    }

    @GetMapping("/page/{pageIndex}/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getByPageIndexAndMaterialId(
            @PathVariable Integer pageIndex,
            @PathVariable Long materialId) {
        return ResponseEntity.ok(flashcardService.getByPageIndexAndMaterialId(pageIndex, materialId));
    }

    @PostMapping("/generate")
    public ResponseEntity<Map<String, Object>> generateFlashcardsForCourse(@RequestParam String course) {
        try {
            String projectPath = new File("").getAbsolutePath();
            String coursePath = projectPath + "/courses/" + course;
            
            List<Flashcard> flashcards = FlashcardImport.parseCourseMaterials(coursePath);
            
            // Salvăm flashcardurile generate în baza de date
            flashcardService.saveAllFlashcards(flashcards);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Flashcards generated successfully");
            response.put("count", flashcards.size());
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    @PostMapping("/generate-all")
    public ResponseEntity<Map<String, Object>> generateAllFlashcards() {
        try {
            String projectPath = new File("").getAbsolutePath();
            String coursesPath = projectPath + "/courses";
            
            File coursesDir = new File(coursesPath);
            if (!coursesDir.exists() || !coursesDir.isDirectory()) {
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("status", "error");
                errorResponse.put("message", "Courses directory not found: " + coursesPath);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }
            
            int totalFlashcards = 0;
            List<Map<String, Object>> coursesStats = new ArrayList<>();
            
            File[] courseDirectories = coursesDir.listFiles(File::isDirectory);
            if (courseDirectories == null || courseDirectories.length == 0) {
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("status", "error");
                errorResponse.put("message", "No course directories found in " + coursesPath);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }
            
            for (File courseDir : courseDirectories) {
                Map<String, Object> courseStats = new HashMap<>();
                courseStats.put("courseName", courseDir.getName());
                
                try {
                    List<Flashcard> flashcards = FlashcardImport.parseCourseMaterials(courseDir.getAbsolutePath());
                    flashcardService.saveAllFlashcards(flashcards);
                    
                    totalFlashcards += flashcards.size();
                    courseStats.put("flashcardsGenerated", flashcards.size());
                    courseStats.put("status", "success");
                } catch (Exception e) {
                    courseStats.put("status", "error");
                    courseStats.put("message", e.getMessage());
                }
                
                coursesStats.add(courseStats);
            }
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Flashcards generated for all courses");
            response.put("totalFlashcards", totalFlashcards);
            response.put("courses", coursesStats);
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
    
    @GetMapping("/due/today")
    public ResponseEntity<List<Flashcard>> getDueForToday(@RequestParam("userId") Integer userId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        Date today = new Date();
        return ResponseEntity.ok(flashcardService.getDueFlashcards(userId, today, limit));
    }

    @GetMapping("/due")
    public ResponseEntity<List<Flashcard>> getDueUntilDate(@RequestParam("userId") Integer userId,
            @RequestParam("dueDate") @DateTimeFormat(pattern = "yyyy-MM-dd") Date dueDate,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        return ResponseEntity.ok(flashcardService.getDueFlashcards(userId, dueDate, limit));
    }
    
    @GetMapping("/random/user/{userId}")
    public ResponseEntity<List<Flashcard>> getRandomFlashcardsByUser(
            @PathVariable Integer userId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByUser(userId, limit));
    }
    
    @GetMapping("/prioritized/user/{userId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByUser(
            @PathVariable Integer userId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        return ResponseEntity.ok(flashcardService.getPrioritizedFlashcardsByUser(userId, limit));
    }
    
    @GetMapping("/random/course/{courseId}")
    public ResponseEntity<List<Flashcard>> getRandomFlashcardsByCourse(
            @PathVariable Long courseId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByCourse(courseId, limit));
    }
    
    @GetMapping("/prioritized/course/{courseId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByCourse(
            @PathVariable Long courseId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        return ResponseEntity.ok(flashcardService.getPrioritizedFlashcardsByCourse(courseId, limit));
    }
    
    @GetMapping("/random/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getRandomFlashcardsByMaterial(
            @PathVariable Long materialId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByMaterial(materialId, limit));
    }
    
    @GetMapping("/prioritized/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByMaterial(
            @PathVariable Long materialId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        return ResponseEntity.ok(flashcardService.getPrioritizedFlashcardsByMaterial(materialId, limit));
    }
    
    @GetMapping("/prioritized/material/{materialId}/user/{userId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByMaterialAndUser(
            @PathVariable Long materialId,
            @PathVariable Integer userId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        
        List<Flashcard> prioritizedFlashcards = flashcardService.getPrioritizedFlashcardsByMaterialAndUser(
                materialId, userId, limit);
        
        // Dacă nu există flashcarduri prioritizate, returnăm câteva aleatoare
        if (prioritizedFlashcards != null && !prioritizedFlashcards.isEmpty()) {
            return ResponseEntity.ok(prioritizedFlashcards);
        } else {
            // Fallback la flashcarduri aleatorii
            return ResponseEntity.ok(flashcardService.getRandomFlashcardsByMaterialAndUser(
                    materialId, userId, limit));
        }
    }
    
    /**
     * Endpoint pentru înregistrarea unui răspuns la un flashcard și actualizarea progresului
     * @param response DTO conținând ID-ul flashcard-ului, ID-ul utilizatorului și calitatea răspunsului
     * @return ResponseEntity cu statusul actualizării și detalii despre progresul modificat
     */
    /**
     * Endpoint pentru înregistrarea răspunsurilor la flashcarduri și actualizarea progresului utilizatorului
     * @param response DTO conținând ID-ul flashcard-ului, ID-ul utilizatorului și calitatea răspunsului
     * @return ResponseEntity cu statusul actualizării și detalii despre progresul modificat
     */
    @PostMapping("/response")
    public ResponseEntity<Map<String, Object>> recordFlashcardResponse(@RequestBody FlashcardResponseDTO response) {
        Map<String, Object> result = new HashMap<>();
        
        try {
            System.out.println("====== DIAGNOSTIC LOG: FlashcardController.recordFlashcardResponse ======");
            System.out.println("Primit răspuns pentru flashcard: " + response);
            
            // Convertim userId în Integer dacă este necesar
            Integer userId = null;
            Object userIdObj = response.getUserId();
            
            if (userIdObj instanceof Integer) {
                userId = (Integer) userIdObj;
            } else if (userIdObj instanceof String) {
                try {
                    userId = Integer.parseInt((String) userIdObj);
                    System.out.println("Am convertit userId din string '" + userIdObj + "' la Integer " + userId);
                } catch (NumberFormatException e) {
                    System.out.println("EROARE la conversia userId din string la Integer: " + e.getMessage());
                    result.put("status", "error");
                    result.put("message", "Format invalid pentru ID utilizator");
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
                }
            } else if (userIdObj != null) {
                try {
                    userId = Integer.parseInt(userIdObj.toString());
                    System.out.println("Am convertit userId din obiect de tip " + userIdObj.getClass().getName() +
                                 " la Integer " + userId);
                } catch (Exception e) {
                    System.out.println("EROARE la conversia userId: " + e.getMessage());
                    result.put("status", "error");
                    result.put("message", "Format invalid pentru ID utilizator");
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
                }
            }
        
            // Validăm datele primite
            if (response.getFlashcardId() == null) {
                result.put("status", "error");
                result.put("message", "Flashcard ID este obligatoriu");
                return ResponseEntity.badRequest().body(result);
            }
            
            if (userId == null) {
                result.put("status", "error");
                result.put("message", "User ID este obligatoriu");
                return ResponseEntity.badRequest().body(result);
            }
            
            System.out.println("Prelucrăm răspuns pentru flashcard ID " + response.getFlashcardId() + 
                          ", user ID " + userId + 
                          ", quality " + response.getQuality() + 
                          ", isCorrect " + response.isCorrect());
            
            // Verificăm dacă flashcardul există
            Optional<Flashcard> optionalFlashcard = flashcardService.getFlashcardById(response.getFlashcardId());
            if (!optionalFlashcard.isPresent()) {
                result.put("status", "error");
                result.put("message", "Flashcard cu ID " + response.getFlashcardId() + " nu există");
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
            }
            
            // Verificăm dacă utilizatorul există
            Optional<User> optionalUser = userService.findById(userId);
            if (!optionalUser.isPresent()) {
                result.put("status", "error");
                result.put("message", "Utilizator cu ID " + userId + " nu există");
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
            }
            
            // Obținem obiectele din opționale
            Flashcard flashcard = optionalFlashcard.get();
            User user = optionalUser.get();
            
            // Încercăm să găsim progresul existent pentru această pereche flashcard-utilizator
            FlashcardProgress existingProgress = flashcardProgressService.findByFlashcardAndUser(flashcard.getId(), userId);
            
            FlashcardProgress updatedProgress;
            
            if (existingProgress == null) {
                // Dacă nu există progres, creăm unul nou
                System.out.println("Nu există progres pentru flashcard ID " + flashcard.getId() + 
                              " și user ID " + userId + ". Creăm un nou progres.");
                
                // Creăm un nou obiect FlashcardProgress
                FlashcardProgress newProgress = new FlashcardProgress();
                newProgress.setFlashcard(flashcard);
                newProgress.setUser(user);
                newProgress.setEaseFactor(2.5); // Valoare inițială standard pentru SM-2
                newProgress.setRepetitions(0); // În loc de setConsecutiveCorrectAnswers
                newProgress.setInterval(1);  // Interval inițial de 1 zi
                newProgress.setDueDate(new Date()); // Setăm data curentă (în loc de setNextReviewDate)
                newProgress.setLastReviewed(new Date()); // Setăm data curentă ca ultima dată de revizuire
                
                // Actualizăm progresul cu algoritmul SM-2
                SpacedRepetitionAlgorithm.updateProgress(newProgress, response.getQuality());
                
                // Salvăm noul progres
                updatedProgress = flashcardProgressService.createFlashcardProgress(newProgress);
                
                System.out.println("Progres nou creat pentru user " + user.getEmail() + 
                              " și flashcard ID " + flashcard.getId() + 
                              " cu următoarea dată de revizuire: " + updatedProgress.getDueDate());
            } else {
                // Dacă există progres, îl actualizăm folosind algoritmul SM-2
                System.out.println("Actualizăm progresul existent pentru flashcard ID " + flashcard.getId() + 
                              " și user ID " + userId);
                
                // Actualizăm progresul cu algoritmul SM-2
                SpacedRepetitionAlgorithm.updateProgress(existingProgress, response.getQuality());
                
                // Salvăm progresul actualizat
                updatedProgress = flashcardProgressService.createFlashcardProgress(existingProgress);
                
                System.out.println("Progres actualizat pentru user " + user.getEmail() + 
                              " și flashcard ID " + flashcard.getId() + 
                              " cu următoarea dată de revizuire: " + updatedProgress.getDueDate());
            }
            
            // Pregătim rezultatul pentru client
            result.put("status", "success");
            result.put("message", "Progres actualizat cu succes");
            result.put("progress", updatedProgress);
            result.put("flashcardId", flashcard.getId());
            result.put("userId", user.getId());
            result.put("nextReview", updatedProgress.getDueDate());
            result.put("easeFactor", updatedProgress.getEaseFactor());
            result.put("interval", updatedProgress.getInterval());
            result.put("repetitions", updatedProgress.getRepetitions());
            
            System.out.println("Răspuns procesat cu succes pentru flashcard ID " + flashcard.getId() + 
                          ", următoarea revizuire la " + updatedProgress.getDueDate());
            System.out.println("============================================================================");
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            // Logging pentru excepții neașteptate
            System.out.println("EROARE NEAȘTEPTATĂ în procesarea răspunsului: " + e.getMessage());
            e.printStackTrace();
            
            result.put("status", "error");
            result.put("message", "Eroare internă la procesarea răspunsului: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        }
    }

    @GetMapping("/courses")
    public ResponseEntity<Map<String, Object>> getAvailableCourses() {
        try {
            String projectPath = new File("").getAbsolutePath();
            String coursesPath = projectPath + "/courses";

            File coursesDir = new File(coursesPath);
            if (!coursesDir.exists() || !coursesDir.isDirectory()) {
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("status", "error");
                errorResponse.put("message", "Courses directory not found: " + coursesPath);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            List<Map<String, Object>> courses = new ArrayList<>();
            File[] courseDirectories = coursesDir.listFiles(File::isDirectory);

            if (courseDirectories != null) {
                for (File courseDir : courseDirectories) {
                    Map<String, Object> courseInfo = new HashMap<>();
                    courseInfo.put("name", courseDir.getName());
                    courseInfo.put("path", courseDir.getAbsolutePath());

                    // Count flashcard files in this course
                    File[] flashcardFiles = courseDir.listFiles((dir, name) -> name.endsWith("_flashcards.txt"));
                    courseInfo.put("flashcardFiles", flashcardFiles != null ? flashcardFiles.length : 0);

                    courses.add(courseInfo);
                }
            }

            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("totalCourses", courses.size());
            response.put("courses", courses);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
}
