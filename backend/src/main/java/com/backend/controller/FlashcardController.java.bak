package com.backend.controller;

import com.backend.dto.FlashcardResponseDTO;
import com.backend.model.Flashcard;
import com.backend.model.FlashcardProgress;
import com.backend.model.User;
import com.backend.service.FlashcardProgressService;
import com.backend.service.FlashcardService;
import com.backend.service.UserService;
import com.backend.utils.FlashcardImport;
import com.backend.utils.SpacedRepetitionAlgorithm;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.File;
import java.util.ArrayList;
// Calendar este folosit în SpacedRepetitionAlgorithm
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/Flashcard")
public class FlashcardController {

    private final FlashcardService flashcardService;
    private final FlashcardProgressService flashcardProgressService;
    private final UserService userService;

    @Autowired
    private FlashcardImport flashcardImport;

    public FlashcardController(FlashcardService flashcardService, 
                              FlashcardProgressService flashcardProgressService,
                              UserService userService) {
        this.flashcardService = flashcardService;
        this.flashcardProgressService = flashcardProgressService;
        this.userService = userService;
    }

    @GetMapping
    public ResponseEntity<List<Flashcard>> getAllFlashcards() {
        return ResponseEntity.ok(flashcardService.getAllFlashcards());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Flashcard> getFlashcardById(@PathVariable Long id) {
        return flashcardService.getFlashcardById(id)
                .map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    @GetMapping("course/{courseId}")
    public ResponseEntity<List<Flashcard>> getFlashcardsByCourseId(@PathVariable Long courseId) {
        return ResponseEntity.ok(flashcardService.getFlashcardsByCourseId(courseId));
    }

    @PostMapping
    public ResponseEntity<Flashcard> createFlashcard(@RequestBody Flashcard flashcard) {
        Flashcard created = flashcardService.createFlashcard(flashcard);
        return ResponseEntity.ok(created);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Flashcard> updateFlashcard(@PathVariable Long id, @RequestBody Flashcard flashcard) {
        Flashcard updated = flashcardService.updateFlashcard(id, flashcard);
        return ResponseEntity.ok(updated);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteFlashcard(@PathVariable Long id) {
        flashcardService.deleteFlashcard(id);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/user/{userId}")
    public ResponseEntity<List<Flashcard>> getByUserId(@PathVariable Integer userId) {
        return ResponseEntity.ok(flashcardService.getByUserId(userId));
    }

    @GetMapping("/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getByMaterialId(@PathVariable Long materialId) {
        return ResponseEntity.ok(flashcardService.getByMaterialId(materialId));
    }

    @GetMapping("/due")
    public ResponseEntity<List<Flashcard>> getDueFlashcards(
            @RequestParam("date") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Date date,
            @RequestParam("userId") Integer userId) {
        return ResponseEntity.ok(flashcardService.getDueFlashcards(date, userId));
    }

    @GetMapping("/page/{pageIndex}")
    public ResponseEntity<List<Flashcard>> getByPageIndex(@PathVariable Integer pageIndex) {
        return ResponseEntity.ok(flashcardService.getByPageIndex(pageIndex));
    }

    @GetMapping("/page/{pageIndex}/user/{userId}")
    public ResponseEntity<List<Flashcard>> getByPageIndexAndUserId(
            @PathVariable Integer pageIndex,
            @PathVariable Integer userId) {
        return ResponseEntity.ok(flashcardService.getByPageIndexAndUserId(pageIndex, userId));
    }

    @GetMapping("/page/{pageIndex}/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getByPageIndexAndMaterialId(
            @PathVariable Integer pageIndex,
            @PathVariable Long materialId) {
        return ResponseEntity.ok(flashcardService.getByPageIndexAndMaterialId(pageIndex, materialId));
    }

    @PostMapping("/generate-course")
    public ResponseEntity<Map<String, Object>> generateFlashcardsForCourse(@RequestParam String course) {
        try {
            String projectPath = new File("").getAbsolutePath();
            String folderPath = projectPath + "/courses/" + course;

            int importedCount = flashcardImport.importFlashcardsFromDirectory(folderPath, 1);

            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("importedCount", importedCount);
            response.put("course", course);

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("course", course);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    @PostMapping("/generate-all")
    public ResponseEntity<Map<String, Object>> generateAllFlashcards() {
        try {
            String projectPath = new File("").getAbsolutePath();
            String coursesPath = projectPath + "/courses";

            File coursesDir = new File(coursesPath);
            if (!coursesDir.exists() || !coursesDir.isDirectory()) {
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("status", "error");
                errorResponse.put("message", "Courses directory not found: " + coursesPath);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            List<Map<String, Object>> courseResults = new ArrayList<>();
            int totalImported = 0;
            int successfulCourses = 0;
            int failedCourses = 0;

            File[] courseDirectories = coursesDir.listFiles(File::isDirectory);
            if (courseDirectories == null || courseDirectories.length == 0) {
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("status", "error");
                errorResponse.put("message", "No course directories found in: " + coursesPath);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            for (File courseDir : courseDirectories) {
                String courseName = courseDir.getName();
                Map<String, Object> courseResult = new HashMap<>();
                courseResult.put("course", courseName);

                try {
                    int courseImported = flashcardImport.importFlashcardsFromDirectory(courseDir.getAbsolutePath(), 1);
                    courseResult.put("status", "success");
                    courseResult.put("importedCount", courseImported);
                    totalImported += courseImported;
                    successfulCourses++;

                    System.out.println("Successfully imported " + courseImported + " flashcards from course: " + courseName);

                } catch (Exception e) {
                    courseResult.put("status", "error");
                    courseResult.put("message", e.getMessage());
                    courseResult.put("importedCount", 0);
                    failedCourses++;

                    System.err.println("Failed to import flashcards from course " + courseName + ": " + e.getMessage());
                }

                courseResults.add(courseResult);
            }

            Map<String, Object> response = new HashMap<>();
            response.put("status", "completed");
            response.put("totalImported", totalImported);
            response.put("totalCourses", courseDirectories.length);
            response.put("successfulCourses", successfulCourses);
            response.put("failedCourses", failedCourses);
            response.put("courseResults", courseResults);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", e.getMessage());

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }


    /**
     * Endpoint to retrieve a limited number of random flashcards
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the randomly selected flashcards
     */
    @GetMapping("/random")
    public ResponseEntity<List<Flashcard>> getRandomFlashcards(
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " random flashcards");
        return ResponseEntity.ok(flashcardService.getRandomFlashcards(limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of prioritized flashcards
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the prioritized flashcards
     */
    @GetMapping("/prioritized")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcards(
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " prioritized flashcards");
        return ResponseEntity.ok(flashcardService.getRandomFlashcards(limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of random flashcards for a specific user
     * @param userId The user ID
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the randomly selected flashcards for the user
     */
    @GetMapping("/random/user/{userId}")
    public ResponseEntity<List<Flashcard>> getRandomFlashcardsByUserId(
            @PathVariable Integer userId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " random flashcards for user " + userId);
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByUserId(userId, limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of prioritized flashcards for a specific user
     * @param userId The user ID
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the prioritized flashcards for the user
     */
    @GetMapping("/prioritized/user/{userId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByUserId(
            @PathVariable Integer userId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " prioritized flashcards for user " + userId);
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByUserId(userId, limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of random flashcards for a specific course
     * @param courseId The course ID
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the randomly selected flashcards from the course
     */
    @GetMapping("/random/course/{courseId}")
    public ResponseEntity<List<Flashcard>> getRandomFlashcardsByCourseId(
            @PathVariable Long courseId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " random flashcards for course " + courseId);
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByCourseId(courseId, limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of prioritized flashcards for a specific course
     * @param courseId The course ID
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the prioritized flashcards from the course
     */
    @GetMapping("/prioritized/course/{courseId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByCourseId(
            @PathVariable Long courseId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " prioritized flashcards for course " + courseId);
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByCourseId(courseId, limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of random flashcards for a specific material
     * @param materialId The material ID
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the randomly selected flashcards from the material
     */
    @GetMapping("/random/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getRandomFlashcardsByMaterialId(
            @PathVariable Long materialId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " random flashcards for material " + materialId);
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByMaterialId(materialId, limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of prioritized flashcards for a specific material
     * @param materialId The material ID
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the prioritized flashcards from the material
     */
    @GetMapping("/prioritized/material/{materialId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByMaterialId(
            @PathVariable Long materialId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " prioritized flashcards for material " + materialId);
        return ResponseEntity.ok(flashcardService.getRandomFlashcardsByMaterialId(materialId, limit));
    }
    
    /**
     * Endpoint to retrieve a limited number of prioritized flashcards for a specific material and user
     * @param materialId The material ID
     * @param userId The user ID
     * @param limit The maximum number of flashcards to return (default: 10)
     * @return A ResponseEntity containing the prioritized flashcards from the material for the user
     */
    @GetMapping("/prioritized/material/{materialId}/user/{userId}")
    public ResponseEntity<List<Flashcard>> getPrioritizedFlashcardsByMaterialIdAndUserId(
            @PathVariable Long materialId,
            @PathVariable Integer userId,
            @RequestParam(value = "limit", defaultValue = "10") int limit) {
        System.out.println("Retrieving " + limit + " prioritized flashcards for material " + materialId + 
                       " and user " + userId);
        
        // Adăugăm log-uri pentru debugging
        List<Flashcard> allFlashcards = flashcardService.getByMaterialId(materialId);
        System.out.println("Total flashcards found for material " + materialId + ": " + 
                          (allFlashcards != null ? allFlashcards.size() : 0));
        
        List<FlashcardProgress> progress = flashcardProgressService.getByUserIdAndMaterialId(userId, materialId);
        System.out.println("Total progress records found for material " + materialId + " and user " + userId + ": " + 
                          (progress != null ? progress.size() : 0));
        
        List<Flashcard> prioritizedFlashcards = flashcardService.getRandomFlashcardsByMaterialIdAndUserId(materialId, userId, limit);
        System.out.println("Prioritized flashcards returned: " + 
                          (prioritizedFlashcards != null ? prioritizedFlashcards.size() : 0));
        
        if (prioritizedFlashcards != null && !prioritizedFlashcards.isEmpty()) {
            System.out.println("Primul flashcard returnat: ID=" + prioritizedFlashcards.get(0).getId() + 
                           ", Question=" + prioritizedFlashcards.get(0).getQuestion());
        } else {
            System.out.println("Nu s-au găsit flashcarduri prioritizate pentru materialul " + materialId + 
                           " și utilizatorul " + userId);
        }
        
        return ResponseEntity.ok(prioritizedFlashcards);
    }
    
    /**
     * Endpoint pentru înregistrarea unui răspuns la un flashcard și actualizarea progresului
     * @param response DTO conținând ID-ul flashcard-ului, ID-ul utilizatorului și calitatea răspunsului
     * @return ResponseEntity cu statusul actualizării și detalii despre progresul modificat
     */
    /**
     * Endpoint pentru înregistrarea răspunsurilor la flashcarduri și actualizarea progresului utilizatorului
     * @param response DTO conținând ID-ul flashcard-ului, ID-ul utilizatorului și calitatea răspunsului
     * @return ResponseEntity cu statusul actualizării și detalii despre progresul modificat
     */
    @PostMapping("/response")
    public ResponseEntity<Map<String, Object>> recordFlashcardResponse(@RequestBody FlashcardResponseDTO response) {
        Map<String, Object> result = new HashMap<>();
        
        try {
            System.out.println("====== DIAGNOSTIC LOG: FlashcardController.recordFlashcardResponse ======");
            System.out.println("Primit răspuns pentru flashcard: " + response);
            
            // Convertim userId în Integer dacă este necesar
            Integer userId = null;
            Object userIdObj = response.getUserId();
            
            if (userIdObj instanceof Integer) {
                userId = (Integer) userIdObj;
            } else if (userIdObj instanceof String) {
                try {
                    userId = Integer.parseInt((String) userIdObj);
                    System.out.println("Am convertit userId din string '" + userIdObj + "' la Integer " + userId);
                } catch (NumberFormatException e) {
                    System.out.println("EROARE la conversia userId din string la Integer: " + e.getMessage());
                    result.put("status", "error");
                    result.put("message", "Format invalid pentru ID utilizator");
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
                }
            } else if (userIdObj != null) {
                try {
                    userId = Integer.parseInt(userIdObj.toString());
                    System.out.println("Am convertit userId din obiect de tip " + userIdObj.getClass().getName() +
                                 " la Integer " + userId);
                } catch (Exception e) {
                    System.out.println("EROARE la conversia userId: " + e.getMessage());
                    result.put("status", "error");
                    result.put("message", "Format invalid pentru ID utilizator");
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
                }
            }
        
        // Validăm datele primite
        if (response.getFlashcardId() == null) {
            result.put("status", "error");
            result.put("message", "Flashcard ID este obligatoriu");
            return ResponseEntity.badRequest().body(result);
        }
        
        if (userId == null) {
            result.put("status", "error");
            result.put("message", "User ID este obligatoriu");
            return ResponseEntity.badRequest().body(result);
        }
        
        System.out.println("Prelucrăm răspuns pentru flashcard ID " + response.getFlashcardId() + 
                      ", user ID " + userId + 
                      ", quality " + response.getQuality() + 
                      ", isCorrect " + response.isCorrect());
        
        // Verificăm dacă flashcardul există
        Optional<Flashcard> optionalFlashcard = flashcardService.getFlashcardById(response.getFlashcardId());
        if (!optionalFlashcard.isPresent()) {
            result.put("status", "error");
            result.put("message", "Flashcard cu ID " + response.getFlashcardId() + " nu există");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
        }
        
        // Verificăm dacă utilizatorul există
        Optional<User> optionalUser = userService.findById(userId);
        if (!optionalUser.isPresent()) {
            result.put("status", "error");
            result.put("message", "Utilizator cu ID " + userId + " nu există");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
        }
        
        // Obținem obiectele din opționale
        Flashcard flashcard = optionalFlashcard.get();
        User user = optionalUser.get();
        
        // Încercăm să găsim progresul existent pentru această pereche flashcard-utilizator
        FlashcardProgress existingProgress = flashcardProgressService.findByFlashcardAndUser(flashcard.getId(), userId);
        
        FlashcardProgress updatedProgress;
        
        if (existingProgress == null) {
            // Dacă nu există progres, creăm unul nou
            System.out.println("Nu există progres pentru flashcard ID " + flashcard.getId() + 
                          " și user ID " + userId + ". Creăm un nou progres.");
            
            // Creăm un nou obiect FlashcardProgress
            FlashcardProgress newProgress = new FlashcardProgress();
            newProgress.setFlashcard(flashcard);
            newProgress.setUser(user);
            newProgress.setEaseFactor(2.5); // Valoare inițială standard pentru SM-2
            newProgress.setRepetitions(0); // În loc de setConsecutiveCorrectAnswers
            newProgress.setInterval(1);  // Interval inițial de 1 zi
            newProgress.setDueDate(new Date()); // Setăm data curentă (în loc de setNextReviewDate)
            newProgress.setLastReviewed(new Date()); // Setăm data curentă ca ultima dată de revizuire
            
            // Actualizăm progresul cu algoritmul SM-2
            SpacedRepetitionAlgorithm.updateProgress(newProgress, response.getQuality());
            
            // Salvăm noul progres
            updatedProgress = flashcardProgressService.createFlashcardProgress(newProgress);
            
            System.out.println("Progres nou creat pentru user " + user.getEmail() + 
                          " și flashcard ID " + flashcard.getId() + 
                          " cu următoarea dată de revizuire: " + updatedProgress.getDueDate());
        } else {
            // Dacă există progres, îl actualizăm folosind algoritmul SM-2
            System.out.println("Actualizăm progresul existent pentru flashcard ID " + flashcard.getId() + 
                          " și user ID " + userId);
            
            // Actualizăm progresul cu algoritmul SM-2
            SpacedRepetitionAlgorithm.updateProgress(existingProgress, response.getQuality());
            
            // Salvăm progresul actualizat
            updatedProgress = flashcardProgressService.createFlashcardProgress(existingProgress);
            
            System.out.println("Progres actualizat pentru user " + user.getEmail() + 
                          " și flashcard ID " + flashcard.getId() + 
                          " cu următoarea dată de revizuire: " + updatedProgress.getDueDate());
        }
        
        // Pregătim rezultatul pentru client
        result.put("status", "success");
        result.put("message", "Progres actualizat cu succes");
        result.put("progress", updatedProgress);
        result.put("flashcardId", flashcard.getId());
        result.put("userId", user.getId());
        result.put("nextReview", updatedProgress.getDueDate());
        result.put("easeFactor", updatedProgress.getEaseFactor());
        result.put("interval", updatedProgress.getInterval());
        result.put("repetitions", updatedProgress.getRepetitions());
        
        System.out.println("Răspuns procesat cu succes pentru flashcard ID " + flashcard.getId() + 
                      ", următoarea revizuire la " + updatedProgress.getDueDate());
        System.out.println("============================================================================");
        
        return ResponseEntity.ok(result);
        
    } catch (Exception e) {
        // Logging pentru excepții neașteptate
        System.out.println("EROARE NEAȘTEPTATĂ în procesarea răspunsului: " + e.getMessage());
        e.printStackTrace();
        
        result.put("status", "error");
        result.put("message", "Eroare internă la procesarea răspunsului: " + e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
    }
}

@GetMapping("/courses")
public ResponseEntity<Map<String, Object>> getAvailableCourses() {
    try {
        String projectPath = new File("").getAbsolutePath();
        String coursesPath = projectPath + "/courses";

        File coursesDir = new File(coursesPath);
        if (!coursesDir.exists() || !coursesDir.isDirectory()) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", "Courses directory not found: " + coursesPath);
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
        }

        List<Map<String, Object>> courses = new ArrayList<>();
        File[] courseDirectories = coursesDir.listFiles(File::isDirectory);

        if (courseDirectories != null) {
            for (File courseDir : courseDirectories) {
                Map<String, Object> courseInfo = new HashMap<>();
                courseInfo.put("name", courseDir.getName());
                courseInfo.put("path", courseDir.getAbsolutePath());

                // Count flashcard files in this course
                File[] flashcardFiles = courseDir.listFiles((dir, name) -> name.endsWith("_flashcards.txt"));
                courseInfo.put("flashcardFiles", flashcardFiles != null ? flashcardFiles.length : 0);

                courses.add(courseInfo);
            }
        }

        Map<String, Object> response = new HashMap<>();
        response.put("status", "success");
        response.put("totalCourses", courses.size());
        response.put("courses", courses);

        return ResponseEntity.ok(response);

    } catch (Exception e) {
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("status", "error");
        errorResponse.put("message", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}